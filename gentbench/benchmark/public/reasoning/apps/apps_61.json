{
    "problem": "You are an expert Python programmer, and here is your task: The new camp by widely-known over the country Spring Programming Camp is going to start soon. Hence, all the team of friendly curators and teachers started composing the camp's schedule. After some continuous discussion, they came up with a schedule $s$, which can be represented as a binary string, in which the $i$-th symbol is '1' if students will write the contest in the $i$-th day and '0' if they will have a day off.\n\nAt the last moment Gleb said that the camp will be the most productive if it runs with the schedule $t$ (which can be described in the same format as schedule $s$). Since the number of days in the current may be different from number of days in schedule $t$, Gleb required that the camp's schedule must be altered so that the number of occurrences of $t$ in it as a substring is maximum possible. At the same time, the number of contest days and days off shouldn't change, only their order may change.\n\nCould you rearrange the schedule in the best possible way?\n\n\n-----Input-----\n\nThe first line contains string $s$ ($1 \\leqslant |s| \\leqslant 500\\,000$), denoting the current project of the camp's schedule.\n\nThe second line contains string $t$ ($1 \\leqslant |t| \\leqslant 500\\,000$), denoting the optimal schedule according to Gleb.\n\nStrings $s$ and $t$ contain characters '0' and '1' only.\n\n\n-----Output-----\n\nIn the only line print the schedule having the largest number of substrings equal to $t$. Printed schedule should consist of characters '0' and '1' only and the number of zeros should be equal to the number of zeros in $s$ and the number of ones should be equal to the number of ones in $s$.\n\nIn case there multiple optimal schedules, print any of them.\n\n\n-----Examples-----\nInput\n101101\n110\n\nOutput\n110110\nInput\n10010110\n100011\n\nOutput\n01100011\n\nInput\n10\n11100\n\nOutput\n01\n\n\n-----Note-----\n\nIn the first example there are two occurrences, one starting from first position and one starting from fourth position.\n\nIn the second example there is only one occurrence, which starts from third position. Note, that the answer is not unique. For example, if we move the first day (which is a day off) to the last position, the number of occurrences of $t$ wouldn't change.\n\nIn the third example it's impossible to make even a single occurrence.",
    "solution": "[\"from sys import stdin,stdout\\n# stdout = open('output.txt', 'w+')\\n# stdin = open('input.txt','r+')\\n\\n\\nfrom collections import Counter\\ndef prefixsuffixmatch(s):\\n\\tpi_table=[0 for i in range(len(s))]\\n\\tfor i in range(1,len(s)):\\n\\t\\ty=pi_table[i-1]\\n\\t\\twhile s[i]!=s[y] and y!=0:\\n\\t\\t\\ty=pi_table[y-1]\\n\\t\\tif s[i]==s[y]:\\n\\t\\t\\ty+=1\\n\\t\\tpi_table[i]=y\\n\\treturn pi_table\\ndef canprint(a,b):\\n\\tif a['0']>=b['0'] and a['1']>=b['1']:\\n\\t\\treturn True\\n\\treturn False\\n\\ndef flushit(s):\\n\\tif '0' in s:\\n\\t\\tstdout.write('0'* s['0'])\\n\\tif '1' in s:\\n\\t\\tstdout.write('1'* s['1'])\\ndef fillit(x):\\n\\tif '0' not in x:\\n\\t\\tx['0']=0\\n\\tif '1' not in x:\\n\\t\\tx['1']=0\\n\\treturn x\\n\\t\\ns=stdin.readline().strip();counter_s=fillit(Counter(s))\\nt=stdin.readline().strip();counter_t=fillit(Counter(t))\\nt_pi_table=prefixsuffixmatch(t)\\nlongest_match=t_pi_table[-1]\\n\\nrepeating_part=t[longest_match:]\\n\\ncounter_repeating_part=fillit(Counter(repeating_part))\\n\\n\\n\\n\\nif len(counter_s)==2 and len(counter_t)==2:\\n\\tif counter_s['0']>=counter_t['0'] and counter_s['1']>=counter_t['1']:\\n\\t\\tstdout.write(t);counter_s['0']-=counter_t['0'];counter_s['1']-=counter_t['1'];\\n\\n\\n\\t# while canprint(counter_s,counter_repeating_part)==True:\\n\\t# \\tstdout.write(repeating_part);\\n\\t# \\tcounter_s['0']-=counter_repeating_part['0'];\\n\\t# \\tcounter_s['1']-=counter_repeating_part['1'];\\n\\n\\tif '0' in counter_repeating_part and '1' in counter_repeating_part:\\n\\t\\tif counter_repeating_part['0']>0 and counter_repeating_part['1']>0:\\n\\t\\t\\tr=min(counter_s['0']//counter_repeating_part['0'],counter_s['1']//counter_repeating_part['1'])\\n\\t\\t\\tstdout.write(repeating_part*r);\\n\\t\\t\\tcounter_s['0']-=(r*counter_repeating_part['0']);\\n\\t\\t\\tcounter_s['1']-=(r*counter_repeating_part['1']);\\n\\tflushit(counter_s);\\n\\n\\n\", \"s = input()\\nt = input()\\noverlap = t\\ntt = ''\\nfor i in range(len(t) - 1):\\n    tt = tt + t[i]\\n    if (t.endswith(tt)):\\n        overlap = t[i + 1:]\\nzro = s.count('0')\\nmek = s.count('1')\\nzro_tum = t.count('0')\\nmek_tum = t.count('1')\\nzro_toxum = overlap.count('0')\\nmek_toxum = overlap.count('1')\\n\\nif (zro >= zro_tum and mek >= mek_tum):\\n    print(t, end='')\\n    zro -= zro_tum\\n    mek -= mek_tum\\nif zro_toxum:\\n    k = zro//zro_toxum\\nelse:\\n    k = 10000000000\\nif mek_toxum:\\n    n = mek//mek_toxum\\nelse:\\n    n = 10000000000\\nans = min(n, k)\\nprint(overlap * ans, end='')\\nzro -= zro_toxum * ans\\nmek -= mek_toxum * ans\\nprint('0' * zro + '1' * mek)\"]",
    "test": "{\n  \"inputs\": [\n    \"101101\\n110\\n\",\n    \"10010110\\n100011\\n\",\n    \"10\\n11100\\n\",\n    \"11000000\\n0\\n\",\n    \"10100110\\n10\\n\",\n    \"10101000\\n101\\n\",\n    \"11010010\\n11010\\n\",\n    \"00101010\\n01101011\\n\",\n    \"11111111\\n1\\n\",\n    \"11011000\\n10\\n\",\n    \"11111111\\n0000\\n\",\n    \"11111111\\n1111\\n\",\n    \"11111111\\n11111110\\n\",\n    \"11100100\\n01101001\\n\",\n    \"10000111100011111100010100110001100110011100001100\\n0001000011101001110111011\\n\",\n    \"01001101001011100000100110001010010010111101100100\\n00001000010011010011111000001111000011011101011000\\n\",\n    \"00000000000000000000000000000000000000000000000000\\n000000000000000000000000000000\\n\",\n    \"10000111\\n10101\\n\",\n    \"00000000000000000000000000000000000000000000000000\\n111111111111111111111111111111\\n\",\n    \"01110100\\n101\\n\",\n    \"11011000\\n11010\\n\",\n    \"00010101\\n00101010\\n\",\n    \"00000000\\n0000\\n\",\n    \"00000000\\n1111\\n\",\n    \"11001111111000110010000001011001001011111101110110\\n1\\n\",\n    \"11111111010110101100010110110110111001111010000110\\n0010\\n\",\n    \"11100010100111101011101101011011011100010001111001\\n0000011001\\n\",\n    \"00010000111010011101110110010110100010001101001110\\n1011111000111010111001111\\n\",\n    \"00001000010011010011111000001111000011011101011000\\n01101111110001001101100000001010110110101100111110\\n\",\n    \"11111111111111111111111111111111111111111111111111\\n1\\n\",\n    \"11111111111111111111111111111111111111111111111111\\n1111\\n\",\n    \"01101111111111010010111011001001111000000010000011\\n1110001010\\n\",\n    \"11111111111111111111111111111111111111111111111111\\n000000000000000000000000000000\\n\",\n    \"11111111111111111111111111111111111111111111111111\\n111111111111111111111111111111\\n\",\n    \"11111111111111111111111111111111111111111111111111\\n11111111111111111111111111111111111111111111111110\\n\",\n    \"01101101110111000010011100000010110010100101011001\\n01100001111011000011\\n\",\n    \"11110011010010001010010010100010110110110101001111\\n01101001100101101001011001101001\\n\",\n    \"0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101\\n000000000000000000000000000000000000000000000000000111011100110101100101000000111\\n\",\n    \"0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101\\n0000000000000000000000000000000000000000000000000010110101111001100010000011110100100000000011111\\n\",\n    \"0101011\\n0101\\n\",\n    \"1111111111111111111111111111111111111111111110000000000000000000000000000000000000000\\n111000011\\n\"\n  ],\n  \"outputs\": [\n    \"110110\",\n    \"10001101\",\n    \"01\",\n    \"00000011\",\n    \"10101010\",\n    \"10101000\",\n    \"11010001\",\n    \"01011000\",\n    \"11111111\",\n    \"10101010\",\n    \"11111111\",\n    \"11111111\",\n    \"11111111\",\n    \"01101001\",\n    \"00010000111010011101110110000000000000011111111111\",\n    \"00001000010011010011111000001111000011011101011000\",\n    \"00000000000000000000000000000000000000000000000000\",\n    \"10101010\",\n    \"00000000000000000000000000000000000000000000000000\",\n    \"10101010\",\n    \"11010001\",\n    \"00101010\",\n    \"00000000\",\n    \"00000000\",\n    \"11111111111111111111111111110000000000000000000000\",\n    \"00100100100100100100100100101111111111111111111111\",\n    \"00000110010000011001000001100111111111111111111111\",\n    \"10111110001110101110011110000000000000000001111111\",\n    \"00000000000000000000000000001111111111111111111111\",\n    \"11111111111111111111111111111111111111111111111111\",\n    \"11111111111111111111111111111111111111111111111111\",\n    \"11100010101110001010111000101011100010100001111111\",\n    \"11111111111111111111111111111111111111111111111111\",\n    \"11111111111111111111111111111111111111111111111111\",\n    \"11111111111111111111111111111111111111111111111111\",\n    \"01100001111011000011110110000111101100001100000011\",\n    \"01101001100101101001011001101001000000001111111111\",\n    \"0000000000000000000000000000000000000000000000000001110111001101011001010000001110000000000000000000000000000000000000000000000000001110111001101011001010000001110000000000000000000000000000000000000000000000000001110111001101011001010000001110000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\",\n    \"0000000000000000000000000000000000000000000000000010110101111001100010000011110100100000000011111000000000000000000000000000000000000000000000000001011010111100110001000001111010010000000001111100000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\",\n    \"0101011\",\n    \"1110000111000011100001110000111000011100001110000111000011100001110000111111111111111\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}