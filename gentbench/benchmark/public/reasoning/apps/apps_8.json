{
    "problem": "You are an expert Python programmer, and here is your task: \u00c6sir - CHAOS \u00c6sir - V.\n\n\"Everything has been planned out. No more hidden concerns. The condition of Cytus is also perfect.\n\nThe time right now...... 00:01:12......\n\nIt's time.\"\n\nThe emotion samples are now sufficient. After almost 3 years, it's time for Ivy to awake her bonded sister, Vanessa.\n\nThe system inside A.R.C.'s Library core can be considered as an undirected graph with infinite number of processing nodes, numbered with all positive integers ($1, 2, 3, \\ldots$). The node with a number $x$ ($x > 1$), is directly connected with a node with number $\\frac{x}{f(x)}$, with $f(x)$ being the lowest prime divisor of $x$.\n\nVanessa's mind is divided into $n$ fragments. Due to more than 500 years of coma, the fragments have been scattered: the $i$-th fragment is now located at the node with a number $k_i!$ (a factorial of $k_i$).\n\nTo maximize the chance of successful awakening, Ivy decides to place the samples in a node $P$, so that the total length of paths from each fragment to $P$ is smallest possible. If there are multiple fragments located at the same node, the path from that node to $P$ needs to be counted multiple times.\n\nIn the world of zeros and ones, such a requirement is very simple for Ivy. Not longer than a second later, she has already figured out such a node.\n\nBut for a mere human like you, is this still possible?\n\nFor simplicity, please answer the minimal sum of paths' lengths from every fragment to the emotion samples' assembly node $P$.\n\n\n-----Input-----\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^6$)\u00a0\u2014 number of fragments of Vanessa's mind.\n\nThe second line contains $n$ integers: $k_1, k_2, \\ldots, k_n$ ($0 \\le k_i \\le 5000$), denoting the nodes where fragments of Vanessa's mind are located: the $i$-th fragment is at the node with a number $k_i!$.\n\n\n-----Output-----\n\nPrint a single integer, denoting the minimal sum of path from every fragment to the node with the emotion samples (a.k.a. node $P$).\n\nAs a reminder, if there are multiple fragments at the same node, the distance from that node to $P$ needs to be counted multiple times as well.\n\n\n-----Examples-----\nInput\n3\n2 1 4\n\nOutput\n5\n\nInput\n4\n3 1 4 4\n\nOutput\n6\n\nInput\n4\n3 1 4 1\n\nOutput\n6\n\nInput\n5\n3 1 4 1 5\n\nOutput\n11\n\n\n\n-----Note-----\n\nConsidering the first $24$ nodes of the system, the node network will look as follows (the nodes $1!$, $2!$, $3!$, $4!$ are drawn bold):\n\n[Image]\n\nFor the first example, Ivy will place the emotion samples at the node $1$. From here:\n\n  The distance from Vanessa's first fragment to the node $1$ is $1$.  The distance from Vanessa's second fragment to the node $1$ is $0$.  The distance from Vanessa's third fragment to the node $1$ is $4$. \n\nThe total length is $5$.\n\nFor the second example, the assembly node will be $6$. From here:\n\n  The distance from Vanessa's first fragment to the node $6$ is $0$.  The distance from Vanessa's second fragment to the node $6$ is $2$.  The distance from Vanessa's third fragment to the node $6$ is $2$.  The distance from Vanessa's fourth fragment to the node $6$ is again $2$. \n\nThe total path length is $6$.",
    "solution": "[\"T = 1\\nfor test_no in range(T):\\n\\tMAXK = 5000\\n\\tn = int(input())\\n\\tcnt = [0] * (MAXK + 1)\\n\\tprimeExponential = [[0 for j in range(MAXK + 1)] for i in range(MAXK + 1)]\\n\\n\\tline, num = (input() + ' '), 0\\n\\tfor c in line:\\n\\t\\tif c != ' ': num = num * 10 + (ord(c) - 48)\\n\\t\\telse:\\n\\t\\t\\tcnt[num] += 1\\n\\t\\t\\tnum = 0\\n\\n\\tfor i in range(2, MAXK + 1):\\n\\t\\tfor j in range(0, MAXK + 1): primeExponential[i][j] += primeExponential[i-1][j]\\n\\t\\ttmp, x = i, 2\\n\\t\\twhile x * x <= tmp:\\n\\t\\t\\twhile tmp % x == 0:\\n\\t\\t\\t\\tprimeExponential[i][x] += 1\\n\\t\\t\\t\\ttmp //= x\\n\\t\\t\\tx += 1\\n\\t\\tif tmp > 1: primeExponential[i][tmp] += 1\\n\\n\\tbestPD = [1] * (MAXK + 1)\\n\\tans, cur = 0, 0\\n\\n\\tfor i in range(1, MAXK + 1):\\n\\t\\tif cnt[i] == 0: continue\\n\\t\\tfor j in range(1, MAXK + 1):\\n\\t\\t\\tans += primeExponential[i][j] * cnt[i]\\n\\t\\t\\tcur += primeExponential[i][j] * cnt[i]\\n\\t\\t\\tif primeExponential[i][j]: bestPD[i] = j\\n\\n\\tfrequency = [0] * (MAXK + 1)\\n\\twhile max(bestPD) > 1:\\n\\t\\tfor i in range(MAXK + 1): frequency[i] = 0\\n\\t\\tfor i in range(MAXK + 1): frequency[bestPD[i]] += cnt[i]\\n\\n\\t\\tbestGroup = max(frequency)\\n\\t\\tbestPrime = frequency.index(bestGroup)\\n\\t\\tif bestGroup * 2 <= n: break\\n\\t\\tif bestPrime == 1: break\\n\\t\\tcur -= bestGroup\\n\\t\\tcur += (n - bestGroup); ans = min(ans, cur)\\n\\n\\t\\tfor i in range(MAXK + 1):\\n\\t\\t\\tif bestPD[i] != bestPrime: bestPD[i] = 1\\n\\t\\t\\tif bestPD[i] == 1: continue\\n\\t\\t\\tprimeExponential[i][bestPD[i]] -= 1\\n\\t\\t\\twhile bestPD[i] > 1 and primeExponential[i][bestPD[i]] == 0: bestPD[i] -= 1\\n\\n\\tprint(ans)\", \"from sys import stdin, stdout\\n\\nprime = list()\\nfactor = list()\\ncount = list()\\ndist = list()\\nN = 0\\n\\ndef find_prime():\\n    nonlocal prime\\n    for i in range(2, 5010):\\n        is_prime = True\\n        for j in prime:\\n            if i % j == 0:\\n                is_prime = False\\n                break\\n        if is_prime is True:\\n            prime.append(i)\\n\\ndef calculate_factor(max):\\n    nonlocal prime\\n    nonlocal factor\\n    nonlocal dist\\n    factor = [[0 for x in range(len(prime))] for y in range(5010)] \\n    dist = [0] * (max+1)\\n    d = 0\\n    for i in range(1, max+1):\\n        temp = i\\n        factor[i] = list(factor[i-1])\\n        for j,x in enumerate(prime):\\n            while temp % x == 0:\\n                factor[i][j] +=1\\n                temp = temp / x\\n                d += 1\\n            if temp == 1:\\n                dist[i] = d \\n                break\\n            \\ndef dynamic_count():\\n    nonlocal count\\n    for i in range (1,len(count)):\\n        count[i] += count[i-1]\\n\\ndef moving(i, left, right, d, current_factor):\\n    nonlocal count\\n    nonlocal prime\\n    nonlocal factor\\n    nonlocal N\\n    while (factor[left][i] == factor[right][i]):\\n        d += ((2 * (count[right] - count[left-1])) - N) * (factor[right][i] - current_factor[i])\\n        current_factor[i] = factor[right][i]\\n        i -= 1\\n        if i < 0:\\n            return d\\n    d += ((2 * (count[right] - count[left-1])) - N) * (factor[left][i] - current_factor[i])\\n    current_factor[i] = factor[left][i]\\n    \\n    \\n    temp_left = right\\n    while temp_left >= left:\\n        if (factor[temp_left-1][i] != factor[right][i] or temp_left == left ) and count[right] - count[temp_left-1] > int(N/2):\\n            if (temp_left > left):\\n                d += ((2 * (count[temp_left-1] - count[left-1]))) * (factor[left][i] - current_factor[i]) \\n            return moving(i, temp_left, right, d, current_factor)\\n        elif factor[temp_left-1][i] != factor[right][i]:\\n            i -= 1\\n            right = temp_left - 1\\n            if i < 0:\\n                return d\\n        temp_left -= 1\\n    return d\\n\\ndef unanem():\\n    nonlocal prime\\n    nonlocal count\\n    nonlocal N\\n    \\n    if count[1] > int(N/2):\\n        return 0\\n    current_factor = [0] * 5010\\n    if count[5000] - count[4998] > int(N/2):\\n        return moving(len(prime)-3, 4999, 5000, 0, current_factor)\\n    for i,x in enumerate(prime):\\n        counter = 0\\n        if i == 0:\\n            counter = count[1]\\n        else:\\n            counter = count[prime[i] - 1] - count[prime[i-1] - 1]\\n        if counter>int(N/2):\\n            return moving (i, prime[i-1], prime[i] - 1, 0 , current_factor)\\n    return 0\\n\\ndef main():\\n    nonlocal prime\\n    nonlocal factor\\n    nonlocal count\\n    nonlocal N\\n    nonlocal debugs\\n    N = int(stdin.readline())\\n    num_list = list(map(int, stdin.readline().split()))\\n    max = 0\\n    for i in num_list:\\n        if max < i:\\n            max = i\\n    \\n    \\n    count = [0] * (5010)\\n    for i in num_list:\\n        count[i] += 1\\n            \\n    find_prime()\\n    calculate_factor(max)\\n    dynamic_count()\\n    \\n    d = unanem()\\n    overall_dist = 0\\n    for i,c in enumerate(count):\\n        if i == max + 1:\\n            break\\n        if i == 0:\\n            continue\\n        overall_dist += (count[i] - count[i-1])*dist[i]\\n    print(overall_dist - d)\\n    \\n\\nmain()\\n\", \"\\nimport copy\\n\\nM = 5003\\nPrimes = []\\nRob = [0] * M\\nfor x in range(2,M):\\n\\tif Rob[x]==0:\\n\\t\\tPrimes.append(x)\\n\\ty = x+x\\n\\twhile y<M:\\n\\t\\tRob[y]+=1\\n\\t\\ty+=x\\n\\nP = len(Primes)\\n\\n\\nn = int(input())\\nCnt = [0] * M\\nfor a in input().split():\\n\\tCnt[int(a)] +=1\\n\\n\\nPF = []\\nPF.append( [0] * P)\\ns = 0\\n\\nres = 0\\nfor k in range(1, M):\\n\\tPF.append(copy.copy(PF[-1]))\\n\\t\\n\\tx = k\\n\\tfor p in range(P):\\n\\t\\twhile x % Primes[p] ==0:\\n\\t\\t\\tPF[k][p]+=1\\n\\t\\t\\tx/=Primes[p]\\n\\t\\t\\ts+=1\\n\\n\\tres += Cnt[k] * s\\n\\t\\n\\nfor i in range(M):\\n\\twhile (len(PF[i])>0 and PF[i][-1]==0):\\n\\t\\tPF[i].pop()\\n\\t\\n\\nBPD = [ len(PF[i]) for i in range(M) ]\\n\\n\\nbranched = 0\\nfrequency = [0] * (P+1)\\nwhile ( max(BPD) > 0):\\n\\t\\n\\t# Find the best prime divisors:\\n\\t\\n\\tfor i in range(P+1): frequency[i] = 0\\n\\t\\n\\tfor i in range(M): frequency[BPD[i]] += Cnt[i]\\n\\t\\n\\tm = max(frequency)\\n\\tpr = frequency.index(m)\\n\\t\\n\\tif pr==0:\\n\\t\\tbreak\\n\\t\\n\\tfor i in range(M):\\n\\t\\tif BPD[i]!=pr:\\n\\t\\t\\tbranched += Cnt[i]\\n\\t\\t\\tCnt[i] = 0\\n\\t\\t\\tBPD[i] = 0\\n\\t\\n\\tif branched * 2 >= n:\\n\\t\\tbreak\\n\\t\\n\\tres += 2* branched - n\\n\\t\\n\\tfor i in range(M):\\n\\t\\tif (BPD[i]==0): continue\\n\\t\\t\\n\\t\\tif (len(PF[i])>0):\\n\\t\\t\\tPF[i][-1]-=1\\n\\t\\twhile (len(PF[i])>0 and PF[i][-1]==0):\\n\\t\\t\\tPF[i].pop()\\n\\t\\tBPD[i] = len(PF[i])\\n\\nprint(res)\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"3\\n2 1 4\\n\",\n    \"4\\n3 1 4 4\\n\",\n    \"4\\n3 1 4 1\\n\",\n    \"5\\n3 1 4 1 5\\n\",\n    \"11\\n5000 5000 5000 5000 5000 5000 0 1 0 1 0\\n\",\n    \"1\\n0\\n\",\n    \"1\\n1\\n\",\n    \"4\\n0 1 1 0\\n\",\n    \"17\\n1 9 2 8 4 5 7 3 8 4 6 2 8 4 1 0 5\\n\",\n    \"4\\n57 918 827 953\\n\",\n    \"51\\n17 26 14 0 41 18 40 14 29 25 5 23 46 20 8 14 12 27 8 38 9 42 17 16 31 2 5 45 16 35 37 1 46 27 27 16 20 38 11 48 11 3 23 40 10 46 31 47 32 49 17\\n\",\n    \"95\\n28 12 46 4 24 37 23 19 7 22 29 34 10 10 9 11 9 17 26 23 8 42 12 31 33 39 25 17 1 41 30 21 11 26 14 43 19 24 32 14 3 42 29 47 40 16 27 43 33 28 6 25 40 4 0 21 5 36 2 3 35 38 49 41 32 34 0 27 30 44 45 18 2 6 1 50 13 22 20 20 7 5 16 18 13 15 15 36 39 37 31 35 48 38 8\\n\",\n    \"49\\n27 12 48 48 9 10 29 50 48 48 48 48 11 14 18 27 48 48 48 48 1 48 33 48 27 48 48 48 12 16 48 48 22 48 48 36 31 32 31 48 50 43 20 48 48 48 48 48 16\\n\",\n    \"17\\n12 12 5 1 3 12 4 2 12 12 12 12 6 12 7 12 0\\n\",\n    \"70\\n50 0 50 0 0 0 0 0 0 50 50 50 50 0 50 50 0 50 50 0 0 0 50 50 0 0 50 0 50 0 50 0 0 50 0 0 0 0 50 50 50 50 0 0 0 0 0 0 0 0 50 0 50 50 0 50 0 0 0 0 50 0 50 0 0 50 0 50 0 0\\n\",\n    \"13\\n0 0 0 0 0 0 0 0 0 0 0 0 50\\n\",\n    \"45\\n50 0 0 0 0 0 0 0 0 50 0 0 50 0 0 50 50 0 0 0 0 0 50 0 0 0 0 0 50 50 0 0 0 0 50 0 50 0 50 0 0 0 0 0 50\\n\",\n    \"24\\n50 0 50 50 50 0 50 50 0 50 50 50 50 50 0 50 50 0 50 50 50 50 50 50\\n\",\n    \"68\\n50 50 50 50 50 50 50 50 0 0 50 50 50 50 50 50 50 50 50 50 50 50 0 50 50 50 50 50 50 50 50 50 50 50 0 50 50 50 50 50 50 50 50 50 50 50 50 50 0 50 50 0 0 50 50 50 50 50 50 50 50 0 50 50 50 50 50 50\\n\",\n    \"75\\n2597 1818 260 4655 4175 2874 2987 4569 2029 4314 444 2276 4937 1209 1797 4965 3526 275 3535 2198 4402 2144 1369 13 4453 1655 4456 711 3563 1650 3997 885 782 147 2426 974 2917 2100 4549 2465 3015 3485 3238 4086 171 3934 1903 133 2278 2573 688 551 872 459 2044 1401 2429 4933 3747 587 2781 4173 4651 4012 1407 2352 1461 566 2062 4599 1430 2269 3914 1820 4728\\n\",\n    \"29\\n8 27 14 21 6 20 2 11 3 19 10 16 0 25 18 4 23 17 15 26 28 1 13 5 9 22 12 7 24\\n\",\n    \"87\\n1120 1120 1120 872 1120 731 3583 2815 4019 1291 4568 973 1120 1705 1120 822 203 1120 1120 1120 1120 4196 3166 4589 3030 1120 1120 1120 711 1120 500 1120 1120 3551 1120 1120 1120 1700 1120 1120 2319 4554 1120 1312 1120 1120 4176 1120 1120 3661 1120 1120 1120 1120 142 63 4125 1120 4698 3469 1829 567 1120 1120 1083 486 1120 1120 1120 1120 3763 1120 247 4496 454 1120 1120 1532 1120 4142 352 1120 359 2880 1120 1120 4494\\n\",\n    \"27\\n9 1144 1144 2 8 1144 12 0 1144 1144 7 3 1144 1144 11 10 1 1144 1144 5 1144 4 1144 1144 1144 1144 6\\n\",\n    \"27\\n0 5000 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5000 5000 0 0 0 5000\\n\",\n    \"59\\n0 0 0 5000 0 0 0 5000 5000 0 5000 0 0 0 5000 0 0 0 0 0 0 0 0 0 5000 0 0 0 0 5000 0 5000 0 5000 0 0 5000 0 5000 0 0 0 0 0 0 5000 0 0 0 0 5000 0 0 0 5000 0 0 0 5000\\n\",\n    \"80\\n0 0 0 0 5000 0 0 5000 5000 5000 0 5000 0 5000 5000 0 0 0 0 5000 5000 0 0 5000 0 5000 5000 5000 0 5000 0 5000 5000 5000 0 0 5000 0 0 5000 5000 0 0 5000 0 5000 5000 5000 0 0 5000 5000 5000 0 0 5000 0 0 5000 0 5000 5000 0 5000 0 5000 0 5000 0 5000 0 0 0 0 5000 5000 5000 0 0 0\\n\",\n    \"20\\n0 5000 5000 5000 5000 5000 0 5000 5000 0 5000 5000 5000 0 5000 5000 5000 5000 0 5000\\n\",\n    \"78\\n0 5000 5000 5000 5000 5000 5000 5000 5000 5000 5000 0 5000 5000 5000 5000 5000 5000 0 0 5000 5000 5000 5000 5000 0 5000 5000 5000 5000 5000 5000 5000 5000 5000 5000 5000 5000 0 5000 5000 0 5000 0 5000 5000 5000 5000 0 5000 5000 5000 5000 5000 5000 5000 0 5000 5000 0 0 0 5000 5000 5000 5000 0 5000 5000 5000 5000 5000 5000 0 5000 5000 0 5000\\n\",\n    \"4\\n13 14 15 16\\n\",\n    \"3\\n1 5 6\\n\",\n    \"3\\n15 13 2\\n\",\n    \"3\\n1 8 9\\n\"\n  ],\n  \"outputs\": [\n    \"5\\n\",\n    \"6\\n\",\n    \"6\\n\",\n    \"11\\n\",\n    \"77835\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"87\\n\",\n    \"7835\\n\",\n    \"2366\\n\",\n    \"4286\\n\",\n    \"3484\\n\",\n    \"179\\n\",\n    \"3024\\n\",\n    \"108\\n\",\n    \"1296\\n\",\n    \"540\\n\",\n    \"864\\n\",\n    \"565559\\n\",\n    \"692\\n\",\n    \"438276\\n\",\n    \"43222\\n\",\n    \"62268\\n\",\n    \"233505\\n\",\n    \"591546\\n\",\n    \"77835\\n\",\n    \"249072\\n\",\n    \"76\\n\",\n    \"10\\n\",\n    \"42\\n\",\n    \"20\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}