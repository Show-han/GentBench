{
    "problem": "You are an expert Python programmer, and here is your task: There are two strings s and t, consisting only of letters a and b. You can make the following operation several times: choose a prefix of s, a prefix of t and swap them. Prefixes can be empty, also a prefix can coincide with a whole string. \n\nYour task is to find a sequence of operations after which one of the strings consists only of a letters and the other consists only of b letters. The number of operations should be minimized.\n\n\n-----Input-----\n\nThe first line contains a string s (1 \u2264 |s| \u2264 2\u00b710^5).\n\nThe second line contains a string t (1 \u2264 |t| \u2264 2\u00b710^5).\n\nHere |s| and |t| denote the lengths of s and t, respectively. It is guaranteed that at least one of the strings contains at least one a letter and at least one of the strings contains at least one b letter.\n\n\n-----Output-----\n\nThe first line should contain a single integer n (0 \u2264 n \u2264 5\u00b710^5)\u00a0\u2014 the number of operations.\n\nEach of the next n lines should contain two space-separated integers a_{i}, b_{i}\u00a0\u2014 the lengths of prefixes of s and t to swap, respectively.\n\nIf there are multiple possible solutions, you can print any of them. It's guaranteed that a solution with given constraints exists.\n\n\n-----Examples-----\nInput\nbab\nbb\n\nOutput\n2\n1 0\n1 3\n\nInput\nbbbb\naaa\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example, you can solve the problem in two operations:  Swap the prefix of the first string with length 1 and the prefix of the second string with length 0. After this swap, you'll have strings ab and bbb.  Swap the prefix of the first string with length 1 and the prefix of the second string with length 3. After this swap, you'll have strings bbbb and a. \n\nIn the second example, the strings are already appropriate, so no operations are needed.",
    "solution": "[\"\\ndef blokovi(x):\\n    ret = [0]\\n    for i in range(len(x) - 1):\\n        if x[i] != x[i + 1]:\\n            ret.append(i + 1)\\n    return ret + [len(x)]\\n\\ns = input()\\nt = input()\\n\\nss = blokovi(s)\\ntt = blokovi(t)\\n\\nif s[-1] == 'a':\\n    s += 'b'\\nelse:\\n    s += 'a'\\n\\nif t[-1] == 'a':\\n    t += 'b'\\nelse:\\n    t += 'a'\\n\\ndef greedy(x, y, rev=False):\\n    i, j = len(x) - 1, len(y) - 1\\n    swaps = []\\n    while True:\\n        while i >= 0 and x[i] == 'a':\\n            i -= 1\\n        while j >= 0 and y[j] == 'b':\\n            j -= 1\\n        if i < 0 and j < 0:\\n            break\\n        x, y = y, x\\n        if rev:\\n            swaps.append((j + 1, i + 1))\\n        else:\\n            swaps.append((i + 1, j + 1))\\n        i, j = j, i\\n    return swaps\\n\\ndef solve(x, y):\\n    p = greedy(x, y)\\n    q = greedy(y, x, True)\\n    if len(p) < len(q):\\n        return p\\n    return q\\n\\nprobao = set()\\n\\ntotal = len(ss) + len(tt)\\nsol = solve(s[:-1], t[:-1])\\nfor b, i in enumerate(ss):\\n    for c in range((2 * b + len(tt) - len(ss)) // 2 - 2, (2 * b + len(tt) - len(ss) + 1) // 2 + 3):\\n        if 0 <= c < len(tt):\\n            j = tt[c]\\n            bs = b + len(tt) - c - 1\\n            bt = c + len(ss) - b - 1\\n            if abs(bs - bt) > 2:\\n                continue\\n            proba = (bs, bt, s[i], t[j])\\n            if proba in probao:\\n                continue\\n            probao.add(proba)\\n            s2 = t[:j] + s[i:-1]\\n            t2 = s[:i] + t[j:-1]\\n            if i + j > 0: \\n                if i + j == len(s) + len(t) - 2:\\n                    cand = solve(t2, s2)\\n                else:\\n                    cand = [(i, j)] + solve(s2, t2)\\n            else:\\n                cand = solve(s2, t2)\\n            if len(cand) < len(sol):\\n                sol = cand\\n\\nprint(len(sol))\\nfor i, j in sol:\\n    print(i, j)\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"bab\\nbb\\n\",\n    \"bbbb\\naaa\\n\",\n    \"aaaaaa\\nbbbbbb\\n\",\n    \"aaaaaa\\naaaabb\\n\",\n    \"aaaaba\\naaaaaa\\n\",\n    \"bbabba\\nbbbbbb\\n\",\n    \"bbabab\\nbbbbbb\\n\",\n    \"bbbbba\\nbbbba\\n\",\n    \"aaaaba\\naaabbb\\n\",\n    \"bbbbba\\nbaaaba\\n\",\n    \"baabab\\nbbbbaa\\n\",\n    \"abbbba\\naaaaba\\n\",\n    \"abbaa\\nabbabb\\n\",\n    \"baabab\\nbbbabb\\n\",\n    \"baabaa\\nbaabaa\\n\",\n    \"bbbbba\\naaaaaa\\n\",\n    \"aabaaa\\nbbbbbb\\n\",\n    \"bbabba\\naaaaaa\\n\",\n    \"abbaba\\nbbbbbb\\n\",\n    \"bbbaa\\naaaabb\\n\",\n    \"bbbbba\\naabaaa\\n\",\n    \"bbaaaa\\naababb\\n\",\n    \"bbbbaa\\nabbaba\\n\",\n    \"bbaaab\\nabaaaa\\n\",\n    \"baabaa\\naabba\\n\",\n    \"babbab\\nabbbaa\\n\",\n    \"aabbab\\nbaaaba\\n\",\n    \"bbbbbb\\nbababa\\n\",\n    \"bababa\\nbbbaaa\\n\",\n    \"bababa\\nbbbabb\\n\",\n    \"bbbaba\\nbababb\\n\",\n    \"bababa\\nbbabaa\\n\",\n    \"babaab\\nbbabab\\n\",\n    \"bbabab\\nbababa\\n\",\n    \"bababa\\nbababa\\n\",\n    \"bbbbbb\\nababab\\n\",\n    \"bababa\\naaaabb\\n\",\n    \"aaabba\\nbababa\\n\",\n    \"baabab\\naabbab\\n\",\n    \"bbabba\\nababab\\n\",\n    \"aababa\\nbaabab\\n\",\n    \"babaab\\nababab\\n\",\n    \"ababab\\nbababa\\n\",\n    \"b\\naabaaaaaabaabbbbaaaaabbbbaaba\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n1 0\\n1 3\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"1\\n0 4\\n\",\n    \"2\\n4 0\\n1 10\\n\",\n    \"3\\n5 0\\n1 2\\n2 2\\n\",\n    \"3\\n4 0\\n1 2\\n3 2\\n\",\n    \"2\\n5 0\\n1 9\\n\",\n    \"2\\n5 3\\n0 4\\n\",\n    \"3\\n5 4\\n0 6\\n7 1\\n\",\n    \"3\\n3 4\\n6 1\\n0 5\\n\",\n    \"3\\n6 5\\n4 5\\n1 0\\n\",\n    \"3\\n3 4\\n3 1\\n0 1\\n\",\n    \"4\\n4 4\\n6 3\\n1 5\\n3 0\\n\",\n    \"4\\n4 3\\n1 3\\n0 3\\n4 2\\n\",\n    \"1\\n5 6\\n\",\n    \"2\\n2 6\\n7 2\\n\",\n    \"3\\n5 6\\n7 2\\n2 8\\n\",\n    \"3\\n4 6\\n7 1\\n2 9\\n\",\n    \"1\\n3 4\\n\",\n    \"2\\n5 2\\n3 6\\n\",\n    \"3\\n2 4\\n2 4\\n5 2\\n\",\n    \"3\\n4 4\\n1 5\\n7 2\\n\",\n    \"2\\n2 1\\n4 3\\n\",\n    \"3\\n1 2\\n4 3\\n4 5\\n\",\n    \"4\\n1 1\\n5 4\\n5 2\\n2 7\\n\",\n    \"3\\n2 1\\n3 5\\n6 4\\n\",\n    \"3\\n0 3\\n1 1\\n2 2\\n\",\n    \"4\\n2 3\\n5 1\\n2 0\\n1 6\\n\",\n    \"4\\n3 4\\n6 2\\n1 5\\n3 0\\n\",\n    \"4\\n4 3\\n4 5\\n3 2\\n1 0\\n\",\n    \"5\\n3 3\\n5 2\\n1 4\\n0 4\\n6 2\\n\",\n    \"5\\n3 3\\n5 4\\n2 7\\n6 1\\n0 2\\n\",\n    \"5\\n3 3\\n4 4\\n5 5\\n2 2\\n0 1\\n\",\n    \"6\\n3 2\\n3 4\\n2 5\\n4 1\\n5 0\\n1 6\\n\",\n    \"3\\n6 3\\n1 7\\n8 2\\n\",\n    \"3\\n3 4\\n5 1\\n2 6\\n\",\n    \"4\\n3 1\\n3 6\\n4 4\\n5 5\\n\",\n    \"4\\n1 2\\n4 3\\n4 5\\n6 5\\n\",\n    \"5\\n2 1\\n2 3\\n5 5\\n3 6\\n7 3\\n\",\n    \"4\\n2 1\\n2 4\\n5 3\\n4 6\\n\",\n    \"5\\n1 1\\n2 2\\n3 3\\n5 4\\n5 6\\n\",\n    \"5\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n\",\n    \"6\\n1 9\\n2 2\\n3 13\\n4 7\\n11 6\\n17 12\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}