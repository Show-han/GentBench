{
    "problem": "You are an expert Python programmer, and here is your task: In Arcady's garden there grows a peculiar apple-tree that fruits one time per year. Its peculiarity can be explained in following way: there are n inflorescences, numbered from 1 to n. Inflorescence number 1 is situated near base of tree and any other inflorescence with number i (i > 1) is situated at the top of branch, which bottom is p_{i}-th inflorescence and p_{i} < i.\n\nOnce tree starts fruiting, there appears exactly one apple in each inflorescence. The same moment as apples appear, they start to roll down along branches to the very base of tree. Each second all apples, except ones in first inflorescence simultaneously roll down one branch closer to tree base, e.g. apple in a-th inflorescence gets to p_{a}-th inflorescence. Apples that end up in first inflorescence are gathered by Arcady in exactly the same moment. Second peculiarity of this tree is that once two apples are in same inflorescence they annihilate. This happens with each pair of apples, e.g. if there are 5 apples in same inflorescence in same time, only one will not be annihilated and if there are 8 apples, all apples will be annihilated. Thus, there can be no more than one apple in each inflorescence in each moment of time.\n\nHelp Arcady with counting number of apples he will be able to collect from first inflorescence during one harvest.\n\n\n-----Input-----\n\nFirst line of input contains single integer number n (2 \u2264 n \u2264 100 000) \u00a0\u2014 number of inflorescences.\n\nSecond line of input contains sequence of n - 1 integer numbers p_2, p_3, ..., p_{n} (1 \u2264 p_{i} < i), where p_{i} is number of inflorescence into which the apple from i-th inflorescence rolls down.\n\n\n-----Output-----\n\nSingle line of output should contain one integer number: amount of apples that Arcady will be able to collect from first inflorescence during one harvest.\n\n\n-----Examples-----\nInput\n3\n1 1\n\nOutput\n1\n\nInput\n5\n1 2 2 2\n\nOutput\n3\n\nInput\n18\n1 1 1 4 4 3 2 2 2 10 8 9 9 9 10 10 4\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn first example Arcady will be able to collect only one apple, initially situated in 1st inflorescence. In next second apples from 2nd and 3rd inflorescences will roll down and annihilate, and Arcady won't be able to collect them.\n\nIn the second example Arcady will be able to collect 3 apples. First one is one initially situated in first inflorescence. In a second apple from 2nd inflorescence will roll down to 1st (Arcady will collect it) and apples from 3rd, 4th, 5th inflorescences will roll down to 2nd. Two of them will annihilate and one not annihilated will roll down from 2-nd inflorescence to 1st one in the next second and Arcady will collect it.",
    "solution": "[\"n = int(input())\\np = [-1, 0] + [int(x) for x in input().split()]\\nh = [0] * (n+1)\\ncount = [0] * n\\ncount[0] = 1\\nmax_h = 0\\nfor i in range(2, n+1):\\n    h[i] = h[p[i]]+1\\n    count[h[i]]+=1\\n    max_h = max(max_h,h[i])\\nans = 0\\nfor i in range(max_h+1):\\n    ans += count[i]%2\\nprint(ans)\", \"import sys, math\\n\\n#f = open('input/input_2', 'r')\\nf = sys.stdin\\n\\nN = int(f.readline())\\npl = list(map(int, f.readline().split()))\\n\\ne = [[] for _ in range(N+1)]\\nlv = [0] * (N+1)\\nfor i, p in enumerate(pl):\\n  e[p].append(i+2)\\n\\nc = [0] * (N+1)\\n\\nfor i in range(1, N+1):\\n  c[lv[i]] = 1 - c[lv[i]]\\n  for j in e[i]:\\n    lv[j] = lv[i]+1\\n\\nprint(sum(c))\\n\", \"# python3\\n\\n\\ndef main():\\n    n = int(input())\\n    parent = tuple(int(x) - 1 for x in input().split())\\n\\n    depth = [0]\\n    for v in range(n - 1):\\n        depth.append(depth[parent[v]] + 1)\\n\\n    parity = [0] * n\\n    for d in depth:\\n        parity[d] ^= 1\\n\\n    print(sum(parity))\\n\\n\\nmain()\\n\", \"n = int(input().strip())\\ncount = [0]*n\\nparams = [-1, 0]+list(map(int, input().split()))\\ni = 2\\nlayer = [0]*(n+1)\\nnodes_in_layer = {}\\nwhile i <= n:\\n    layer[i] = layer[params[i]] + 1\\n    count[params[i]] += 1\\n    if nodes_in_layer.get(layer[i]) is None:\\n        nodes_in_layer.setdefault(layer[i], 1)\\n    else:\\n        nodes_in_layer[layer[i]] += 1\\n    i += 1\\nmax_layer = max(layer)\\nresult = 1\\nfor i in range(1, max_layer+1):\\n    result += nodes_in_layer[i] % 2\\n\\nprint(result)\\n\", \"import collections\\nn = int(input())\\na = list(map(int, input().split()))\\n\\nto = {}\\nfor i, node in enumerate(a):\\n    to[i+2] = node\\n\\nlayers = collections.defaultdict(list)\\nfor k, v in to.items():\\n    layers[v].append(k)\\n\\nqueue = [1]\\nans = 0\\nwhile queue:\\n    ans += len(queue)%2\\n    n = len(queue)\\n    for _ in range(n):\\n        node = queue.pop(0)\\n        if node in layers:\\n            queue.extend(layers[node])\\n\\nprint(ans)\", \"import threading\\nfrom sys import setrecursionlimit, exc_info\\n\\n\\ndef main():\\n    try:\\n        n = int(input())\\n        par = list(map(int, input().split()))\\n\\n        gr = [[] for i in range(n)]\\n        for i in range(n - 1):\\n            gr[par[i] - 1].append(i + 1)\\n\\n        cnt = [0] * n\\n\\n\\n\\n        def dfs(v, depth=0):\\n            cnt[depth] += 1\\n            while depth >= len(cnt):\\n                pass\\n            for u in gr[v]:\\n                dfs(u, depth + 1)\\n\\n\\n\\n        dfs(0)\\n        print(sum([x % 2 for x in cnt]))\\n    except:\\n        print(exc_info()[0])\\n\\n\\nsetrecursionlimit(100000000)\\nthreading.stack_size(102400000)\\nthread = threading.Thread(target=main)\\nthread.start()\\n\", \"n=int(input())\\na=[0,0]+list(map(int,input().split()))\\nb=[0]*(n+1);c=[0]*(n+1)\\nfor i in range(2,n+1):\\n       if a[i]==1:\\n              b[i]=1\\nfor i in range(2,n+1):\\n       cou=0;s=i\\n       while b[s]==0:  \\n              cou+=1;s=a[s]\\n       b[i]=cou+b[s]\\nfor i in b[2:]:\\n       c[i]+=1\\nans=1\\nfor i in c:\\n       ans+=i%2\\nprint(ans)\", \"n=int(input())\\n\\n\\n\\n\\n\\na=list(map(int,input().split()))\\n\\ndp=[0,]\\n\\ncount=[0 for i in range(n)]\\n\\ncount[0]+=1\\n\\nfor i in range(n-1):\\n\\n    dp.append(dp[a[i]-1]+1)\\n\\n    count[dp[-1]]+=1\\n\\nans=0\\n\\nfor i in range(n):\\n\\n    ans+=count[i]%2\\n\\nprint(ans)\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"def bfs(d,n):\\n    queue = [[1,0]]\\n    res = 0\\n    mark = {i:False for i in range(1,n+1)}\\n    mark[1]=True\\n    res = [0 for i in range(n)]\\n    while queue:\\n        q = queue.pop(0)\\n        x,level = q[0],q[1]\\n        lev = level+1\\n        res[level]=(res[level]+1)%2\\n        for i,y in enumerate(d[x]):\\n            if mark[y]==False:\\n                mark[y]=True\\n                queue.append([y,lev])\\n    print(sum(res))\\nn = int(input())\\nlst = list(map(int,input().split()))\\nd = {1:[]}\\nfor i,x in enumerate(lst):\\n    d[x].append(i+2)\\n    d[i+2]=[]\\nbfs(d,n)\", \"from sys import setrecursionlimit\\n\\na = int(input())\\n\\nsetrecursionlimit(200000)\\n\\nh = [[] for i in range(a)]\\ns = list(map(int, input().split()))\\nfor i in range(a - 1):\\n    h[s[i] - 1].append(i + 1)\\n\\nmetka = [False for i in range(a)]\\ndat = [0 for i in range(a)]\\ndis = [0 for i in range(a)]\\n\\n\\ndef dfs(x):\\n    stack = []\\n    stack.append(x)\\n    while stack:\\n        x = stack.pop(-1)\\n        dat[dis[x]] += 1\\n        metka[x] = True\\n        for i in h[x]:\\n            if not metka[i]:\\n                stack.append(i)\\n                dis[i] = dis[x] + 1\\n\\n\\ndfs(0)\\n\\nprint(sum([x % 2 for x in dat]))\\n\", \"# 930A\\nimport collections\\ndef do():\\n    n = int(input())\\n    nums = [0] + [int(c)-1 for c in input().split(\\\" \\\")]\\n    g = collections.defaultdict(list)\\n    for i, j in enumerate(nums):\\n        if i != j:\\n            g[j].append(i)  # children\\n    cur = [0]\\n    res = 0\\n    while cur:\\n        res += len(cur) % 2\\n        next = []\\n        for c in cur:\\n            for nei in g[c]:\\n                next.append(nei)\\n        cur = next\\n    return res\\n\\nprint(do())\", \"n = int(input())\\n\\npar = [None] + [int(i) - 1 for i in input().split()]\\nchildren = [[] for _ in range(n)]\\nfor child in range(1, n):\\n    children[par[child]].append(child)\\n\\ncount = 0\\nnodesAtCurrLevel = [0]\\n\\nwhile nodesAtCurrLevel:\\n    count += len(nodesAtCurrLevel) % 2\\n    \\n    nodesAtNextLevel = []\\n    for node in nodesAtCurrLevel:\\n        nodesAtNextLevel += children[node]\\n    \\n    nodesAtCurrLevel = nodesAtNextLevel\\n\\nprint(count)\", \"import sys\\ninput = sys.stdin.readline\\nfrom collections import deque, Counter\\n\\ndef bfs():\\n    q = deque([0])\\n    dist = [-1]*n\\n    dist[0] = 0\\n    \\n    while q:\\n        v = q.popleft()\\n        \\n        for nv in G[v]:\\n            if dist[nv]==-1:\\n                dist[nv] = dist[v]+1\\n                q.append(nv)\\n    \\n    return dist\\n\\nn = int(input())\\np = list(map(int, input().split()))\\nG = [[] for _ in range(n)]\\n\\nfor i in range(n-1):\\n    G[i+1].append(p[i]-1)\\n    G[p[i]-1].append(i+1)\\n\\ndist = bfs()\\ncnt = Counter(dist)\\nans = 0\\n\\nfor v in cnt.values():\\n    ans += v%2\\n\\nprint(ans)\", \"n = int(input())\\np = [-1, 0] + list(map(int, input().split()))\\nh = [0] * (n+1)\\ncnt = [1] + [0] * n\\nfor i in range(2, n+1):\\n    h[i] = h[p[i]] + 1\\n    cnt[h[i]] += 1\\nres = 0\\nfor i in range(max(h)+1):\\n    if cnt[i] % 2 == 1:\\n        res += 1\\nprint(res)\\n\", \"n = int(input())\\na = [int(e) for e in input().split()]\\nd = {1:0}\\nfor k, v in enumerate(a):\\n    d[k+2] = d[v] + 1\\nd2 = {}\\nfor k, v in d.items():\\n    d2[v] = d2.get(v,0) + 1\\ns = sum([v%2 for v in d2.values()])\\nprint(s)\", \"\\nclass Node: \\n    def __init__(self, id):\\n        self.id = id\\n        self.parent = -1\\n        self.children = set()\\n        self.apples = 1\\n\\nnodes = dict()\\n\\nnb_nodes = int(input())\\nfor i in range(nb_nodes): \\n    nodes[i+1] = Node(i+1)\\n\\nparents = [int(i) for i in input().split(\\\" \\\")]\\n\\nbase = 2\\nfor p in parents: \\n    nodes[base].parent = p\\n    nodes[p].children.add(base)\\n    base += 1\\n\\n#for n in nodes.values(): \\n#    print(\\\"%d -> %s\\\" % (n.id, n.children))\\n    \\nrecolt = 0\\ntodo = { 1 }\\nwhile len(todo) > 0: \\n    recolt += len(todo) % 2\\n    next = set()\\n    for t in todo: \\n        next |= nodes[t].children\\n    todo = next\\n        \\nprint(recolt)\", \"n = int(input())\\nparent = tuple(int(x) - 1 for x in input().split())\\n \\ndepth = [0]\\nfor v in range(n - 1):\\n    depth.append(depth[parent[v]] + 1)\\n \\nparity = [0] * n\\nfor d in depth:\\n    parity[d] ^= 1\\n \\nprint(sum(parity))\", \"n = int(input())\\nparent = tuple(int(x) - 1 for x in input().split())\\n\\ndepth = [0]\\nfor v in range(n - 1):\\n    depth.append(depth[parent[v]] + 1)\\n\\nparity = [0] * n\\nfor d in depth:\\n    parity[d] ^= 1\\n\\nprint(sum(parity))\", \"n = int(input())\\nparent = tuple(int(x) - 1 for x in input().split())\\n \\ndepth = [0]\\nfor v in range(n - 1):\\n    depth.append(depth[parent[v]] + 1)\\n \\n# parity = [0] * n\\n# for d in depth:\\n#     parity[d] ^= 1\\n\\nfreq = {}\\n\\nfor d in depth:\\n    if d in freq:\\n        freq[d] += 1\\n    else:\\n        freq[d] = 1\\n\\nres = 0\\nfor d in freq:\\n    res+= freq[d]%2\\nprint(res)\\n \\n# print(sum(parity))\\n\", \"inflos = int(input())\\nparent = tuple(int(x) - 1 for x in input().split())\\n \\ndepth = [0]\\nfor v in range(inflos - 1):\\n    depth.append(depth[parent[v]] + 1)\\n\\nfreq = {}\\n\\nfor d in depth:\\n    if d in freq:\\n        freq[d] += 1\\n    else:\\n        freq[d] = 1\\nres = 0\\nfor d in freq:\\n    res+= freq[d]%2\\nprint(res)\\n\", \"inflos = int(input())\\nroots = [int(x) - 1 for x in input().split()]\\n \\n\\ndepth = [0]\\nfor v in range(inflos - 1):\\n    depth.append(depth[roots[v]] + 1)\\n\\nfreq = {}\\n\\nfor d in depth:\\n    if d in freq:\\n        freq[d] += 1\\n    else:\\n        freq[d] = 1\\nres = 0\\nfor d in freq:\\n    res+= freq[d]%2\\nprint(res)\\n\", \"inflos = int(input())\\nroots = input()\\nroots = [int(x) - 1 for x in roots.split()]\\n \\n\\ndepth = [0]\\nfor v in range(inflos - 1):\\n    depth.append(depth[roots[v]] + 1)\\n\\nfreq = {}\\n\\nfor d in depth:\\n    if d in freq:\\n        freq[d] += 1\\n    else:\\n        freq[d] = 1\\nres = 0\\nfor d in freq:\\n    res+= freq[d]%2\\nprint(res)\\n\", \"inflos = int(input())\\nroots = input()\\nroots = [int(x) - 1 for x in roots.split()]\\n \\n\\nson = [0]\\nfor v in range(inflos - 1):\\n    son.append(son[roots[v]] + 1)\\n\\nfreq = {}\\n\\nfor d in son:\\n    if d in freq:\\n        freq[d] += 1\\n    else:\\n        freq[d] = 1\\nres = 0\\nfor d in freq:\\n    res+= freq[d]%2\\nprint(res)\", \"import sys\\nimport bisect\\n# from collections import deque\\n\\nRi = lambda : [int(x) for x in sys.stdin.readline().split()]\\nri = lambda : sys.stdin.readline().strip()\\n \\ndef input(): return sys.stdin.readline().strip()\\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\\ndef ceil(x, y=1): return int(-(-x // y))\\ndef INT(): return int(input())\\ndef MAP(): return map(int, input().split())\\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\\ndef Yes(): print('Yes')\\ndef No(): print('No')\\ndef YES(): print('YES')\\ndef NO(): print('NO')\\nINF = 10 ** 30  \\nMOD = 998244353\\n\\nn = int(ri())\\na  = Ri()\\n\\ndic = {}\\nfor i in range(len(a)):\\n    if a[i] == 1:\\n        dic[i+2] = 1\\n    else:\\n        time = dic[a[i]]\\n        dic[i+2] = time+1\\ncnt = 0\\ntime = {}\\nfor i in dic:\\n    if dic[i] in time:\\n        time[dic[i]]+=1\\n    else:\\n        time[dic[i]] = 1\\n    \\nfor i in time:\\n    cnt +=(time[i]%2)\\nprint(cnt+1)\", \"n = int(input())\\nparent = tuple(int(x)-1 for x in input().split())\\n \\ndepth = [0]\\nfor v in range(n - 1):\\n    depth.append(depth[parent[v]] + 1)\\n \\n\\nfreq = {}\\n \\nfor d in depth:\\n    if d in freq:\\n        freq[d] += 1\\n    else:\\n        freq[d] = 1\\n \\nres = 0\\nfor d in freq:\\n    res+= freq[d]%2\\nprint(res)\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"3\\n1 1\\n\",\n    \"5\\n1 2 2 2\\n\",\n    \"18\\n1 1 1 4 4 3 2 2 2 10 8 9 9 9 10 10 4\\n\",\n    \"2\\n1\\n\",\n    \"3\\n1 2\\n\",\n    \"20\\n1 1 1 1 1 4 1 2 4 1 2 1 7 1 2 2 9 7 1\\n\",\n    \"20\\n1 2 1 2 2 1 2 4 1 6 2 2 4 3 2 6 2 5 9\\n\",\n    \"20\\n1 1 1 4 2 4 3 1 2 8 3 2 11 13 15 1 12 13 12\\n\",\n    \"20\\n1 2 2 4 3 5 5 6 6 9 11 9 9 12 13 10 15 13 15\\n\",\n    \"20\\n1 2 3 4 5 6 7 8 9 6 11 12 12 7 13 15 16 11 13\\n\",\n    \"10\\n1 1 1 2 1 3 4 2 1\\n\",\n    \"30\\n1 1 1 2 1 2 1 1 2 1 1 1 2 2 4 3 6 2 3 5 3 4 11 5 3 3 4 7 6\\n\",\n    \"40\\n1 1 1 1 1 1 1 1 1 3 4 3 3 1 3 6 7 4 5 2 4 3 9 1 4 2 5 3 5 9 5 9 10 12 3 7 2 11 1\\n\",\n    \"50\\n1 1 1 1 1 2 3 3 2 1 1 2 3 1 3 1 5 6 4 1 1 2 1 2 1 10 17 2 2 4 12 9 6 6 5 13 1 3 2 8 25 3 22 1 10 13 6 3 2\\n\",\n    \"10\\n1 1 1 1 2 1 3 4 3\\n\",\n    \"30\\n1 2 1 1 1 2 1 4 2 3 9 2 3 2 1 1 4 3 12 4 8 8 3 7 9 1 9 19 1\\n\",\n    \"40\\n1 1 1 2 3 1 2 1 3 7 1 3 4 3 2 3 4 1 2 2 4 1 7 4 1 3 2 1 4 5 3 10 14 11 10 13 8 7 4\\n\",\n    \"50\\n1 2 1 1 1 3 1 3 1 5 3 2 7 3 6 6 3 1 4 2 3 10 8 9 1 4 5 2 8 6 12 9 7 5 7 19 3 15 10 4 12 4 19 5 16 5 3 13 5\\n\",\n    \"10\\n1 1 1 2 3 2 1 2 3\\n\",\n    \"30\\n1 1 1 1 2 1 4 4 2 3 2 1 1 1 1 3 1 1 3 2 3 5 1 2 9 16 2 4 3\\n\",\n    \"40\\n1 1 1 2 1 2 1 2 4 8 1 7 1 6 2 8 2 12 4 11 5 5 15 3 12 11 22 11 13 13 24 6 10 15 3 6 7 1 2\\n\",\n    \"50\\n1 1 1 1 3 4 1 2 3 5 1 2 1 5 1 10 4 11 1 8 8 4 4 12 5 3 4 1 1 2 5 13 13 2 2 10 12 3 19 14 1 1 15 3 23 21 12 3 14\\n\",\n    \"10\\n1 1 1 1 2 4 1 1 3\\n\",\n    \"30\\n1 1 1 1 3 3 2 3 7 4 1 2 4 6 2 8 1 2 13 7 5 15 3 3 8 4 4 18 3\\n\",\n    \"40\\n1 1 1 2 2 1 1 4 6 4 7 7 7 4 4 8 10 7 5 1 5 13 7 8 2 11 18 2 1 20 7 3 12 16 2 22 4 22 14\\n\",\n    \"50\\n1 1 1 2 2 1 3 5 3 1 9 4 4 2 12 15 3 13 8 8 4 13 20 17 19 2 4 3 9 5 17 9 17 1 5 7 6 5 20 11 31 33 32 20 6 25 1 2 6\\n\",\n    \"10\\n1 1 1 3 3 5 6 8 3\\n\",\n    \"30\\n1 2 2 1 5 5 5 1 7 4 10 2 4 11 2 3 10 10 7 13 12 4 10 3 22 25 8 1 1\\n\",\n    \"40\\n1 2 2 2 2 4 2 2 6 9 3 9 9 9 3 5 7 7 2 17 4 4 8 8 25 18 12 27 8 19 26 15 33 26 33 9 24 4 27\\n\",\n    \"50\\n1 1 3 3 4 5 5 2 4 3 9 9 1 5 5 7 5 5 16 1 18 3 6 5 6 13 26 12 23 20 17 21 9 17 19 34 12 24 11 9 32 10 40 42 7 40 11 25 3\\n\",\n    \"10\\n1 2 1 2 5 5 6 6 6\\n\",\n    \"30\\n1 1 3 3 5 6 7 5 7 6 5 4 8 6 10 12 14 9 15 20 6 21 14 24 17 23 23 18 8\\n\",\n    \"40\\n1 2 2 3 1 2 5 6 4 8 11 12 9 5 12 7 4 16 16 15 6 22 17 24 10 8 22 4 27 9 19 23 16 18 28 22 5 35 19\\n\",\n    \"50\\n1 2 3 4 5 5 5 7 1 2 11 5 7 11 11 11 15 3 17 10 6 18 14 14 24 11 10 7 17 18 8 7 19 18 31 27 21 30 34 32 27 39 38 22 32 23 31 48 25\\n\",\n    \"10\\n1 2 2 4 5 5 6 4 7\\n\",\n    \"30\\n1 2 3 3 5 6 3 8 9 10 10 10 11 7 8 8 15 16 13 13 19 12 15 18 18 24 27 25 10\\n\",\n    \"40\\n1 2 3 4 5 6 6 8 7 10 11 3 12 11 15 12 17 15 10 20 16 20 12 20 15 21 20 26 29 23 29 30 23 24 35 33 25 32 36\\n\",\n    \"50\\n1 2 2 2 5 6 7 7 9 10 7 4 5 4 15 15 16 17 10 19 18 16 15 24 20 8 27 16 19 24 23 32 17 23 29 18 35 35 38 35 39 41 42 38 19 46 38 28 29\\n\",\n    \"10\\n1 2 3 4 5 5 5 7 9\\n\",\n    \"30\\n1 2 3 4 5 6 5 3 6 7 8 11 12 13 15 15 13 13 19 10 14 10 15 23 21 9 27 22 28\\n\",\n    \"40\\n1 2 2 3 3 6 5 5 9 7 8 11 13 7 10 10 16 14 18 20 11 19 23 18 20 21 25 16 29 25 27 31 26 34 33 23 36 33 32\\n\",\n    \"50\\n1 2 2 4 5 5 7 6 9 10 11 12 13 7 14 15 14 17 10 14 9 21 23 23 19 26 19 25 11 24 22 27 26 34 35 30 37 31 38 32 40 32 42 44 37 21 40 40 48\\n\",\n    \"10\\n1 2 3 4 3 6 6 6 7\\n\",\n    \"30\\n1 2 2 4 5 6 5 7 9 6 4 12 7 14 12 12 15 17 13 12 8 20 21 15 17 24 21 19 16\\n\",\n    \"40\\n1 2 3 4 4 6 6 4 9 9 10 12 10 12 12 16 8 13 18 14 17 20 21 23 25 22 25 26 29 26 27 27 33 31 33 34 36 29 34\\n\",\n    \"50\\n1 2 3 3 4 3 6 7 8 10 11 10 12 11 11 14 13 8 17 20 21 19 15 18 21 18 17 23 25 28 25 27 29 32 32 34 37 29 30 39 41 35 24 41 37 36 41 35 43\\n\",\n    \"99\\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\\n\",\n    \"99\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98\\n\",\n    \"100\\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\\n\",\n    \"100\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n\",\n    \"3\\n\",\n    \"4\\n\",\n    \"2\\n\",\n    \"3\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"4\\n\",\n    \"4\\n\",\n    \"8\\n\",\n    \"2\\n\",\n    \"4\\n\",\n    \"2\\n\",\n    \"4\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"4\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"4\\n\",\n    \"4\\n\",\n    \"4\\n\",\n    \"6\\n\",\n    \"4\\n\",\n    \"6\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"4\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"6\\n\",\n    \"8\\n\",\n    \"6\\n\",\n    \"8\\n\",\n    \"4\\n\",\n    \"6\\n\",\n    \"10\\n\",\n    \"4\\n\",\n    \"4\\n\",\n    \"10\\n\",\n    \"10\\n\",\n    \"1\\n\",\n    \"99\\n\",\n    \"2\\n\",\n    \"100\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}