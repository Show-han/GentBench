{
    "problem": "You are an expert Python programmer, and here is your task: Many years have passed, and n friends met at a party again. Technologies have leaped forward since the last meeting, cameras with timer appeared and now it is not obligatory for one of the friends to stand with a camera, and, thus, being absent on the photo.\n\nSimply speaking, the process of photographing can be described as follows. Each friend occupies a rectangle of pixels on the photo: the i-th of them in a standing state occupies a w_{i} pixels wide and a h_{i} pixels high rectangle. But also, each person can lie down for the photo, and then he will occupy a h_{i} pixels wide and a w_{i} pixels high rectangle.\n\nThe total photo will have size W \u00d7 H, where W is the total width of all the people rectangles, and H is the maximum of the heights. The friends want to determine what minimum area the group photo can they obtain if no more than n / 2 of them can lie on the ground (it would be strange if more than n / 2 gentlemen lie on the ground together, isn't it?..)\n\nHelp them to achieve this goal.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 1000) \u2014 the number of friends.\n\nThe next n lines have two integers w_{i}, h_{i} (1 \u2264 w_{i}, h_{i} \u2264 1000) each, representing the size of the rectangle, corresponding to the i-th friend.\n\n\n-----Output-----\n\nPrint a single integer equal to the minimum possible area of the photo containing all friends if no more than n / 2 of them can lie on the ground.\n\n\n-----Examples-----\nInput\n3\n10 1\n20 2\n30 3\n\nOutput\n180\n\nInput\n3\n3 1\n2 2\n4 3\n\nOutput\n21\n\nInput\n1\n5 10\n\nOutput\n50",
    "solution": "[\"from operator import neg\\nn = int(input())\\na = [tuple(map(int, input().split())) for i in range(n)]\\n\\ndef check(max_h):\\n    k = n // 2\\n    b = []\\n    for w, h in a:\\n        if h > max_h:\\n            if k <= 0 or w > max_h:\\n                return 1 << 60\\n            b.append((h, w))\\n            k -= 1\\n        else:\\n            b.append((w, h))\\n    b.sort(key=lambda t: t[1] - t[0])\\n    r = 0\\n    for w, h in b:\\n        if k > 0 and w <= max_h and h < w:\\n            r += h\\n            k -= 1\\n        else:\\n            r += w\\n    return r * max_h\\n\\nprint(min(check(h) for h in range(1, 1001)))\\n    \\n        \\n\", \"from operator import neg\\nn = int(input())\\na = [tuple(map(int, input().split())) for i in range(n)]\\n\\ndef check(max_h):\\n    k = n // 2\\n    b = []\\n    for w, h in a:\\n        if h > max_h:\\n            if k <= 0 or w > max_h:\\n                return 1 << 60\\n            b.append((h, w))\\n            k -= 1\\n        else:\\n            b.append((w, h))\\n    b.sort(key=lambda t: t[1] - t[0])\\n    r = 0\\n    for w, h in b:\\n        if k > 0 and w <= max_h and h < w:\\n            r += h\\n            k -= 1\\n        else:\\n            r += w\\n    return r * max_h\\n\\nprint(min(check(h) for h in range(1, 1001)))\\n    \\n        \\n\"]",
    "test": "{\n  \"inputs\": [\n    \"3\\n10 1\\n20 2\\n30 3\\n\",\n    \"3\\n3 1\\n2 2\\n4 3\\n\",\n    \"1\\n5 10\\n\",\n    \"1\\n1 1\\n\",\n    \"1\\n1000 1000\\n\",\n    \"1\\n1 1000\\n\",\n    \"2\\n1 1000\\n1000 1\\n\",\n    \"2\\n1 1\\n1000 1000\\n\",\n    \"1\\n1000 1\\n\",\n    \"5\\n407 830\\n12 199\\n768 215\\n668 28\\n628 310\\n\",\n    \"3\\n379 820\\n923 407\\n916 853\\n\",\n    \"3\\n99 768\\n477 885\\n169 118\\n\",\n    \"3\\n227 612\\n223 259\\n423 895\\n\",\n    \"3\\n651 161\\n480 32\\n485 672\\n\",\n    \"3\\n779 301\\n34 214\\n442 937\\n\",\n    \"3\\n203 145\\n780 692\\n992 713\\n\",\n    \"3\\n627 286\\n37 65\\n53 490\\n\",\n    \"3\\n755 938\\n487 543\\n307 459\\n\",\n    \"3\\n475 487\\n41 20\\n368 236\\n\",\n    \"3\\n922 71\\n719 26\\n462 700\\n\",\n    \"2\\n881 4\\n788 2\\n\",\n    \"2\\n1 304\\n8 892\\n\",\n    \"3\\n227 2\\n223 9\\n423 5\\n\",\n    \"3\\n7 612\\n3 259\\n3 895\\n\",\n    \"4\\n573 7\\n169 9\\n447 7\\n947 3\\n\",\n    \"10\\n864 874\\n534 702\\n73 363\\n856 895\\n827 72\\n435 468\\n888 921\\n814 703\\n648 715\\n384 781\\n\",\n    \"10\\n489 685\\n857 870\\n736 221\\n687 697\\n166 360\\n265 200\\n738 519\\n393 760\\n66 176\\n798 160\\n\",\n    \"1\\n1 1\\n\",\n    \"1\\n1000 1000\\n\",\n    \"1\\n1 1000\\n\",\n    \"2\\n1 1000\\n1000 1\\n\",\n    \"2\\n1 1\\n1000 1000\\n\",\n    \"1\\n1000 1\\n\",\n    \"2\\n1 1\\n1 1\\n\",\n    \"4\\n3 817\\n9 729\\n7 407\\n7 433\\n\",\n    \"3\\n500 500\\n2 1\\n10 5\\n\"\n  ],\n  \"outputs\": [\n    \"180\\n\",\n    \"21\\n\",\n    \"50\\n\",\n    \"1\\n\",\n    \"1000000\\n\",\n    \"1000\\n\",\n    \"2000\\n\",\n    \"1001000\\n\",\n    \"1000\\n\",\n    \"1070700\\n\",\n    \"1570946\\n\",\n    \"614190\\n\",\n    \"781335\\n\",\n    \"756672\\n\",\n    \"728049\\n\",\n    \"1366821\\n\",\n    \"235752\\n\",\n    \"1307660\\n\",\n    \"366224\\n\",\n    \"1013790\\n\",\n    \"6676\\n\",\n    \"8028\\n\",\n    \"7857\\n\",\n    \"11635\\n\",\n    \"19224\\n\",\n    \"4909752\\n\",\n    \"3231747\\n\",\n    \"1\\n\",\n    \"1000000\\n\",\n    \"1000\\n\",\n    \"2000\\n\",\n    \"1001000\\n\",\n    \"1000\\n\",\n    \"2\\n\",\n    \"21242\\n\",\n    \"253500\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}