{
    "problem": "You are an expert Python programmer, and here is your task: Oleg writes down the history of the days he lived. For each day he decides if it was good or bad. Oleg calls a non-empty sequence of days a zebra, if it starts with a bad day, ends with a bad day, and good and bad days are alternating in it. Let us denote bad days as 0 and good days as 1. Then, for example, sequences of days 0, 010, 01010 are zebras, while sequences 1, 0110, 0101 are not.\n\nOleg tells you the story of days he lived in chronological order in form of string consisting of 0 and 1. Now you are interested if it is possible to divide Oleg's life history into several subsequences, each of which is a zebra, and the way it can be done. Each day must belong to exactly one of the subsequences. For each of the subsequences, days forming it must be ordered chronologically. Note that subsequence does not have to be a group of consecutive days. \n\n\n-----Input-----\n\nIn the only line of input data there is a non-empty string s consisting of characters 0 and 1, which describes the history of Oleg's life. Its length (denoted as |s|) does not exceed 200 000 characters.\n\n\n-----Output-----\n\nIf there is a way to divide history into zebra subsequences, in the first line of output you should print an integer k (1 \u2264 k \u2264 |s|), the resulting number of subsequences. In the i-th of following k lines first print the integer l_{i} (1 \u2264 l_{i} \u2264 |s|), which is the length of the i-th subsequence, and then l_{i} indices of days forming the subsequence. Indices must follow in ascending order. Days are numbered starting from 1. Each index from 1 to n must belong to exactly one subsequence. If there is no way to divide day history into zebra subsequences, print -1.\n\nSubsequences may be printed in any order. If there are several solutions, you may print any of them. You do not have to minimize nor maximize the value of k.\n\n\n-----Examples-----\nInput\n0010100\n\nOutput\n3\n3 1 3 4\n3 2 5 6\n1 7\n\nInput\n111\n\nOutput\n-1",
    "solution": "[\"s = input() \\nzero = set() # \\u524d\\u9762\\u7684\\u4e00\\u4e2a\\u4ee50\\u7ed3\\u5c3e\\u7684\\u4e32\\u7684\\u7d22\\u5f15\\none  = set() # \\u524d\\u9762\\u7684\\u4e00\\u4e2a\\u4ee51\\u7ed3\\u5c3e\\u7684\\u4e32\\u7684\\u7d22\\u5f15\\nans  = []    # \\u7ed3\\u679c\\u7684\\u4e32\\nfor i in range(0,len(s)):\\n    if(s[i] == '0'):\\n        if one:\\n            k = one.pop()\\n            zero.add(k)\\n            ans[k].append(i+1)\\n        else:\\n            zero.add(len(ans))\\n            ans.append([i+1])\\n    else:\\n        if not zero:\\n            print(-1)\\n            return\\n        k = zero.pop()\\n        one.add(k)\\n        ans[k].append(i+1)\\nif(one):\\n    print(-1)\\n    return\\nprint(len(ans))\\nprint('\\\\n'.join([str(len(x))+' '+' '.join(map(str,x)) for x in ans]))\\n\", \"s, r, f, p = input(), [], 0, -1\\ntry:\\n    for i in range(len(s)):\\n        j = i + 1\\n        if s[i] == '0':\\n            if p > -1:\\n                r[p].append(j)\\n                p -= 1\\n            else:\\n                r.append([j])\\n        else:\\n            p += 1\\n            r[p].append(j)  \\nexcept:\\n    f = 1\\nif f or p > -1:\\n    print(-1)\\nelse:\\n    print(len(r))\\n    for x in r:\\n        print(len(x), *x)\\n\", \"s = input()\\none = -1\\nans=[]\\np = True\\nfor i in range(0,len(s)):\\n    if s[i]=='0':\\n        if one == -1:\\n            ans.append([i+1])\\n        else:\\n            ans[one].append(i+1)\\n            one-=1\\n    else:\\n        one+=1\\n        if one == len(ans):\\n            p = False\\n            break\\n        else:\\n            ans[one].append(i+1)\\n    #print(ans)\\nif p==False or one !=-1:\\n    print(\\\"-1\\\")\\nelse:\\n    print(len(ans))\\n    print(\\\"\\\\n\\\".join([str(len(sub)) + \\\" \\\" + \\\" \\\".join(map(str, sub)) for sub in ans]))\", \"s = input()\\none = -1\\nans=[]\\np = True\\nfor i in range(0,len(s)):\\n    if s[i]=='0':\\n        if one == -1:\\n            ans.append([i+1])\\n        else:\\n            ans[one].append(i+1)\\n            one-=1\\n    else:\\n        one+=1\\n        if one == len(ans):\\n            p = False\\n            break\\n        else:\\n            ans[one].append(i+1)\\nif p==False or one !=-1:\\n    print(\\\"-1\\\")\\nelse:\\n    print(len(ans))\\n    print(\\\"\\\\n\\\".join([str(len(sub)) + \\\" \\\" + \\\" \\\".join(map(str, sub)) for sub in ans]))\", \"def read_data():\\n    a = list(map(int, list(input().strip())))\\n    return a\\n\\ndef solve():\\n    sol = []\\n    pos = -1\\n    try:\\n        for i in range(0,len(a)):\\n            if a[i] == 0:\\n                if pos > -1:\\n                    sol[pos].append(i+1)\\n                    pos -= 1\\n                else:\\n                    sol.append([i+1])\\n            else:\\n                pos += 1\\n                sol[pos].append(i+1)\\n    except:\\n        return -1\\n    if pos == -1:\\n        return sol\\n    else:\\n        return -1\\n\\ndef print_sol(sol):\\n    if sol == -1:\\n        print(sol)\\n        return 0\\n    print(len(sol))\\n    for list in sol:\\n        print(len(list), *list)\\n\\na = read_data()\\nsol = solve()\\nprint_sol(sol)\\n\", \"from sys import stdin, stdout\\n\\ndef solution():\\n    life = stdin.readline().strip()\\n    result = [[1]]\\n\\n    zeros = [0]\\n    ones = []\\n\\n    if life[0] == '1':\\n        print(\\\"-1\\\")\\n        return\\n\\n    for i in range(1, len(life)):\\n        if life[i] == '0':\\n            if ones:\\n                index = ones.pop()\\n                result[index].append(i+1)\\n                zeros.append(index)\\n            else:\\n                result.append([i+1])\\n                zeros.append(len(result) - 1)\\n        else:\\n            if zeros:\\n                index = zeros.pop()\\n                result[index].append(i+1)\\n                ones.append(index)\\n            else:\\n                print(\\\"-1\\\")\\n                return\\n    #print(result)\\n    if ones:\\n        print(\\\"-1\\\")\\n        return\\n\\n    print(len(result))\\n    print('\\\\n'.join([str(len(x))+' '+' '.join(map(str,x)) for x in result]))\\n\\nsolution()\\n\", \"s = input()\\none = -1\\nans=[]\\np = True\\nfor i in range(0,len(s)):\\n    if s[i]=='0':\\n        if one == -1:\\n            ans.append([i+1])\\n        else:\\n            ans[one].append(i+1)\\n            one-=1\\n    else:\\n        one+=1\\n        if one == len(ans):\\n            p = False\\n            break\\n        else:\\n            ans[one].append(i+1)\\nif p==False or one !=-1:\\n    print(\\\"-1\\\")\\nelse:\\n    print(len(ans))\\n    print(\\\"\\\\n\\\".join([str(len(sub)) + \\\" \\\" + \\\" \\\".join(map(str, sub)) for sub in ans]))\", \"s = input()\\no = -1\\nsol=[]\\np = True\\nfor i in range(0,len(s)):\\n    if s[i]=='0':\\n        if o == -1:\\n            sol.append([i+1])\\n        else:\\n            sol[o].append(i+1)\\n            o-=1\\n    else:\\n        o+=1\\n        if o == len(sol):\\n            p = False\\n            break\\n        else:\\n            sol[o].append(i+1)\\nif p==False or o !=-1:\\n    print(\\\"-1\\\")\\nelse:\\n    print(len(sol))\\n    print(\\\"\\\\n\\\".join([str(len(sub)) + \\\" \\\" + \\\" \\\".join(map(str, sub)) for sub in sol]))\", \"s = input()\\no = -1\\nsol=[]\\np = True\\nfor i in range(0,len(s)):\\n    if s[i]=='0':\\n        if o == -1:\\n            sol.append([i+1])\\n        else:\\n            sol[o].append(i+1)\\n            o-=1\\n    else:\\n        o+=1\\n        if o == len(sol):\\n            p = False\\n            break\\n        else:\\n            sol[o].append(i+1)\\nif p==False or o !=-1:\\n    print(\\\"-1\\\")\\nelse:\\n    print(len(sol))\\n    print(\\\"\\\\n\\\".join([str(len(sub)) + \\\" \\\" + \\\" \\\".join(map(str, sub)) for sub in sol]))\", \"s = input()\\n\\no = -1\\n\\nsol=[]\\n\\np = True\\n\\nfor i in range(0,len(s)):\\n\\n    if s[i]=='0':\\n\\n        if o == -1:\\n\\n            sol.append([i+1])\\n\\n        else:\\n\\n            sol[o].append(i+1)\\n\\n            o-=1\\n\\n    else:\\n\\n        o+=1\\n\\n        if o == len(sol):\\n\\n            p = False\\n\\n            break\\n\\n        else:\\n\\n            sol[o].append(i+1)\\n\\nif p==False or o !=-1:\\n\\n    print(\\\"-1\\\")\\n\\nelse:\\n\\n    print(len(sol))\\n\\n    print(\\\"\\\\n\\\".join([str(len(sub)) + \\\" \\\" + \\\" \\\".join(map(str, sub)) for sub in sol]))\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"s=input()\\nl=[]\\neven=[]\\nodd=[]\\nf=1\\nfor i in range(len(s)):\\n\\tif s[i]=='0':\\n\\t\\tif len(even)!=0:\\n\\t\\t\\tind=even.pop()\\n\\t\\t\\tl[ind].append(i+1)\\n\\t\\t\\todd.append(ind)\\n\\t\\telse:\\n\\t\\t\\tl.append([i+1])\\n\\t\\t\\todd.append(len(l)-1)\\n\\telse:\\n\\t\\tif len(odd):\\n\\t\\t\\tind=odd.pop()\\n\\t\\t\\tl[ind].append(i+1)\\n\\t\\t\\teven.append(ind)\\n\\t\\telse:\\n\\t\\t\\tf=0\\n\\t\\t\\tbreak\\nif f and len(even)==0:\\n\\tprint(len(l))\\n\\tfor x in l:\\n\\t\\tprint(len(x),*x)\\nelse:\\n\\tprint(-1)\", \"s = input()\\nres, p = [], -1\\n\\nfor i in range(len(s)):\\n    j = i + 1\\n    if s[i] == '0':\\n        if p > -1:\\n            res[p].append(j)\\n            p -= 1\\n        else:\\n            res.append([j])\\n    else:\\n        p += 1\\n        if p >= len(res):\\n            print(-1)\\n            return\\n        res[p].append(j)  \\n\\nif p != -1:\\n    print(-1)\\n    return    \\n\\nprint(len(res))\\nfor x in res:\\n    print(len(x), *x)\\n\", \"from collections import deque \\nl=input()\\naz=deque([])\\nz=deque([])\\nf=0\\nfor i in range(len(l)):\\n    if l[i]=='0':\\n        if len(az)==0:\\n            z.append([i+1])\\n        else:\\n            az[0].append(i+1)\\n            z.append(az[0])\\n            az.popleft()\\n    else:\\n        #print(f)\\n        if len(z)==0:\\n            f=1\\n            break \\n        else:\\n            z[0].append(i+1)\\n            az.append(z[0])\\n            z.popleft()\\nif f==1 or len(az)!=0:\\n    print(-1)\\nelse:\\n    print(len(z))\\n    for i in range(len(z)):\\n        print(len(z[i]),*z[i],sep=\\\" \\\")\\n            \"]",
    "test": "{\"inputs\": [\"0010100\\n\", \"111\\n\", \"0\\n\", \"1\\n\", \"0101010101\\n\", \"010100001\\n\", \"000111000\\n\", \"0101001000\\n\", \"0000001000\\n\", \"0101\\n\", \"000101110\\n\", \"010101010\\n\", \"0101001010\\n\", \"0100101100\\n\", \"0110100000\\n\", \"0000000000\\n\", \"1111111111\\n\", \"0010101100\\n\", \"1010000\\n\", \"0001110\\n\", \"0000000000011001100011110101000101000010010111000100110110000011010011110110001100100001001001010010\\n\", \"0010011100000000\\n\"], \"outputs\": [\"3\\n1 1\\n5 2 3 4 5 6\\n1 7\\n\", \"-1\\n\", \"1\\n1 1\\n\", \"-1\\n\", \"-1\\n\", \"-1\\n\", \"3\\n3 1 6 7\\n3 2 5 8\\n3 3 4 9\\n\", \"4\\n5 1 2 3 4 5\\n3 6 7 8\\n1 9\\n1 10\\n\", \"8\\n1 1\\n1 2\\n1 3\\n1 4\\n1 5\\n3 6 7 8\\n1 9\\n1 10\\n\", \"-1\\n\", \"-1\\n\", \"1\\n9 1 2 3 4 5 6 7 8 9\\n\", \"2\\n5 1 2 3 4 5\\n5 6 7 8 9 10\\n\", \"2\\n5 1 2 3 8 9\\n5 4 5 6 7 10\\n\", \"-1\\n\", \"10\\n1 1\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\\n\", \"-1\\n\", \"2\\n3 1 8 9\\n7 2 3 4 5 6 7 10\\n\", \"-1\\n\", \"-1\\n\", \"22\\n1 1\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n7 9 24 25 26 27 28 29\\n7 10 13 14 17 18 23 30\\n11 11 12 15 16 19 22 31 32 33 34 35\\n3 20 21 36\\n3 37 46 47\\n9 38 39 40 45 48 57 58 75 76\\n17 41 42 43 44 49 50 51 54 55 56 59 72 73 74 77 80 81\\n9 52 53 60 71 78 79 82 83 84\\n7 61 64 65 66 67 70 85\\n5 62 63 68 69 86\\n3 87 88 89\\n3 90 91 92\\n5 93 94 95 96 97\\n3 98 99 100\\n\", \"8\\n3 1 8 9\\n5 2 3 4 7 10\\n3 5 6 11\\n1 12\\n1 13\\n1 14\\n1 15\\n1 16\\n\"]}",
    "tags": [
        "reasoning/coding"
    ]
}