{
    "problem": "You are an expert Python programmer, and here is your task: You are given $n$ integer numbers $a_1, a_2, \\dots, a_n$. Consider graph on $n$ nodes, in which nodes $i$, $j$ ($i\\neq j$) are connected if and only if, $a_i$ AND $a_j\\neq 0$, where AND denotes the bitwise AND operation.\n\nFind the length of the shortest cycle in this graph or determine that it doesn't have cycles at all.\n\n\n-----Input-----\n\nThe first line contains one integer $n$ $(1 \\le n \\le 10^5)$\u00a0\u2014 number of numbers.\n\nThe second line contains $n$ integer numbers $a_1, a_2, \\dots, a_n$ ($0 \\le a_i \\le 10^{18}$).\n\n\n-----Output-----\n\nIf the graph doesn't have any cycles, output $-1$. Else output the length of the shortest cycle.\n\n\n-----Examples-----\nInput\n4\n3 6 28 9\n\nOutput\n4\nInput\n5\n5 12 9 16 48\n\nOutput\n3\nInput\n4\n1 2 4 8\n\nOutput\n-1\n\n\n-----Note-----\n\nIn the first example, the shortest cycle is $(9, 3, 6, 28)$.\n\nIn the second example, the shortest cycle is $(5, 12, 9)$.\n\nThe graph has no cycles in the third example.",
    "solution": "[\"from collections import deque\\nbits = [0] * 64\\nn = int(input())\\ndata = list([x for x in map(int, input().split()) if x != 0])\\nn = len(data)\\nif n == 0:\\n    print(-1)\\n    return\\nfor v in data:\\n    i = 0\\n    while v != 0:\\n        bits[i] += v & 1\\n        i += 1\\n        v >>= 1\\nfor i in range(64):\\n    if bits[i] > 2:\\n        print(3)\\n        return\\ngraph = [[] for _ in range(n)]\\nfor u in range(n):\\n    for v in range(u):\\n        if (data[u] & data[v]) != 0 and u != v:\\n            graph[v].append(u)\\n            graph[u].append(v)\\n\\n\\ndef bfs(start):\\n    group = [-1] * n\\n    depth = [0] + [-1] * (n - 1)\\n    for j in range(len(graph[start])):\\n        to = graph[start][j]\\n        group[to] = j\\n        depth[to] = 1\\n    bfsQ = deque(graph[start])\\n    minlen = 999999999\\n    while len(bfsQ) > 0:\\n        u = bfsQ[0]\\n        bfsQ.popleft()\\n        for v in graph[u]:\\n            if v == start:\\n                if depth[u] < 2:\\n                    continue\\n                return depth[u] + 1\\n            if group[v] == -1:\\n                group[v] = group[u]\\n                depth[v] = depth[u] + 1\\n                bfsQ.append(v)\\n            elif group[v] != group[u]:\\n                newlen = depth[u] + depth[v] + 1\\n                if newlen < minlen:\\n                    minlen = newlen\\n    return minlen\\n\\n\\nanswer = min(list(map(bfs, list(range(n)))))\\nprint(answer if answer <= n else -1)\\n\", \"from collections import Counter, deque\\n\\nn = int(input())\\narr = list([x for x in map(int, input().strip().split()) if x != 0])\\n\\n'''\\nfor i, a in enumerate(arr):\\n    for j, b in enumerate(arr):\\n        if a & b != 0 and i != j:\\n            print(i,j,a,b)\\nreturn\\n'''\\n\\nc = Counter()\\n\\nfor each in arr:\\n    for b in range(0, 64):\\n        if (1 << b) & each != 0:\\n            c[b] += 1\\n            if c[b] >= 3:\\n                print(3)\\n                return\\n\\nans = 1234567\\n\\nfor idx, st in enumerate(arr):\\n    dists = {}\\n    q = deque()\\n    q.append((idx, -1))\\n    dists[idx] = 0\\n\\n    while q:\\n        node, par = q[0]\\n        dist = dists[node]\\n        q.popleft()\\n        for idx2, v in enumerate(arr):\\n            if idx2 == par:\\n                continue\\n            if idx2 == node or (v & arr[node]) == 0:\\n                continue\\n            if idx2 in dists:\\n                candidate = dists[idx2] + dist + 1\\n                if candidate != 2:\\n                    ans = min(ans, candidate)\\n                continue\\n            dists[idx2] = dist + 1\\n            q.append((idx2, node))\\n\\n\\nif ans == 1234567:\\n    print(-1)\\nelse:\\n    print(ans)\\n\", \"import sys\\nn=int(input())\\na=[]\\n\\nfor x in input().split():\\n    if(int(x)!=int(0)):\\n        a.append(int(x))\\n\\nif(len(a)>500):\\n    print(3)\\n    return\\n\\nn=len(a)\\n\\n#print(n)\\n\\ng=[]\\nfor i in range(n):\\n   g.append([])\\n\\nfor i in range(n):\\n    for j in range(n):\\n        g[i].append(1000000000)\\n\\nfor i in range(n):\\n    for j in range(n):\\n        if(i!=j and (a[i]&a[j])!=0):\\n            g[i][j]=1\\n\\n\\nans=int(10000000000)\\n\\ndis=[]\\nfor i in range(n):\\n    dis.append([])\\n\\nfor i in range(n):\\n    for j in range(n):\\n        dis[i].append(g[i][j])\\n\\nfor  k in range(n):\\n    for i in range(k):\\n        for j in range(i+1,k):\\n            ans=min(ans,dis[i][j]+g[i][k]+g[k][j])\\n    for i in range(n):\\n        for j in range(n):\\n            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])\\n\\n\\n\\nif(ans>1000):\\n    print(-1)\\nelse:\\n    print(ans)\\n\", \"import sys\\nfrom collections import deque\\n\\nn = int(input())\\na = list(map(int, input().split()))\\nna = list()\\nfor x in a:\\n    if (x):\\n        na.append(x)\\na = na\\nn = len(a)\\nfor b in range(60):\\n    cnt = 0\\n    for x in a:\\n        if (x >> b & 1):\\n            cnt += 1\\n    if (cnt >= 3) :\\n        print(3)\\n        return\\ng = [list() for x in range(n)]\\nfor i in range(n):\\n    for j in range (n):\\n        if (i != j and (a[i] & a[j])):\\n            g[i].append(j)\\nans = 200\\ndef go(r):\\n    nonlocal ans\\n    d = [-1 for x in range(n)]\\n    q = deque()\\n    d[r] = 0\\n    q.append(r)\\n    while (len(q)):\\n        v = q.popleft()\\n        for u in g[v]:\\n            if (d[u] == -1):\\n                d[u] = d[v] + 1\\n                q.append(u)\\n            elif (d[u] >= d[v]):\\n                ans = min(ans, d[v] + d[u] + 1)\\nfor r in range(n):\\n    go(r)\\nif (ans > n) :\\n    ans = -1\\nprint(ans)\", \"from collections import defaultdict\\n\\nn = int(input())\\n\\narr = list(map(int, input().split()))\\n\\nd = defaultdict(list)\\ndd = defaultdict(list)\\n\\nfor i, el in enumerate(arr):\\n    b = '{0:b}'.format(el)[::-1]\\n    for j, digit in enumerate(b):\\n        if digit == '1':\\n            for i2 in d[j]:\\n                dd[i].append(i2)\\n                dd[i2].append(i)\\n            d[j].append(i)\\n        if len(d[j]) == 3:\\n            print(3)\\n            return\\n\\ncolors = {i: [] for i in range(len(arr))}\\n\\nmin_cycle = float('+inf')\\n\\nfor i in range(len(arr)):\\n    if colors[i]:\\n        continue\\n    tier = [(i, [])]\\n    next_tier = []\\n    while tier:\\n        for t, way in tier:\\n            if colors[t]:\\n                c = 0\\n                while len(way) > c and len(colors[t]) > c and way[c] == \\\\\\n                        colors[t][c]:\\n                    c += 1\\n                min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1,\\n                                min_cycle)\\n                continue\\n            colors[t] = way + [t]\\n            for k in dd[t]:\\n                if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\\n                    next_tier.append((k, colors[t]))\\n        tier = next_tier\\n        next_tier = []\\n\\nif min_cycle < 1e9:\\n    print(min_cycle)\\nelse:\\n    print(-1)\\n\\npass\", \"# 1205B\\ndef do():\\n    n = int(input())\\n    nums = [int(c) for c in input().split(\\\" \\\")]\\n    valid = set()\\n    for i in range(64):\\n        count = []\\n        for j in range(n):\\n            if (1 << i) & nums[j]:\\n                count.append(nums[j])\\n            if len(count) == 3:\\n                return 3\\n        if len(count) == 2:\\n            valid.add(count[0])\\n            valid.add(count[1])\\n    # valid won't be that large hahaha at most 64*2\\n    nv = len(valid)\\n    valid = list(valid)\\n    dis = [[float('inf')] * nv for _ in range(nv)]\\n    for i in range(nv):\\n        for j in range(nv):\\n            if i == j:\\n                dis[i][j] = 0\\n            elif valid[i] & valid[j]:\\n                dis[i][j] = 1\\n    mp = [[_ for _ in dis[i]] for i in range(len(dis))]\\n    res = nv + 1\\n    for k in range(nv):\\n        for i in range(nv):\\n            if k != i:\\n                for j in range(nv):\\n                    if k != j and i != j:\\n                        res = min(res, dis[i][j] + mp[j][k] + mp[k][i])\\n        for i in range(nv):\\n            if k != i:\\n                for j in range(nv):\\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\\n    return res if res <= nv else -1\\n\\nprint(do())\\n\\n\\n\\n\\n\\n\", \"# 1205B\\ndef do():\\n    n = int(input())\\n    nums = [int(c) for c in input().split(\\\" \\\")]\\n    valid = set()\\n    for i in range(64):\\n        count = []\\n        for j in range(n):\\n            if (1 << i) & nums[j]:\\n                count.append(nums[j])\\n            if len(count) == 3:\\n                return 3\\n        if len(count) == 2:\\n            valid.add(count[0])\\n            valid.add(count[1])\\n    # valid won't be that large hahaha at most 64*2\\n    nv = len(valid)\\n    valid = list(valid)\\n    dis = [[float('inf')] * nv for _ in range(nv)]\\n    for i in range(nv):\\n        for j in range(nv):\\n            if i == j:\\n                dis[i][j] = 0\\n            elif valid[i] & valid[j]:\\n                dis[i][j] = 1\\n    mp = [[_ for _ in dis[i]] for i in range(len(dis))]\\n    res = nv + 1\\n    for k in range(nv):\\n        for i in range(k):\\n            for j in range(k):\\n                if i != j:\\n                    res = min(res, dis[i][j] + mp[j][k] + mp[k][i])\\n        for i in range(nv):\\n            if k != i:\\n                for j in range(nv):\\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\\n    return res if res <= nv else -1\\n\\nprint(do())\\n\\n\\n\\n\\n\\n\", \"from collections import deque\\n\\nn=int(input())\\ns=[int(x) for x in input().split()]\\nb=[]\\nmx=-1\\nfor i in range(0,len(s)):\\n    t=bin(s[i])\\n    t=t[2:]\\n    b.append(t)\\n    mx=max(mx,len(t))\\n\\nfor i in range(0,len(b)):\\n    b[i]='0'*(mx-len(b[i]))+b[i]\\n\\nflag=0\\nL=[]\\nkk=dict()\\nfor i in range(0,mx):\\n    c=0\\n    h=[]\\n    for j in range(0,len(b)):\\n        if(b[j][i]=='1'):\\n            c+=1\\n            h.append(j)\\n    if(len(h)==2 and kk.get(tuple(h))==None):\\n        h=tuple(h)\\n        L.append(h)\\n        kk[h]=1\\n    if(c>2):\\n        flag=1\\n        break\\n#print(L)\\n\\nif(flag==1):\\n    print(3)\\nelse:\\n    temp=1000000007\\n    for i in range(0,len(L)):\\n\\n        arr=[]\\n        for j in range(n):\\n            s1=[]\\n            arr.append(s1)\\n\\n        for j in range(0,len(L)):\\n            if(j==i):\\n                src=L[j][0]\\n                dst=L[j][1]\\n\\n            else:\\n                arr[L[j][0]].append(L[j][1])\\n                arr[L[j][1]].append(L[j][0])\\n\\n        q=deque()\\n        q.append((src,0))\\n        visited=[False]*n\\n        visited[src]=True\\n\\n        while(q):\\n\\n            r=q.popleft()\\n\\n            visited[r[0]]=True\\n            if(r[0]==dst):\\n                temp=min(temp,r[1]+1)\\n                break\\n\\n            for j in arr[r[0]]:\\n                if(visited[j]==False):\\n                    q.append((j,r[1]+1))\\n\\n\\n    if(temp==1000000007):\\n        print(-1)\\n    else:\\n        print(temp)\\n\\n        \\n\\n        \\n                \\n    \\n\", \"\\nclass node():\\n\\tdef __init__(self, v, edges):\\n\\t\\tself.value = v\\n\\t\\tself.edges = edges\\n \\nn = int(input())\\na = [int(i) for i in input().split(\\\" \\\")]\\n \\n \\ndef fun(a):\\n\\tnodes = {}\\n\\tfor i in range(60):\\n\\t\\tk = 0\\n\\t\\tvalue = 1 << i\\n\\t\\ti_edges = set()\\n\\t\\tfor j in a:\\n\\t\\t\\tif value&j > 0:\\n#                 print(i+1)\\n\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\tif k > 2:\\n\\t\\t\\t\\t\\tdel i_edges\\n\\t\\t\\t\\t\\tdel nodes\\n\\t\\t\\t\\t\\treturn 3\\n\\t\\t\\t\\ti_edges.add(j)\\n\\t\\tfor j in i_edges:\\n\\t\\t\\tif j not in nodes:\\n\\t\\t\\t\\tif (i_edges.difference({j})) != 0:\\n\\t\\t\\t\\t\\tnodes[j] = node(j,i_edges.difference({j}))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnodes[j].edges = nodes[j].edges.union(i_edges.difference({j}))\\n\\treturn nodes\\n \\ndef find_short_path(v1, v2):\\n\\tlength = 0\\n\\tv2 = {v2}\\n\\tsetic = set()\\n\\tset_was = set()\\n\\twhile (v1 not in setic):\\n\\t\\tdel setic\\n\\t\\tsetic = set()\\n\\t\\tfor i in v2:\\n\\t\\t\\tsetic = setic.union(nodes[i].edges.difference(set_was))\\n\\t\\tset_was = set_was.union(setic)\\n\\t\\tif len(setic) == 0:\\n\\t\\t\\tdel v2\\n\\t\\t\\treturn 0\\n\\t\\tlength += 1\\n\\t\\tdel v2\\n\\t\\tv2 = setic.copy()\\n\\tdel set_was\\n\\tdel setic\\n\\treturn length\\n \\n \\nnodes = fun(a)\\nif type(nodes) == int:\\n\\tprint(3)\\nelse:\\n\\tmass = []\\n\\twhile len(nodes.keys()) != 0:\\n\\t\\t# print(type(nodes.keys()))\\n\\t\\ti = list(nodes.keys())[0]\\n\\t\\tif len(nodes[i].edges) != 0:\\n\\t\\t\\t\\n\\t\\t\\tfirst_v = i\\n\\t\\t\\tsecond_v = nodes[first_v].edges.pop()\\n\\t\\t\\tnodes[second_v].edges.remove(first_v)\\n\\t\\t\\tlength = 0\\n\\t\\t\\tif len(nodes[first_v].edges) == 0:\\n\\t\\t\\t\\tnodes.pop(first_v)\\n\\t\\t\\telif len(nodes[second_v].edges) == 0:\\n\\t\\t\\t\\tnodes.pop(second_v)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlength = find_short_path(first_v, second_v)\\n\\t\\n\\t\\t\\tif length:\\n\\t\\t\\t\\tmass.append(length + 1)\\n\\t\\telse:\\n\\t\\t\\tnodes.pop(i)\\n\\t\\t\\t\\n\\tif len(mass) != 0:\\n\\t\\tprint(min(mass))\\n\\telse:\\n\\t\\tprint(-1)\", \"\\nfrom sys import stdin\\nimport os\\nimport sys\\nfrom atexit import register\\nfrom io import BytesIO\\nimport itertools\\n\\n\\n# sys.stdout = BytesIO()\\n# register(lambda: os.write(1, sys.stdout.getvalue()))\\n#\\n# input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\\n# if sys.version_info[0] < 3:\\n#     range = xrange\\n#     filter = itertools.ifilter\\n#     map = itertools.imap\\n#     zip = itertools.izip\\n\\n\\ndef bfs(src, dest, adj):\\n    visited = [False for _ in range(len(adj))]\\n    visited[src] = True\\n    queue = [src]\\n    i = 1\\n    while len(queue)>0:\\n        newq = []\\n        i += 1\\n        for node in queue:\\n            for vertex in adj[node]:\\n                if node==src and vertex==dest: continue\\n                if not visited[vertex]:\\n                    newq.append(vertex)\\n                    visited[vertex] = True\\n                    if vertex==dest:\\n                        return i\\n        queue = newq\\n    return -1\\n\\n\\ndef main():\\n    n = int(input())\\n    li = list(map(int, input().split()))\\n    binaries = [0]*n\\n    adj = [set() for _ in range(n)]\\n    for index, i in enumerate(li):\\n        binaries[index] = (bin(i)[2:].zfill(60))\\n    edges = set()\\n    #print(\\\"Pass 0\\\")\\n    for j in range(60):\\n        indexes = []\\n        for i in range(n):\\n            if binaries[i][j] == '1':\\n                indexes.append(i)\\n                if len(indexes) == 3:\\n                    print(3)\\n                    return\\n        if len(indexes)==2:\\n            indexes.sort()\\n            edges.add(tuple(indexes))\\n            adj[indexes[0]].add(indexes[1])\\n            adj[indexes[1]].add(indexes[0])\\n    #print(edges, adj)\\n    min_cycle = -1\\n    for li in edges:\\n        le = bfs(li[0], li[1], adj)\\n        #print(li, le, min_cycle)\\n        if min_cycle==-1:\\n            min_cycle = le\\n        elif le>-1:\\n            min_cycle = min(min_cycle, le)\\n    print(min_cycle)\\n\\nmain()\\n\", \"from collections import defaultdict, deque\\nimport sys\\n\\nn = int(input())\\na = [int(val) for val in input().split()]\\na = [val for val in a if val > 0]\\nn = len(a)\\n\\ncount = defaultdict(list)\\nfor i, val in enumerate(a):\\n    power = 0\\n    while val > 0:\\n        if val % 2 == 1:\\n            count[power].append(i)\\n        power +=1\\n        val = val >> 1\\n\\nfor power, val in list(count.items()):\\n    if len(val) >= 3:\\n        print(3)\\n        return\\n\\nG = defaultdict(list)\\nfor i in range(n - 1):\\n    for j in range(i + 1, n):\\n        if a[i] & a[j] > 0:\\n            G[i].append(j) \\n            G[j].append(i) \\n\\nmin_cycle = n + 1\\nfor key, _ in list(G.items()):\\n    qu = deque()\\n    qu.append((key, 0, None))\\n    visited = {}\\n    while len(qu) > 0:\\n        node = qu.popleft()\\n        visited[node[0]] = node[1]\\n        for child in G[node[0]]:\\n            if child not in visited:\\n                 qu.append((child, node[1] + 1, node[0]))\\n            else:\\n                if node[2] != child:\\n                    min_cycle = min(min_cycle, visited[child] + node[1] + 1)\\nif min_cycle == n + 1:\\n    print(-1)\\nelse:\\n    print(min_cycle)\\n\\n\", \"import sys\\ninput=sys.stdin.readline\\nimport collections\\nfrom collections import defaultdict\\n\\nvisited=set()\\nmem=[]\\nG=defaultdict(list)\\nn=int(input())\\nl=[int(i) for i  in input().split()]\\nl=[i for i in l if i>0]\\n\\nif len(l)>=128 :\\n    print(3)\\nelif len(l)<3:\\n    print(-1)\\nelse:\\n    for i in range(1,len(l)):\\n        for j in range(0,i):\\n            if l[i]&l[j]!=0:\\n                G[i].append(j)\\n                G[j].append(i)\\n    #print(G)\\n    min_cycle = n + 1\\n    for key, _ in list(G.items()):\\n        #print(key,_)\\n        qu = collections.deque()\\n        qu.append((key, 0, None))\\n        visited = {}\\n        while len(qu) > 0:\\n            #print(qu,visited)\\n            node = qu.popleft()\\n            visited[node[0]] = node[1]\\n            for child in G[node[0]]:\\n                if child not in visited:\\n                     qu.append((child, node[1] + 1, node[0]))\\n                     #print(qu)\\n                else:\\n                    if node[2] != child:\\n                        min_cycle = min(min_cycle, visited[child] + node[1] + 1)\\n                        #print(min_cycle,visited[child],node[1])\\n    if min_cycle == n + 1:\\n        print(-1)\\n    else:\\n        print(min_cycle)\\n\\n    \\n\", \"from collections import deque\\n\\n\\ninput()\\nh = [list(bin(int(i)))[2:] for i in input().split()]\\nsas = min(list(map(len, h)))\\nans = 1e9\\ngraf = [[] for _ in range(100000)]\\nrebra = []\\ndef bfs(assx, sasx):\\n    q = deque()\\n    q.append(assx)\\n    metka = [1 for _ in range(100000)]\\n    metka[assx] = 0\\n    dis = [0 for _ in range(100000)]\\n    while q:\\n        x = q.popleft()\\n        for i in graf[x]:\\n            if i == sasx and x != assx:\\n                return dis[x] + 2\\n            if metka[i] and (i != sasx or x != assx):\\n                metka[i] = 0\\n                dis[i] = dis[x] + 1\\n                q.append(i)\\n    return 0\\nfor i in range(len(h)):\\n    h[i].reverse()\\nfor i in range(60):\\n    r = 0\\n    ass = []\\n    for j in range(len(h)):\\n        if len(h[j]) <= i:\\n            continue\\n        if int(h[j][i]):\\n            r += 1\\n            ass.append(j)\\n    if r >= 3:\\n        print(3)\\n        return\\n    if len(ass) > 1:\\n        graf[ass[0]].append(ass[1])\\n        graf[ass[1]].append(ass[0])\\n        rebra.append(ass)\\nfor i in rebra:\\n    g = bfs(i[0], i[1])\\n    if g:\\n        ans = min(ans, g)\\nprint(ans if ans != 1e9 else -1)\\n\", \"# -*- coding: utf-8 -*-\\n\\nimport math\\nimport collections\\nimport bisect\\nimport heapq\\nimport time\\nimport random\\nimport itertools\\nimport sys\\nfrom typing import List\\n\\n\\\"\\\"\\\"\\ncreated by shhuan at 2020/1/10 01:32\\n\\n\\\"\\\"\\\"\\n\\n\\ndef shortest_path(u, v, g):\\n    q = [w for w in g[u] if w != v]\\n    vis = set(q) | {u}\\n    d = 0\\n    while q:\\n        d += 1\\n        nq = []\\n        for w in q:\\n            if w == v:\\n                return d\\n            for x in g[w]:\\n                if x not in vis:\\n                    vis.add(x)\\n                    nq.append(x)\\n        q = nq\\n\\n    return float('inf')\\n\\n\\ndef solve(N, A):\\n    b = 1\\n    g = collections.defaultdict(list)\\n    edges = []\\n    for i in range(64):\\n        connected = [i for i, v in enumerate(A) if v & b > 0]\\n        if len(connected) >= 3:\\n            return 3\\n        for u in connected:\\n            for v in connected:\\n                if u != v:\\n                    g[u].append(v)\\n                    edges.append((u, v))\\n        b <<= 1\\n\\n    # print(g)\\n    ans = float('inf')\\n    for u, v in edges:\\n        # remove edge u, v\\n        # print(u, v, shortest_path(u, v, g))\\n        ans = min(ans, 1 + shortest_path(u, v, g))\\n\\n    return ans if ans < float('inf') else -1\\n\\n\\nN = int(input())\\nA = [int(x) for x in input().split()]\\nprint(solve(N, A))\", \"from collections import deque\\ninf = int(1e6)\\n\\n\\nclass Graph:\\n    def __init__(self, n):\\n        self.n = n\\n        self.adj = [[] for i in range(n)]\\n        self.loop = inf\\n\\n    def add_edge(self, u, v):\\n        self.adj[u].append(v)\\n        self.adj[v].append(u)\\n\\n    def find_loop(self):\\n        for i in range(n):\\n            q = deque()\\n            q.append(i)\\n            depth = [-1] * n\\n            depth[i] = 0\\n            while len(q) > 0:\\n                u = q.popleft()\\n                for v in self.adj[u]:\\n                    if depth[v] >= depth[u]:\\n                        self.loop = min(self.loop, depth[u] + depth[v] + 1)\\n                    if depth[v] == -1:\\n                        depth[v] = depth[u] + 1\\n                        q.append(v)\\n        return -1 if self.loop == inf else self.loop\\n\\n\\ninput()\\na = list([x for x in map(int, input().split(' ')) if x != 0])\\nn = len(a)\\ngroups = [0] * 64\\nfor num in a:\\n    t = '{0:b}'.format(num)\\n    l = len(t)\\n    curr = 0\\n    for i in range(l):\\n        if t[l - i - 1] == '1':\\n            groups[i] += 1\\n\\nloop = -1\\nfor cnt in groups:\\n    if cnt >= 3:\\n        loop = 3\\n        break\\nif loop == 3:\\n    print(3)\\nelse:\\n    g = Graph(n)\\n    for i in range(n-1):\\n        for j in range(i + 1, n):\\n            if a[i] & a[j] != 0:\\n                g.add_edge(i, j)\\n    print(g.find_loop())\\n\", \"import sys\\nimport math\\nfrom collections import defaultdict\\n\\ndef print_graph(graph):\\n    for key, values in graph.items():\\n        [print(key,nodo) for nodo in values]\\n\\ndef BFS(graph, n, start, end):\\n    #print(\\\"==================\\\")\\n    #print(\\\"Partiendo BFS:\\\")\\n    #print(\\\"Nodo Start:\\\", start)\\n    #print(\\\"Nodo end:\\\", end)\\n    q = [ (start,0) ]\\n    visited = [False for x in range(n)]\\n    visited[start] = True\\n    while (len(q) >0):\\n        aux = q.pop(0)\\n        actual = aux[0]\\n        peso = aux[1]+1\\n        #print(\\\"===========\\\")\\n        #print(\\\"Nodo Actual:\\\",actual)\\n        for vecino in graph[actual]:\\n            \\n            #saltamos el arco base\\n            if not visited[vecino] and not ((actual == start and end == vecino) or (vecino == start and end == actual)):\\n                #print(\\\"Vecino:\\\",vecino)\\n                q.append( (vecino, peso) )\\n                visited[vecino] = True\\n                if vecino == end:\\n                    peso+=1\\n                    #print(\\\"PESO FINAL:\\\", peso)\\n                    return peso\\n        \\n        #print(\\\"peso hasta el momento:\\\", peso)\\n    return -1    \\n \\nlines = sys.stdin.read().split(\\\"\\\\n\\\")\\nlines.pop(-1)\\n#lines = [\\\"50\\\", \\\"65600 17825792 0 288230376285929472 16392 0 0 16896 0 0 10486272 140737488355330 65537 171798691840 571746046443520 0 0 33024 0 2052 36028797155278848 36028805608898560 0 0 562967133290496 0 0 0 146028888064 281474976710660 0 288230376151711746 8388864 0 17180393472 0 0 0 68719476737 34376515584 0 299067162755072 68719478784 0 9007199255789568 140737488879616 9007199254773760 8796093022272 4294967304 17596481011712\\\"]\\n#lines = [\\\"4\\\", \\\"3 6 28 9\\\"]\\nn = int(lines[0].strip())\\n#nodos_int = [  int(x) for x in lines[1].strip().split(\\\" \\\")]\\nnodos = [  \\\"{0:b}\\\".format(int(x)).zfill(60) for x in lines[1].strip().split(\\\" \\\")]\\ngraph = dict()\\nvertex = []\\n \\nfor i in range(n):\\n    graph[i] = []\\n    \\nfor bit in range(60):\\n    count = 0\\n    q = []\\n    for index in range(n):\\n        if nodos[index][bit] =='1':\\n            count+=1\\n            q.append(index)\\n    if count==2:\\n        graph[q[0]] += [q[1]]\\n        graph[q[1]] += [q[0]]\\n        vertex.append([q[0],q[1]])\\n    if count>2:\\n        print(3)\\n        return\\n \\n##print(vertex)\\n##print(graph)\\n        \\nminimo = -1\\nfor index in range(n):\\n    while len(vertex) > 0:\\n        a,b = vertex.pop(0)\\n        peso = BFS(graph, n ,a,b)\\n        if (peso > 0):\\n            if minimo == -1:\\n                minimo = peso\\n            elif peso<minimo:\\n                minimo = peso\\n        \\nprint(minimo)\\n#print_graph(graph)\\n\", \"n=int(input())\\nlinea = input()\\nsep = linea.split()\\nnodos = list(map(int, sep))\\n\\nconexiones=[list() for i in range(n)]\\nlista_bits = [list() for i in range(64)]\\nj = 0\\nfor caquita in nodos:\\n    if caquita != 0:\\n        for z in range(64):\\n            if not (caquita >> z):\\n                break\\n            bit = (caquita >> z) & 1\\n            if bit == 1:\\n                lista_bits[z].append(j)\\n    else:\\n        j -= 1\\n        n -= 1\\n    j += 1\\n\\n\\n# Python3 implementation of the approach \\nfrom sys import maxsize as INT_MAX \\nfrom collections import deque \\n  \\ngr = conexiones\\n  \\n# Function to find the length of \\n# the shortest cycle in the graph \\ndef shortest_cycle(n: int) -> int: \\n  \\n    # To store length of the shortest cycle \\n    ans = INT_MAX \\n  \\n    # For all vertices \\n    for i in range(n): \\n  \\n        # Make distance maximum \\n        dist = [int(1e9)] * n \\n  \\n        # Take a imaginary parent \\n        par = [-1] * n \\n  \\n        # Distance of source to source is 0 \\n        dist[i] = 0\\n        q = deque() \\n  \\n        # Push the source element \\n        q.append(i) \\n  \\n        # Continue until queue is not empty \\n        while q: \\n  \\n            # Take the first element \\n            x = q[0] \\n            q.popleft() \\n  \\n            # Traverse for all it's childs \\n            for child in gr[x]: \\n  \\n                # If it is not visited yet \\n                if dist[child] == int(1e9): \\n  \\n                    # Increase distance by 1 \\n                    dist[child] = 1 + dist[x] \\n  \\n                    # Change parent \\n                    par[child] = x \\n  \\n                    # Push into the queue \\n                    q.append(child) \\n  \\n                # If it is already visited \\n                elif par[x] != child and par[child] != x: \\n                    ans = min(ans, dist[x] + \\n                                   dist[child] + 1) \\n  \\n    # If graph contains no cycle \\n    if ans == INT_MAX: \\n        return -1\\n  \\n    # If graph contains cycle \\n    else: \\n        return ans \\n\\nal_menos_tres = False\\nson_2 = False\\nfor listita in lista_bits:\\n    if len(listita) >= 3:\\n        al_menos_tres = True\\n        break\\n    elif len(listita) == 2:\\n        son_2 = True\\n        x = listita[0]\\n        y = listita[1]\\n        gr[x].append(y)\\n        gr[y].append(x)\\n\\nif al_menos_tres:\\n    print(3)\\nelif not son_2:\\n    print(-1)\\nelse:\\n    print(shortest_cycle(n)) \\n\\n# This code is contributed by \\n# sanjeev2552 \\n\\n\", \"from sys import maxsize as INT_MAX \\nfrom collections import deque \\n  \\nn=int(input())\\nlinea = input()\\nsep = linea.split()\\nnodos = list(map(int, sep))\\nbits= [list() for i in range (64)]\\nj=0\\nfor s in nodos:\\n    if s!=0:\\n        for i in range(64):\\n            bit=(s >> i) & 1\\n            if bit==1:\\n                bits[i].append(j)\\n    else:\\n        j-=1\\n        n-=1\\n    j+=1\\ndos= False\\nejecucion= True\\ngr=[list() for i in range (n)]\\nfor k in bits:\\n    if len(k)==2:\\n        dos=True\\n        x= k[0]\\n        y= k[1]\\n        gr[x].append(y)\\n        gr[y].append(x)\\n    elif len(k) >= 3:\\n        ejecucion= False\\n        break\\nif ejecucion==False: \\n    print(3)\\nelif not dos:\\n    print(-1)\\nelse:\\n    # Python3 implementation of the approach \\n      \\n    # Function to find the length of \\n    # the shortest cycle in the graph \\n    def shortest_cycle(n: int) -> int: \\n      \\n        # To store length of the shortest cycle \\n        ans = INT_MAX \\n      \\n        # For all vertices \\n        for i in range(n): \\n      \\n            # Make distance maximum \\n            dist = [int(1e9)] * n \\n      \\n            # Take a imaginary parent \\n            par = [-1] * n \\n      \\n            # Distance of source to source is 0 \\n            dist[i] = 0\\n            q = deque() \\n      \\n            # Push the source element \\n            q.append(i) \\n      \\n            # Continue until queue is not empty \\n            while q: \\n      \\n                # Take the first element \\n                x = q[0] \\n                q.popleft() \\n      \\n                # Traverse for all it's childs \\n                for child in gr[x]: \\n      \\n                    # If it is not visited yet \\n                    if dist[child] == int(1e9): \\n      \\n                        # Increase distance by 1 \\n                        dist[child] = 1 + dist[x] \\n      \\n                        # Change parent \\n                        par[child] = x \\n      \\n                        # Push into the queue \\n                        q.append(child) \\n      \\n                    # If it is already visited \\n                    elif par[x] != child and par[child] != x: \\n                        ans = min(ans, dist[x] + \\n                                       dist[child] + 1) \\n      \\n        # If graph contains no cycle \\n        if ans == INT_MAX: \\n            return -1\\n      \\n        # If graph contains cycle \\n        else: \\n            return ans \\n      \\n      \\n    # Function call \\n    print(shortest_cycle(n)) \\n      \\n    # This code is contributed by \\n    # sanjeev2552 \\n\\n\", \"import sys\\ninput=sys.stdin.readline\\nimport collections\\nfrom collections import defaultdict\\n\\nvisited=set()\\nmem=[]\\nG=defaultdict(list)\\nn=int(input())\\nl=[int(i) for i  in input().split()]\\nl=[i for i in l if i>0]\\n\\nif len(l)>=121 :\\n    print(3)\\nelif len(l)<3:\\n    print(-1)\\nelse:\\n    for i in range(1,len(l)):\\n        for j in range(0,i):\\n            if l[i]&l[j]!=0:\\n                G[i].append(j)\\n                G[j].append(i)\\n    #print(G)\\n    min_cycle = n + 1\\n    for key, _ in list(G.items()):\\n        #print(key,_)\\n        qu = collections.deque()\\n        qu.append((key, 0, None))\\n        visited = {}\\n        while len(qu) > 0:\\n            #print(qu,visited)\\n            node = qu.popleft()\\n            visited[node[0]] = node[1]\\n            for child in G[node[0]]:\\n                if child not in visited:\\n                     qu.append((child, node[1] + 1, node[0]))\\n                     #print(qu)\\n                else:\\n                    if node[2] != child:\\n                        min_cycle = min(min_cycle, visited[child] + node[1] + 1)\\n                        #print(min_cycle,visited[child],node[1])\\n    if min_cycle == n + 1:\\n        print(-1)\\n    else:\\n        print(min_cycle)\\n\\n    \\n\", \"from sys import stdin\\nfrom collections import deque\\n\\n\\nINT_MAX = float('inf')\\ndef shortest_cycle(gr): \\n  \\n    # To store length of the shortest cycle \\n    ans = INT_MAX \\n  \\n    # For all vertices \\n    for i in gr: \\n  \\n        # Make distance maximum \\n        dist = {x:int(1e9) for x in gr}\\n  \\n        # Take a imaginary parent \\n        par = {x:-1 for x in gr} \\n  \\n        # Distance of source to source is 0 \\n        dist[i] = 0\\n        q = deque() \\n  \\n        # Push the source element \\n        q.append(i) \\n  \\n        # Continue until queue is not empty \\n        while q: \\n  \\n            # Take the first element \\n            x = q.popleft() \\n  \\n            # Traverse for all it's childs \\n            for child in gr[x]: \\n  \\n                # If it is not visited yet \\n                if dist[child] == int(1e9): \\n  \\n                    # Increase distance by 1 \\n                    dist[child] = 1 + dist[x] \\n  \\n                    # Change parent \\n                    par[child] = x \\n  \\n                    # Push into the queue \\n                    q.append(child) \\n  \\n                # If it is already visited \\n                elif par[x] != child and par[child] != x: \\n                    ans = min(ans, dist[x] + \\n                                   dist[child] + 1) \\n  \\n    # If graph contains no cycle \\n    if ans == INT_MAX: \\n        return -1\\n  \\n    # If graph contains cycle \\n    else: \\n        return ans\\n    \\nn = int(stdin.readline())\\na = sorted([int(x) for x in stdin.readline().split()])\\n\\nif n-a.count(0) > 128:\\n    print(3)\\n\\nelse:\\n\\n    l = [[] for x in range(64)]\\n\\n    mini = False\\n    for x in a:\\n        c = 1\\n        for y in range(64):\\n            if x & c:\\n                l[y].append(x)\\n                if len(l[y]) > 2:\\n                    mini = True\\n            c <<= 1\\n\\n    if mini:\\n        print(3)\\n    else:\\n        minC = float('inf')\\n        minX = -1\\n        flatL = set()\\n        for x in l:\\n            for y in x:\\n                flatL.add(y)\\n        graph = {}\\n        for x in flatL:\\n            graph[x] = set()\\n            for y in flatL:\\n                if y != x and y&x:\\n                    graph[x].add(y)\\n        print(shortest_cycle(graph))\\n        '''for x in graph:\\n            visited = {}\\n            q = deque()\\n            q.append((x,x,0))\\n            valid = False\\n            while q and not valid:\\n                n,p,d = q.popleft()\\n                if not n in visited:\\n                    visited[n] = d\\n                    for y in graph[n]:\\n                        if y != p:\\n                            if y in visited:\\n                                valid = d+visited[y]\\n                                break\\n                            else:\\n                                q.append((y,n,d+1))\\n            if valid:\\n                minC = min(minC,valid)\\n                minX = x\\n        if minC != float('inf'):\\n            print(minC+1)\\n        else:\\n            print(-1)'''\\n        #print(minX)\\n\", \"def solve(n,a):\\n\\tB = 60\\n\\tbits = [[] for i in range(B)]\\n\\tfor i in range(n):\\n\\t\\tfor j in range(B):\\n\\t\\t\\tif a[i]&(1<<j):\\n\\t\\t\\t\\tbits[j].append(i)\\n\\n\\tadj = [[] for i in range(n)]\\n\\tfor shared in bits:\\n\\t\\tif len(shared) >= 3:\\n\\t\\t\\treturn 3\\n\\t\\telif len(shared)==2:\\n\\t\\t\\tu, v = shared\\n\\t\\t\\tadj[u].append(v)\\n\\t\\t\\tadj[v].append(u)\\n\\n\\tvis = [False for u in range(n)]\\n\\tdist = [-1 for u in range(n)]\\n\\tdef shortest_cycle(n,adj,s):\\n\\t\\tfrontier = [(s,-1)]\\n\\t\\tdist[s] = 0\\n\\t\\tptr = 0\\n\\n\\t\\twhile ptr < len(frontier):\\n\\t\\t\\tu, p = frontier[ptr]\\n\\t\\t\\tif not vis[u]:\\n\\t\\t\\t\\tvis[u] = True\\n\\t\\t\\t\\tfor v in adj[u]:\\n\\t\\t\\t\\t\\tif vis[v] and v != p:\\n\\t\\t\\t\\t\\t\\tans = dist[u]+dist[v]+1\\n\\t\\t\\t\\t\\t\\tfor u, p in frontier:\\n\\t\\t\\t\\t\\t\\t\\tvis[u] = False\\n\\t\\t\\t\\t\\t\\t\\tdist[u] = -1\\n\\t\\t\\t\\t\\t\\treturn ans\\n\\t\\t\\t\\t\\tif dist[v]==-1:\\n\\t\\t\\t\\t\\t\\tdist[v] = dist[u] + 1\\n\\t\\t\\t\\t\\t\\tfrontier.append((v,u))\\t\\n\\t\\t\\tptr += 1\\n\\n\\t\\treturn 10**18 #INF\\n\\n\\tans = min([shortest_cycle(n,adj,i) for i in range(n)])\\n\\tif ans==10**18:\\n\\t\\tans = -1\\n\\n\\treturn ans\\n\\nprint(solve(int(input()),list(map(int,input().split()))))\\n\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"4\\n3 6 28 9\\n\",\n    \"5\\n5 12 9 16 48\\n\",\n    \"4\\n1 2 4 8\\n\",\n    \"1\\n1000000000000000000\\n\",\n    \"4\\n70369817919488 281474976710657 70368744177665 281476050452480\\n\",\n    \"5\\n292733975779082240 18014398509482240 306244774661193728 4504699138998272 1099511628032\\n\",\n    \"30\\n550292684800 2149580800 4194320 576531121047601152 1125899906842628 577023702256844800 36028799166447616 584115552256 144115256795332608 1103806595072 70368811286528 278528 8830452760576 1125968626319360 2251800887427072 2097168 562958543355904 98304 9007200328482816 8590000128 2253998836940800 8800387989504 18691697672192 36028797018996736 4194308 17592186306560 537395200 9007199255265280 67125248 144117387099111424\\n\",\n    \"35\\n1099511627784 36028797019488256 576460752303423490 17592186044672 18014398510006272 274877923328 2252899325313024 16777248 4297064448 4210688 17592454479872 4505798650626048 4503599627371520 612489549322387456 2251808403619840 1074790400 562958543355904 549756862464 562949953421440 8320 9007199523176448 8796093022464 8796093030400 2199040032768 70368744181760 4295098368 288230376151842816 18084767253659648 2097184 5120 9007474132647936 1077936128 514 288230925907525632 520\\n\",\n    \"4\\n269019726702209410 974764215496813080 547920080673102148 403277729561219906\\n\",\n    \"10\\n76578820211343624 0 293297008968192 0 0 0 189152283861189120 324294649604739072 20266198324215808 0\\n\",\n    \"10\\n565299879350784 4508014854799360 0 0 0 4503635094929409 18014810826352646 306526525186934784 0 0\\n\",\n    \"10\\n193953851215184128 21533387621925025 0 0 90143735963329536 2272071319648 0 0 3378250047292544 0\\n\",\n    \"10\\n32832 0 154618822656 0 4311744512 12884901888 25769803776 16809984 137438953536 0\\n\",\n    \"100\\n0 0 0 0 0 16896 0 0 0 393216 537919488 0 0 0 147456 1310720 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2251799813685312 0 0 0 0 105553116266496 0 0 576 3377699720527872 0 0 0 0 0 0 0 0 17867063951360 0 0 1196268651020288 0 0 0 0 146028888064 0 9126805504 0 0 0 0 0 0 0 0 412316860416 0 0 0 52776558133248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\",\n    \"10\\n145135569469440 4415327043584 17247502464 72075186223972364 145241087982700608 144115188076380352 52776826568712 72198331527331844 46161896180549632 45071180914229248\\n\",\n    \"20\\n144115188142973184 18015498289545217 9077576588853760 4573976961482880 144150509954007040 4295098374 290482175998952448 290486848889815040 393228 8796118192128 4672941199360 36029898946510848 18014467230007297 4503599627379072 33817608 36028803461414914 9007199389483520 149533589782528 140737623113728 35390531567616\\n\",\n    \"20\\n0 0 554050781184 11258999068426240 141836999983104 1107296256 2251834173423616 9007199255789568 18014467228958720 4503633987108864 18155135997837312 4504149383184384 0 144123984168878080 34603008 1100585369600 8800387989504 0 144115256795332608 0\\n\",\n    \"35\\n0 288230376151711748 276824064 288230444871188480 563499709235200 550024249344 36864 68719476992 160 0 0 0 0 0 0 0 0 2199023321088 33024 0 0 0 0 0 2814749767106560 0 34359738372 576460752370532352 0 69632 2199023271936 0 2251834173423616 75497472 576460752303439872\\n\",\n    \"20\\n17592722915328 137438953728 0 549755822096 2251800350556160 70368744185856 0 2251804108652544 0 1099511628288 17592186045440 8864812498944 79164837199872 0 68719477760 1236950581248 549755814400 0 17179869456 21474836480\\n\",\n    \"20\\n8589950976 0 8858370048 1342177280 65536 2199023255808 0 1075838976 0 35184372285440 0 0 0 9009398277996544 2228224 16640 0 9042383626829824 0 0\\n\",\n    \"50\\n65600 17825792 0 288230376285929472 16392 0 0 16896 0 0 10486272 140737488355330 65537 171798691840 571746046443520 0 0 33024 0 2052 36028797155278848 36028805608898560 0 0 562967133290496 0 0 0 146028888064 281474976710660 0 288230376151711746 8388864 0 17180393472 0 0 0 68719476737 34376515584 0 299067162755072 68719478784 0 9007199255789568 140737488879616 9007199254773760 8796093022272 4294967304 17596481011712\\n\",\n    \"35\\n274877906976 65544 8796361457664 288230376151712256 549755817984 36028797019095040 33556482 167772160 1099511635968 72057594037936128 524289 288230376151711776 18014398509482000 34363932672 1099511627840 18049582881570816 34359738384 108086391056891904 68719738880 2286984185774080 1073745920 68719476746 9007203549708288 2251799813816320 402653184 16842752 2112 786432 9007474132647936 4831838208 2097153 549755814400 1090519040 8796097216512 538968064\\n\",\n    \"2\\n267367244641009858 102306300054748095\\n\",\n    \"3\\n268193483524125986 538535259923264236 584613336374288890\\n\",\n    \"5\\n269845965585325538 410993175365329220 287854792412106894 411389931291882088 384766635564718672\\n\",\n    \"6\\n270672213058376258 847222126643910769 251161541005887447 196130104757703053 970176324544067925 590438340902981666\\n\",\n    \"7\\n271498451941492386 506823119072235421 991096248449924897 204242310783332531 778958050378192987 384042493592684635 942496553147499871\\n\",\n    \"8\\n272324690824608514 943052078940751562 954402997043705450 212354512513994712 364367743652509536 401018687432130708 606631724317463342 824875323687041818\\n\",\n    \"9\\n273150934002691938 379281034514300406 694337708782710196 220466718539624190 949777432631858790 417994876976609485 494138923752268029 239707031030225806 400378607279200010\\n\",\n    \"10\\n996517375802030517 559198117598196517 624045669640274070 717274415983359970 778062383071550120 624694462096204861 661230177799843966 796915526446173606 891967553796619137 158012341402690753\\n\",\n    \"20\\n738505179452405439 393776795586588703 916949583509061480 942864257552472139 431031017016115809 547400344148658853 843639266066743033 751410499628305149 926196799677780683 288523782519361359 236550712208050515 88576472401554300 610164240954478789 948544811346543677 828908414387546137 615705220832279892 728861610641889898 318107398080960259 253426267717802880 526751456588066498\\n\",\n    \"6\\n288793326105133056 160 9077567998918656 9007199254741024 562949953421440 288300744895889408\\n\",\n    \"7\\n69206016 134250496 2149580800 2147516416 144115188142964736 146366987889541120 2251799947902976\\n\",\n    \"8\\n90071992547409920 4503599627370500 18014398510006272 72057594037928192 260 525312 4503599627632640 263168\\n\",\n    \"9\\n1161084278931456 1125899906843648 1140850688 274877972480 70643622084608 633318697598976 1073807360 35184439197696 562949953422336\\n\",\n    \"10\\n289356276058554368 4503599627378688 72057594038059008 1126037345796096 288230376152760320 4503599627370498 139264 72057594038976512 70506183131136 70368744177666\\n\",\n    \"12\\n2176 562967133290496 1073807360 17179871232 9011597301252096 4398046511168 9007267974217728 562949953421376 68719607808 35185445830656 196608 35184372088960\\n\",\n    \"14\\n72058143793741824 144115325514809344 36028797018966016 144115188080050176 135168 1125899911036928 36028797019095040 412316860416 8796093024256 1126449662656512 8864812498944 72057662757404672 274877906952 4104\\n\",\n    \"18\\n277025390592 9007199254773760 140737488371712 72057594037944320 288230378299195392 140737555464192 2199024304128 576460752303427584 201326592 1048608 137439477760 2199023779840 4128 648518346341351424 141733920768 297237575406452736 275012124672 4295000064\\n\",\n    \"25\\n4398046511360 562949957615616 17179885568 70403103916032 4398048608256 262152 5242880 281474976710657 268435968 72057594037928064 8796093022209 1048704 633318697598976 72057611217797120 171798691840 35184372089088 40960 8796093153280 163840 137438953480 281474976711168 270336 2251799815782400 2251800082120704 35184372105216\\n\",\n    \"20\\n0 0 2148564992 20301391285223424 0 2260595906773568 0 637721039077904 0 72058143793742848 0 0 0 288230376151711776 0 0 4299169792 0 9147936743096322 36046457941262624\\n\",\n    \"40\\n0 0 0 0 33554432 0 0 34359738376 0 0 0 0 0 0 0 0 16392 598169893278720 0 0 288230651029686272 0 0 0 0 0 299084343836800 0 2287052905529600 0 0 0 0 0 0 0 28217866417348608 4311744576 0 558630961281\\n\",\n    \"100\\n0 0 0 0 0 0 0 0 0 70368744472576 0 0 0 0 0 0 0 0 0 0 0 144678138029342720 0 0 0 0 0 281474977767489 0 16783360 0 0 0 0 0 288793463544086528 0 0 0 0 0 0 0 0 0 18144089473024 20 0 0 0 0 0 0 0 0 0 0 0 0 144115222435725440 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 18014419984875520 0 0 0 0 0 0 0 0 0 274878432256 0 0 0 38280596899758080 0 0 0 0 0 0 0 18014398509813764 72057594046316576 0\\n\",\n    \"100\\n0 0 0 72057598886543392 0 0 0 0 0 0 34635777 0 0 0 0 0 0 0 0 0 0 145276272354791568 0 0 0 0 0 0 0 268435456 0 0 0 299068236759040 0 0 2251800082128928 1236950844416 0 0 0 0 0 0 0 0 290482175998951428 0 0 0 2621440 0 0 0 0 0 0 0 0 0 0 0 4259840 0 0 0 0 0 4398046511108 0 0 0 0 0 0 288230376151712258 0 144258124587466816 0 0 0 0 0 0 0 0 0 0 0 0 1266637395206144 0 281818574094336 0 0 0 0 0 0 0\\n\",\n    \"150\\n0 0 0 0 0 0 0 2537672836907008 0 0 0 0 0 0 16384 0 0 0 0 34360787232 0 0 70871155232 0 0 0 0 0 0 0 0 0 0 0 2256197860262016 0 0 0 0 0 0 0 0 0 0 536872961 0 0 0 0 0 0 0 0 0 0 33619968 0 0 0 0 0 0 0 0 0 0 0 0 37189881297899520 0 18031990695526400 0 0 1099511627776 0 0 0 0 0 0 0 0 2097152 0 0 0 134217984 0 0 0 0 0 0 32768 0 0 0 0 0 0 0 0 72057594037928066 0 0 0 0 297307996227110981 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 288240271756361736 0 2097154 0 9007199254740992 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\",\n    \"10\\n70377334112256 2304 134219776 0 8724152320 70368744177920 0 0 0 0\\n\",\n    \"15\\n4296097792 1125934333693952 288230376152777216 68719509522 1126484559265792 140737756799040 18155136283049984 36028797052551170 288300753485824512 4299227392 70377334120512 18023194619281412 36028797056712960 8796160135172 619012161552\\n\",\n    \"20\\n67109888 0 0 67108896 562949953422336 0 68719480832 134217760 562949954469888 0 36028797153181696 0 36028865738440704 0 0 0 4098 1048578 0 0\\n\",\n    \"50\\n72057594038452224 0 12884901888 288230376151713792 65664 0 0 0 0 17314086912 150994944 0 18031990695526400 580964351930793984 72066390130950144 17179871232 17592186060800 0 35184372088848 4297064448 0 24 0 0 576460753377165312 8589934593 0 0 0 549755879424 562949953437696 175921860444160 553648128 4504149383184384 0 0 274877906952 0 0 0 0 0 562949953454080 1125899906842752 140738562097152 537395200 288230376153808896 1134695999864832 32769 18014673387388928\\n\",\n    \"35\\n18049582881570816 2112 0 2251799813816320 108086391056891904 0 2 0 0 0 402653184 2286984185774080 0 0 0 0 0 0 68719738880 0 72057594037936128 33556482 34359738384 0 0 1099511627840 0 167772160 18014398509482000 34363932672 8796361457664 36028797019095040 1099511635968 0 8796097216512\\n\",\n    \"20\\n137438953728 288230384741646336 17592186045440 1125908496777232 1236950581248 17592722915328 8864812498944 1099511628288 79164837199872 144115188075855876 17179869440 2251804108652544 2251800350556160 68719477760 21474836480 288230376151711748 145241087982698496 70368744185856 549755822096 549755814400\\n\",\n    \"20\\n281474976710658 1075838976 281477124194304 2147487744 35184372285440 8196 2228224 4112 9042383626829824 275012190208 1342177280 8858370048 8589950976 1125899906850816 274877906960 6 2199023255808 1125900041060352 9009398277996544 16640\\n\",\n    \"3\\n1 1 3\\n\",\n    \"7\\n5 42 80 192 160 9 22\\n\",\n    \"7\\n129 259 6 12 24 304 224\\n\",\n    \"3\\n5 5 5\\n\",\n    \"5\\n25 3 44 6 48\\n\",\n    \"5\\n49 3 6 44 24\\n\",\n    \"6\\n97 3 6 28 40 80\\n\",\n    \"5\\n25 48 3 6 44\\n\",\n    \"7\\n641 1283 2054 4108 8216 16688 32992\\n\",\n    \"7\\n259 6 12 24 304 224 129\\n\",\n    \"179\\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\\n\",\n    \"27\\n4295000064 274877906976 48389226512 33554434 68720525312 4194320 67108865 96 2056 413264846980 541065216 17179901952 8589935104 129 2147487744 68719607808 139586437120 17315009610 1280 2097408 25165824 1107296256 268435968 278528 34376515584 16388 10240\\n\"\n  ],\n  \"outputs\": [\n    \"4\",\n    \"3\",\n    \"-1\",\n    \"-1\",\n    \"4\",\n    \"5\",\n    \"30\",\n    \"35\",\n    \"3\",\n    \"3\",\n    \"3\",\n    \"3\",\n    \"7\",\n    \"15\",\n    \"10\",\n    \"20\",\n    \"15\",\n    \"17\",\n    \"6\",\n    \"10\",\n    \"11\",\n    \"17\",\n    \"-1\",\n    \"3\",\n    \"3\",\n    \"3\",\n    \"3\",\n    \"3\",\n    \"3\",\n    \"3\",\n    \"3\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"10\",\n    \"12\",\n    \"14\",\n    \"18\",\n    \"25\",\n    \"-1\",\n    \"4\",\n    \"3\",\n    \"3\",\n    \"-1\",\n    \"5\",\n    \"15\",\n    \"10\",\n    \"30\",\n    \"17\",\n    \"5\",\n    \"10\",\n    \"3\",\n    \"4\",\n    \"4\",\n    \"3\",\n    \"3\",\n    \"3\",\n    \"4\",\n    \"3\",\n    \"4\",\n    \"4\",\n    \"3\",\n    \"3\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}