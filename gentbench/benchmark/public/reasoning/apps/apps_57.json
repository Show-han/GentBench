{
    "problem": "You are an expert Python programmer, and here is your task: Dora loves adventures quite a lot. During some journey she encountered an amazing city, which is formed by $n$ streets along the Eastern direction and $m$ streets across the Southern direction. Naturally, this city has $nm$ intersections. At any intersection of $i$-th Eastern street and $j$-th Southern street there is a monumental skyscraper. Dora instantly became curious and decided to explore the heights of the city buildings.\n\nWhen Dora passes through the intersection of the $i$-th Eastern and $j$-th Southern street she examines those two streets. After Dora learns the heights of all the skyscrapers on those two streets she wonders: how one should reassign heights to the skyscrapers on those two streets, so that the maximum height would be as small as possible and the result of comparing the heights of any two skyscrapers on one street wouldn't change.\n\nFormally, on every of $nm$ intersections Dora solves an independent problem. She sees $n + m - 1$ skyscrapers and for each of them she knows its real height. Moreover, any two heights can be compared to get a result \"greater\", \"smaller\" or \"equal\". Now Dora wants to select some integer $x$ and assign every skyscraper a height from $1$ to $x$. When assigning heights, Dora wants to preserve the relative order of the skyscrapers in both streets. That is, the result of any comparison of heights of two skyscrapers in the current Eastern street shouldn't change and the result of any comparison of heights of two skyscrapers in current Southern street shouldn't change as well. Note that skyscrapers located on the Southern street are not compared with skyscrapers located on the Eastern street only. However, the skyscraper located at the streets intersection can be compared with both Southern and Eastern skyscrapers. For every intersection Dora wants to independently calculate the minimum possible $x$.\n\nFor example, if the intersection and the two streets corresponding to it look as follows: [Image] \n\nThen it is optimal to replace the heights of the skyscrapers as follows (note that all comparisons \"less\", \"equal\", \"greater\" inside the Eastern street and inside the Southern street are preserved) [Image] \n\nThe largest used number is $5$, hence the answer for this intersection would be $5$.\n\nHelp Dora to compute the answers for each intersection.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 1000$)\u00a0\u2014 the number of streets going in the Eastern direction and the number of the streets going in Southern direction.\n\nEach of the following $n$ lines contains $m$ integers $a_{i,1}$, $a_{i,2}$, ..., $a_{i,m}$ ($1 \\le a_{i,j} \\le 10^9$). The integer $a_{i,j}$, located on $j$-th position in the $i$-th line denotes the height of the skyscraper at the intersection of the $i$-th Eastern street and $j$-th Southern direction.\n\n\n-----Output-----\n\nPrint $n$ lines containing $m$ integers each. The integer $x_{i,j}$, located on $j$-th position inside the $i$-th line is an answer for the problem at the intersection of $i$-th Eastern street and $j$-th Southern street.\n\n\n-----Examples-----\nInput\n2 3\n1 2 1\n2 1 2\n\nOutput\n2 2 2 \n2 2 2 \n\nInput\n2 2\n1 2\n3 4\n\nOutput\n2 3 \n3 2 \n\n\n\n-----Note-----\n\nIn the first example, it's not possible to decrease the maximum used height for the problem at any intersection, hence we don't have to change any heights.\n\nIn the second example, the answers are as follows:   For the intersection of the first line and the first column [Image] For the intersection of the first line and the second column [Image] For the intersection of the second line and the first column [Image] For the intersection of the second line and the second column [Image]",
    "solution": "[\"import heapq\\nimport sys\\nfrom collections import defaultdict, Counter\\nfrom functools import reduce\\n\\n\\nn, m = list(map(int, input().split()))\\narr = []\\nfor _ in range(n):\\n    arr.append(list(map(int, input().split())))\\n\\nrows = []\\nfor i in range(n):\\n    row = set()\\n    for j in range(m):\\n        row.add(arr[i][j])\\n    rows.append({x: i for i, x in enumerate(sorted(row))})\\n\\ncolumns = []\\n\\nfor j in range(m):\\n    column = set()\\n    for i in range(n):\\n        column.add(arr[i][j])\\n    columns.append({x: i for i, x in enumerate(sorted(column))})\\n\\n\\ndef get_answer(i, j):\\n    el = arr[i][j]\\n    index1 = rows[i][el]\\n    index2 = columns[j][el]\\n    return max(index1, index2) + max(len(rows[i]) - index1,  len(columns[j]) - index2)\\n\\n\\nfor i in range(n):\\n    answer = []\\n    for j in range(m):\\n        answer.append(str(get_answer(i, j)))\\n    print(' '.join(answer))\\n\", \"import sys\\ninput=sys.stdin.readline\\nn, m = list(map(int, input().split()))\\nSt = [list(map(int, input().split())) for _ in range(n)]\\nppr = [sorted(list(set(s))) for s in St]\\nPR = []\\nfor i in range(n):\\n    H = dict()\\n    for j, v in enumerate(ppr[i], 1):\\n        H[v] = j\\n    PR.append([H[p] for p in St[i]] + [j])\\n\\nTSt = list(map(list, list(zip(*St))))\\nppc = [sorted(list(set(s))) for s in TSt]\\nPC = []\\nfor i in range(m):\\n    H = dict()\\n    for j, v in enumerate(ppc[i], 1):\\n        H[v] = j\\n    PC.append([H[p] for p in TSt[i]] + [j])\\n\\nfor i in range(n):\\n    pri = PR[i]\\n    prm = PR[i][-1]\\n    print(*[max(pri[j], PC[j][i]) + max(prm-pri[j], PC[j][-1]-PC[j][i]) for j in range(m)])\\n\\n\", \"def solution(heights, n, m):\\n    rows = []\\n    cols = []\\n\\n    for j in range(n):\\n        lst = set()\\n        for i in range(m):\\n            lst.add(heights[j][i])\\n        rows.append({x: i for i, x in enumerate(sorted(lst))})\\n\\n    for i in range(m):\\n        lst = set()\\n        for j in range(n):\\n            lst.add(heights[j][i])\\n        cols.append({x: i for i, x in enumerate(sorted(lst))})\\n\\n    for j in range(n):\\n        answer = []\\n        for i in range(m):\\n            val = heights[j][i]\\n            rank_row = rows[j][val]\\n            rank_col = cols[i][val]\\n            value = max(rank_row, rank_col) + max(len(rows[j]) - rank_row, len(cols[i]) - rank_col)\\n            answer.append(str(value))\\n        print(\\\" \\\".join(answer))\\n\\n\\ndef get():\\n    (n, m) = list(map(int, input().split()))\\n    data = []\\n    for j in range(n):\\n        data.append(list(map(int, input().split())))\\n\\n    solution(data, n, m)\\n\\n\\nget()\\n\", \"n, m = (int(x) for x in input().split())\\n\\nfield = [[int(x) for x in input().split()] for _ in range(n)]\\n\\nr_c___rord = []\\nr_c___cord = [[] for _ in range(n)]\\n\\nr___uniques_nr = []\\nc___uniques_nr = []\\n\\nfor r in range(n):\\n    row = field[r]\\n    srted = sorted(list(set(row)))\\n    r___uniques_nr.append(len(srted))\\n    srted = {x: i for i, x in enumerate(srted)}\\n    ords = [srted[x] for x in row]\\n    r_c___rord.append(ords)\\n\\nfor c in range(m):\\n    col = [field[i][c] for i in range(n)]\\n    srted = sorted(list(set(col)))\\n    c___uniques_nr.append(len(srted))\\n    srted = {x: i for i, x in enumerate(srted)}\\n    ords = [srted[x] for x in col]\\n    for i in range(n):\\n        r_c___cord[i].append(ords[i])\\n\\nfor r in range(n):\\n    curr = []\\n    for c in range(m):\\n        less_nr = max(r_c___rord[r][c], r_c___cord[r][c])\\n        greq_nr = max(r___uniques_nr[r] - r_c___rord[r][c], c___uniques_nr[c] - r_c___cord[r][c])\\n        curr.append(less_nr + greq_nr)\\n    print(*curr)\\n\\n\\n\\n\\n\\n\\n\", \"n, m = list(map(int, input().split()))\\ngor = []\\nver = []\\no = []\\nfor i in range(n):\\n    gor.append(list(map(int, input().split())))\\n    o.append([])\\nfor i in range(m):\\n    ver.append([])\\nfor i in range(m):\\n    for g in gor:\\n        ver[i].append(g[i])\\nver = list([sorted(list(set(x))) for x in ver])\\n\\n\\ndef f(vg, vr, o):\\n    vr1 = vr.index(o)\\n    vg1 = vg.index(o)\\n    if vr1 > vg1:\\n        return max([len(vr), len(vg) + vr1 - vg1])\\n    return max([len(vg), len(vr) + vg1 - vr1])\\n\\n\\nfor i, vg in enumerate(gor):\\n    vg1 = sorted(list(set(vg)))\\n    for j, vr in enumerate(vg):\\n        o[i].append(f(vg1, ver[j], vr))\\nfor i in o:\\n    print(' '.join(list(map(str, i))))\\n\", \"# # from collections import Counter\\n#\\n# n, m = list(map(int, input().split()))\\n# streets = []\\n# for i in range(n):\\n#     streets.append(list(map(int, input().split())))\\n#\\n# mem_rows = {}\\n# len_row = []\\n# for i in range(n):\\n#     mem_r = sorted(set(streets[i]))\\n#     mem_rows[i] = {x: i for i, x in enumerate(mem_r)}\\n#     len_row.append(len(mem_rows[i]))\\n#\\n# mem_cols = {}\\n# len_col = []\\n# for j in range(m):\\n#     mem_d = sorted(set([k[j] for k in streets]))\\n#     mem_cols[j] = {x: i for i, x in enumerate(mem_d)}\\n#     len_col.append(len(mem_cols[j]))\\n#\\n# for i in range(n):\\n#     for j in range(m):\\n#         elem = streets[i][j]\\n#         pos1, pos2 = mem_rows[i][elem], mem_cols[j][elem]\\n#         streets_ans = max(pos1, pos2) + max((len_row[i] - pos1), (len_col[j] - pos2))\\n#         print(streets_ans, end=' ')\\n#     print('\\\\n', end='')\\n\\n\\n# from collections import Counter\\n\\nn, m = list(map(int, input().split()))\\nstreets = []\\nfor i in range(n):\\n    streets.append(list(map(int, input().split())))\\n\\nmem_rows = {}\\nlen_row = []\\nfor i in range(n):\\n    mem_r = sorted(set(streets[i]))\\n    srted = {x: i for i, x in enumerate(mem_r)}\\n    ords = [srted[i] for i in streets[i]]\\n    mem_rows[i] = ords\\n    len_row.append(len(mem_r))\\n\\nmem_cols = {}\\nlen_col = []\\nfor j in range(m):\\n    col = [k[j] for k in streets]\\n    mem_d = sorted(set(col))\\n    srted = {x: i for i, x in enumerate(mem_d)}\\n    ords = [srted[i] for i in col]\\n    mem_cols[j] = ords\\n    len_col.append(len(mem_d))\\n\\n\\nfor i in range(n):\\n    prt = []\\n    for j in range(m):\\n        elem = streets[i][j]\\n        pos1, pos2 = mem_rows[i][j], mem_cols[j][i]\\n        streets_ans = max(pos1, pos2) + max((len_row[i] - pos1), (len_col[j] - pos2))\\n        prt.append(streets_ans)\\n    print(*prt)\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"2 3\\n1 2 1\\n2 1 2\\n\",\n    \"2 2\\n1 2\\n3 4\\n\",\n    \"1 1\\n1543\\n\",\n    \"2 1\\n179\\n1329\\n\",\n    \"1 2\\n66 699\\n\",\n    \"2 2\\n2 2\\n2 2\\n\",\n    \"2 2\\n1 1000000000\\n1 1000000000\\n\",\n    \"1 4\\n1 5 4 3\\n\",\n    \"3 1\\n1\\n7\\n9\\n\",\n    \"2 1\\n179\\n179\\n\",\n    \"1 2\\n57 57\\n\",\n    \"2 2\\n1 2\\n3 1\\n\",\n    \"2 2\\n1 1\\n1 2\\n\",\n    \"2 2\\n17 56\\n12 8\\n\",\n    \"2 2\\n351 910\\n958 555\\n\",\n    \"2 2\\n955933963 48131784\\n834485410 137462264\\n\",\n    \"2 2\\n1 2\\n2 1\\n\",\n    \"2 2\\n1 2\\n2 1\\n\",\n    \"2 2\\n1 1\\n1 1\\n\",\n    \"2 2\\n1 1\\n1 2\\n\",\n    \"1 100\\n855 693 601 329 311 798 783 920 504 868 521 358 367 467 623 767 481 635 855 608 157 95 273 261 110 713 948 897 546 476 855 337 93 321 648 441 215 979 505 69 858 99 877 337 237 116 824 98 955 192 773 99 485 385 861 849 772 993 470 215 792 635 986 515 84 7 476 831 903 74 79 545 308 675 342 947 403 952 237 731 934 607 207 556 677 701 861 844 690 179 310 772 182 771 473 11 26 7 796 556\\n\",\n    \"5 5\\n1 2 10 1 1\\n2 1 20 2 1\\n11 13 14 15 16\\n2 5 10 3 7\\n1 1 1 1 1\\n\",\n    \"4 3\\n1 2 3\\n10 11 4\\n9 12 5\\n8 7 6\\n\"\n  ],\n  \"outputs\": [\n    \"2 2 2 \\n2 2 2 \\n\",\n    \"2 3 \\n3 2 \\n\",\n    \"1 \\n\",\n    \"2 \\n2 \\n\",\n    \"2 2 \\n\",\n    \"1 1 \\n1 1 \\n\",\n    \"2 2 \\n2 2 \\n\",\n    \"4 4 4 4 \\n\",\n    \"3 \\n3 \\n3 \\n\",\n    \"1 \\n1 \\n\",\n    \"1 1 \\n\",\n    \"2 2 \\n2 2 \\n\",\n    \"1 2 \\n2 2 \\n\",\n    \"3 2 \\n3 2 \\n\",\n    \"2 2 \\n2 2 \\n\",\n    \"2 2 \\n3 3 \\n\",\n    \"2 2 \\n2 2 \\n\",\n    \"2 2 \\n2 2 \\n\",\n    \"1 1 \\n1 1 \\n\",\n    \"1 2 \\n2 2 \\n\",\n    \"88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 88 \\n\",\n    \"3 4 5 4 3 \\n3 4 4 4 3 \\n7 7 5 5 5 \\n6 5 7 6 5 \\n3 4 4 4 3 \\n\",\n    \"4 5 6 \\n5 4 4 \\n4 4 5 \\n5 4 6 \\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}