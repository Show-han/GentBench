{
    "problem": "You are an expert Python programmer, and here is your task: Country of Metropolia is holding Olympiad of Metrpolises soon. It mean that all jury members of the olympiad should meet together in Metropolis (the capital of the country) for the problem preparation process.\n\nThere are n + 1 cities consecutively numbered from 0 to n. City 0 is Metropolis that is the meeting point for all jury members. For each city from 1 to n there is exactly one jury member living there. Olympiad preparation is a long and demanding process that requires k days of work. For all of these k days each of the n jury members should be present in Metropolis to be able to work on problems.\n\nYou know the flight schedule in the country (jury members consider themselves important enough to only use flights for transportation). All flights in Metropolia are either going to Metropolis or out of Metropolis. There are no night flights in Metropolia, or in the other words, plane always takes off at the same day it arrives. On his arrival day and departure day jury member is not able to discuss the olympiad. All flights in Megapolia depart and arrive at the same day.\n\nGather everybody for k days in the capital is a hard objective, doing that while spending the minimum possible money is even harder. Nevertheless, your task is to arrange the cheapest way to bring all of the jury members to Metrpolis, so that they can work together for k days and then send them back to their home cities. Cost of the arrangement is defined as a total cost of tickets for all used flights. It is allowed for jury member to stay in Metropolis for more than k days.\n\n\n-----Input-----\n\nThe first line of input contains three integers n, m and k (1 \u2264 n \u2264 10^5, 0 \u2264 m \u2264 10^5, 1 \u2264 k \u2264 10^6). \n\nThe i-th of the following m lines contains the description of the i-th flight defined by four integers d_{i}, f_{i}, t_{i} and c_{i} (1 \u2264 d_{i} \u2264 10^6, 0 \u2264 f_{i} \u2264 n, 0 \u2264 t_{i} \u2264 n, 1 \u2264 c_{i} \u2264 10^6, exactly one of f_{i} and t_{i} equals zero), the day of departure (and arrival), the departure city, the arrival city and the ticket cost.\n\n\n-----Output-----\n\nOutput the only integer that is the minimum cost of gathering all jury members in city 0 for k days and then sending them back to their home cities.\n\nIf it is impossible to gather everybody in Metropolis for k days and then send them back to their home cities, output \"-1\" (without the quotes).\n\n\n-----Examples-----\nInput\n2 6 5\n1 1 0 5000\n3 2 0 5500\n2 2 0 6000\n15 0 2 9000\n9 0 1 7000\n8 0 2 6500\n\nOutput\n24500\n\nInput\n2 4 5\n1 2 0 5000\n2 1 0 4500\n2 1 0 3000\n8 0 1 6000\n\nOutput\n-1\n\n\n\n-----Note-----\n\nThe optimal way to gather everybody in Metropolis in the first sample test is to use flights that take place on days 1, 2, 8 and 9. The only alternative option is to send jury member from second city back home on day 15, that would cost 2500 more.\n\nIn the second sample it is impossible to send jury member from city 2 back home from Metropolis.",
    "solution": "[\"N,M,K = map(int,input().split())\\n\\nINF = 10**6+1\\nfrom collections import defaultdict\\n\\nincoming = defaultdict(list)\\noutgoing = defaultdict(list)\\n\\nfor _ in range(M):\\n  d,f,t,c = map(int,input().split())\\n  if t == 0:\\n    incoming[d].append((c,f-1))\\n  if f == 0:\\n    outgoing[d].append((c,t-1))\\n\\nincoming_dates = sorted(incoming.keys())\\noutgoing_dates = sorted(outgoing.keys(),reverse=True)\\n\\n\\n\\nLi = []\\nmark = [False]*N\\ncnt = 0\\ncosts = [0]*N\\ntotal_cost = 0\\n\\nfor d in incoming_dates:\\n  for c,x in incoming[d]:\\n    if mark[x]:\\n      if costs[x] > c:\\n        total_cost += c-costs[x]\\n        costs[x] = c\\n    else:\\n      mark[x] = True\\n      cnt += 1\\n      costs[x] = c\\n      total_cost += c\\n\\n  if cnt == N:\\n    Li.append((d,total_cost))\\n\\n\\nLo = []\\nmark = [False]*N\\ncnt = 0\\ncosts = [0]*N\\ntotal_cost = 0\\n\\nfor d in outgoing_dates:\\n  for c,x in outgoing[d]:\\n    if mark[x]:\\n      if costs[x] > c:\\n        total_cost += c-costs[x]\\n        costs[x] = c\\n    else:\\n      mark[x] = True\\n      cnt += 1\\n      costs[x] = c\\n      total_cost += c\\n\\n  if cnt == N:\\n    Lo.append((d,total_cost))\\n\\nLo.reverse()\\n\\n\\nif not Li or not Lo:\\n  print(-1)\\n  return\\n\\n\\n# print(Li,Lo)\\n\\nfrom bisect import bisect\\n\\nbest = float('inf')\\n\\nfor d,c in Li:\\n  i = bisect(Lo,(d+K+1,0))\\n  if i >= len(Lo):\\n    break\\n  else:\\n    best = min(best,c+Lo[i][1])\\n\\nif best == float('inf'):\\n  print(-1)\\nelse:\\n  print(best)\", \"def main():\\n    n, m, k = list(map(int, input().split()))\\n    ff, tt = [], []\\n    for _ in range(m):\\n        d, f, t, c = list(map(int, input().split()))\\n        if f:\\n            ff.append((d, f, c))\\n        else:\\n            tt.append((-d, t, c))\\n    for ft in ff, tt:\\n        cnt, costs = n, [1000001] * (n + 1)\\n        ft.sort(reverse=True)\\n        while ft:\\n            day, city, cost = ft.pop()\\n            oldcost = costs[city]\\n            if oldcost > cost:\\n                costs[city] = cost\\n                if oldcost == 1000001:\\n                    cnt -= 1\\n                    if not cnt:\\n                        break\\n        else:\\n            print(-1)\\n            return\\n        total = sum(costs) - 1000001\\n        l = [(day, total)]\\n        while ft:\\n            day, city, cost = ft.pop()\\n            oldcost = costs[city]\\n            if oldcost > cost:\\n                total -= oldcost - cost\\n                costs[city] = cost\\n                if l[-1][0] == day:\\n                    l[-1] = (day, total)\\n                else:\\n                    l.append((day, total))\\n        if ft is ff:\\n            ff = l\\n        else:\\n            tt = l\\n    l, k = [], -k\\n    d, c = tt.pop()\\n    try:\\n        for day, cost in ff:\\n            while d + day >= k:\\n                d, c = tt.pop()\\n            if d + day < k:\\n                l.append(c + cost)\\n    except IndexError:\\n        pass\\n    print(min(l, default=-1))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"g = lambda: map(int, input().split())\\nn, m, k = g()\\nF, T = [], []\\ne = int(3e11)\\n\\nfor i in range(m):\\n    d, f, t, c = g()\\n    if f: F.append((d, f, c))\\n    else: T.append((-d, t, c))\\n\\nfor p in [F, T]:\\n    C = [e] * (n + 1)\\n    s = n * e\\n    q = []\\n\\n    p.sort()\\n    for d, t, c in p:\\n        if C[t] > c:\\n            s += c - C[t]\\n            C[t] = c\\n            if s < e: q.append((s, d))\\n    p.clear()\\n    p += q\\n\\ns, t = e, (0, 0)\\nfor f in F:\\n    while f:\\n        if t[1] + f[1] + k < 0: s = min(s, f[0] + t[0])\\n        elif T:\\n            t = T.pop()\\n            continue\\n        f = 0\\n\\nprint(s if s < e else -1)\", \"R=lambda :list(map(int,input().split()))\\nn,m,k=R()\\nF,T=[],[]\\nans=int(1e12)\\nfor i in range(m):\\n    d,f,t,c=R()\\n    if f:F.append((d,f,c))\\n    else:T.append((-d,t,c))\\nfor p in [F,T]:\\n    cost=[ans]*(n+1)\\n    s=n*ans\\n    q=[]\\n    p.sort()\\n    for d,t,c in p:\\n        #print(p)\\n        if c<cost[t]:\\n            #print(c,cost[t])\\n            s+=c-cost[t]\\n            #print(s)\\n            cost[t]=c\\n            if s<ans:\\n                q.append((s,d))\\n    p.clear()\\n    #print(q)\\n    p+=q\\n    #print(p)\\ns,t=ans,(0,0)\\n#print(F,T)\\nfor f in F:\\n    while  f:\\n        if f[1]+t[1]+k<0:s=min(s,f[0]+t[0])\\n        elif T:\\n            #print(T)\\n            t=T.pop()\\n            #print(T)\\n           # print(t)\\n            continue\\n        #print(f)\\n        f=0\\n        #print(f)\\nprint(s if s<ans else -1)\\n\", \"R=lambda :list(map(int,input().split()))\\n\\nn,m,k=R()\\n\\nF,T=[],[]\\n\\nans=int(1e12)\\n\\nfor i in range(m):\\n\\n    d,f,t,c=R()\\n\\n    if f:F.append((d,f,c))\\n\\n    else:T.append((-d,t,c))\\n\\nfor p in [F,T]:\\n\\n    cost=[ans]*(n+1)\\n\\n    s=n*ans\\n\\n    q=[]\\n\\n    p.sort()\\n\\n    for d,t,c in p:\\n\\n        #print(p)\\n\\n        if c<cost[t]:\\n\\n            #print(c,cost[t])\\n\\n            s+=c-cost[t]\\n\\n            #print(s)\\n\\n            cost[t]=c\\n\\n            if s<ans:\\n\\n                q.append((s,d))\\n\\n    p.clear()\\n\\n    #print(q)\\n\\n    p+=q\\n\\n    #print(p)\\n\\ns,t=ans,(0,0)\\n\\n#print(F,T)\\n\\nfor f in F:\\n\\n    while  f:\\n\\n        if f[1]+t[1]+k<0:s=min(s,f[0]+t[0])\\n\\n        elif T:\\n\\n            #print(T)\\n\\n            t=T.pop()\\n\\n            #print(T)\\n\\n           # print(t)\\n\\n            continue\\n\\n        #print(f)\\n\\n        f=0\\n\\n        #print(f)\\n\\nprint(s if s<ans else -1)\\n\\n\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"g = lambda: map(int, input().split())\\nn, m, k = g()\\nF, T = [], []\\ne = int(3e11)\\n\\nfor i in range(m):\\n    d, f, t, c = g()\\n    if f: F.append((d, f, c))\\n    else: T.append((-d, t, c))\\n\\nfor p in [F, T]:\\n    C = [e] * (n + 1)\\n    s = n * e\\n    q = []\\n\\n    p.sort()\\n    for d, t, c in p:\\n        if C[t] > c:\\n            s += c - C[t]\\n            C[t] = c\\n            if s < e: q.append((s, d))\\n    p.clear()\\n    p += q\\n\\ns, t = e, (0, 0)\\nfor f in F:\\n    while f:\\n        if t[1] + f[1] + k < 0: s = min(s, f[0] + t[0])\\n        elif T:\\n            t = T.pop()\\n            continue\\n        f = 0\\n\\nprint(s if s < e else -1)\", \"from bisect import *\\nfrom sys import *\\nn,m,k=[int(i) for i in input().split()]\\npln=[]\\nif m==0:\\n    print(-1)\\n    return\\nfor i in range(m):\\n    pln.append([int(i) for i in input().split()])\\npln.sort()\\n\\ngrp=[[pln[0]]];gt=0;\\nfor i in range(1,m):\\n    if pln[i][0]!=pln[i-1][0]:\\n        gt=gt+1\\n        grp.append([])\\n    grp[gt].append(pln[i])\\nxx=[]\\nfor i in range(len(grp)):\\n    xx.append(grp[i][0][0])\\n#print('grp',grp)\\n#print('xx',xx)\\n\\nfrom math import inf\\npre=[0]*len(xx)\\nct=0 \\nmincost=[inf]*(n+1);sumcost=inf\\nfor i,x in enumerate(grp):\\n    for di,fi,ti,ci in x:\\n        if ti==0:\\n            if mincost[fi]==inf:\\n                ct+=1\\n            if sumcost==inf:\\n                mincost[fi]=min(mincost[fi],ci)\\n            else:\\n                sumcost=sumcost-mincost[fi]\\n                mincost[fi]=min(mincost[fi],ci)\\n                sumcost=sumcost+mincost[fi]\\n    if ct==n and sumcost==inf:\\n        sumcost=sum(mincost[1:])\\n    pre[i]=sumcost\\n#print(pre)\\n\\nsa=[0]*len(xx)\\nct=0 \\nmincost=[inf]*(n+1);sumcost=inf\\ngrp.reverse()\\nfor i,x in enumerate(grp):\\n    for di,fi,ti,ci in x:\\n        if fi==0:\\n            if mincost[ti]==inf:\\n                ct+=1\\n            if sumcost==inf:\\n                mincost[ti]=min(mincost[ti],ci)\\n            else:\\n                sumcost=sumcost-mincost[ti]\\n                mincost[ti]=min(mincost[ti],ci)\\n                sumcost=sumcost+mincost[ti]\\n    if ct==n and sumcost==inf:\\n        sumcost=sum(mincost[1:])\\n    sa[i]=sumcost\\nsa.reverse()\\n#print(sa)\\n\\nans=inf\\nfor l,xxi in enumerate(xx):\\n    r=bisect_right(xx,xxi+k)\\n    ansl=pre[l]\\n    ansr= inf if r==len(xx) else sa[r]\\n    ans=min(ans,ansl+ansr)\\nprint(ans) if ans!=inf else print(-1)\\n        \\n            \\n\"]",
    "test": "{\n  \"inputs\": [\n    \"2 6 5\\n1 1 0 5000\\n3 2 0 5500\\n2 2 0 6000\\n15 0 2 9000\\n9 0 1 7000\\n8 0 2 6500\\n\",\n    \"2 4 5\\n1 2 0 5000\\n2 1 0 4500\\n2 1 0 3000\\n8 0 1 6000\\n\",\n    \"2 5 5\\n1 1 0 1\\n2 2 0 100\\n3 2 0 10\\n9 0 1 1000\\n10 0 2 10000\\n\",\n    \"2 4 5\\n1 1 0 1\\n2 2 0 10\\n8 0 1 100\\n9 0 2 1000\\n\",\n    \"1 2 1\\n10 1 0 16\\n20 0 1 7\\n\",\n    \"1 2 10\\n20 0 1 36\\n10 1 0 28\\n\",\n    \"1 2 9\\n20 0 1 97\\n10 1 0 47\\n\",\n    \"2 4 1\\n20 0 1 72\\n21 0 2 94\\n9 2 0 43\\n10 1 0 91\\n\",\n    \"2 4 10\\n20 0 1 7\\n9 2 0 32\\n10 1 0 27\\n21 0 2 19\\n\",\n    \"2 4 9\\n10 1 0 22\\n21 0 2 92\\n9 2 0 29\\n20 0 1 37\\n\",\n    \"3 6 1\\n10 1 0 62\\n8 3 0 83\\n20 0 1 28\\n22 0 3 61\\n21 0 2 61\\n9 2 0 75\\n\",\n    \"3 6 10\\n22 0 3 71\\n20 0 1 57\\n8 3 0 42\\n10 1 0 26\\n9 2 0 35\\n21 0 2 84\\n\",\n    \"3 6 9\\n10 1 0 93\\n20 0 1 26\\n8 3 0 51\\n22 0 3 90\\n21 0 2 78\\n9 2 0 65\\n\",\n    \"4 8 1\\n9 2 0 3\\n22 0 3 100\\n20 0 1 40\\n10 1 0 37\\n23 0 4 49\\n7 4 0 53\\n21 0 2 94\\n8 3 0 97\\n\",\n    \"4 8 10\\n8 3 0 65\\n21 0 2 75\\n7 4 0 7\\n23 0 4 38\\n20 0 1 27\\n10 1 0 33\\n22 0 3 91\\n9 2 0 27\\n\",\n    \"4 8 9\\n8 3 0 61\\n9 2 0 94\\n23 0 4 18\\n21 0 2 19\\n20 0 1 52\\n10 1 0 68\\n22 0 3 5\\n7 4 0 59\\n\",\n    \"5 10 1\\n24 0 5 61\\n22 0 3 36\\n8 3 0 7\\n21 0 2 20\\n6 5 0 23\\n20 0 1 28\\n23 0 4 18\\n9 2 0 40\\n7 4 0 87\\n10 1 0 8\\n\",\n    \"5 10 10\\n24 0 5 64\\n23 0 4 17\\n20 0 1 91\\n9 2 0 35\\n21 0 2 4\\n22 0 3 51\\n6 5 0 69\\n7 4 0 46\\n8 3 0 92\\n10 1 0 36\\n\",\n    \"5 10 9\\n22 0 3 13\\n9 2 0 30\\n24 0 5 42\\n21 0 2 33\\n23 0 4 36\\n20 0 1 57\\n10 1 0 39\\n8 3 0 68\\n7 4 0 85\\n6 5 0 35\\n\",\n    \"1 10 1\\n278 1 0 4\\n208 1 0 4\\n102 0 1 9\\n499 0 1 7\\n159 0 1 8\\n218 1 0 6\\n655 0 1 5\\n532 1 0 6\\n318 0 1 6\\n304 1 0 7\\n\",\n    \"2 10 1\\n5 0 2 5\\n52 2 0 9\\n627 0 2 6\\n75 0 1 6\\n642 0 1 8\\n543 0 2 7\\n273 1 0 2\\n737 2 0 4\\n576 0 1 7\\n959 0 2 5\\n\",\n    \"3 10 1\\n48 2 0 9\\n98 0 2 5\\n43 0 1 8\\n267 0 1 7\\n394 3 0 7\\n612 0 3 9\\n502 2 0 6\\n36 0 2 9\\n602 0 1 3\\n112 1 0 6\\n\",\n    \"4 10 1\\n988 0 1 1\\n507 1 0 9\\n798 1 0 9\\n246 0 3 7\\n242 1 0 8\\n574 4 0 7\\n458 0 4 9\\n330 0 2 9\\n303 2 0 8\\n293 0 3 9\\n\",\n    \"5 10 1\\n132 0 4 7\\n803 0 2 8\\n280 3 0 5\\n175 4 0 6\\n196 1 0 7\\n801 0 4 6\\n320 0 5 7\\n221 0 4 6\\n446 4 0 8\\n699 0 5 9\\n\",\n    \"6 10 1\\n845 0 4 9\\n47 0 4 8\\n762 0 2 8\\n212 6 0 6\\n416 0 5 9\\n112 5 0 9\\n897 0 6 9\\n541 0 4 5\\n799 0 6 7\\n252 2 0 9\\n\",\n    \"7 10 1\\n369 6 0 9\\n86 7 0 9\\n696 0 4 8\\n953 6 0 7\\n280 4 0 9\\n244 0 2 9\\n645 6 0 8\\n598 7 0 6\\n598 0 7 8\\n358 0 4 6\\n\",\n    \"8 10 1\\n196 2 0 9\\n67 2 0 9\\n372 3 0 6\\n886 6 0 6\\n943 0 3 8\\n430 3 0 6\\n548 0 4 9\\n522 0 3 8\\n1 4 0 3\\n279 4 0 8\\n\",\n    \"9 10 1\\n531 8 0 5\\n392 2 0 9\\n627 8 0 9\\n363 5 0 9\\n592 0 5 3\\n483 0 6 7\\n104 3 0 8\\n97 8 0 9\\n591 0 7 9\\n897 0 6 7\\n\",\n    \"10 10 1\\n351 0 3 7\\n214 0 9 9\\n606 0 7 8\\n688 0 9 3\\n188 3 0 9\\n994 0 1 7\\n372 5 0 8\\n957 0 3 6\\n458 8 0 7\\n379 0 4 7\\n\",\n    \"1 2 1\\n5 0 1 91\\n1 1 0 87\\n\",\n    \"2 4 1\\n1 1 0 88\\n5 2 0 88\\n3 0 1 46\\n9 0 2 63\\n\",\n    \"3 6 1\\n19 0 3 80\\n11 0 2 32\\n8 2 0 31\\n4 0 1 45\\n1 1 0 63\\n15 3 0 76\\n\",\n    \"1 0 1\\n\",\n    \"5 0 1\\n\"\n  ],\n  \"outputs\": [\n    \"24500\\n\",\n    \"-1\\n\",\n    \"11011\\n\",\n    \"1111\\n\",\n    \"23\\n\",\n    \"-1\\n\",\n    \"144\\n\",\n    \"300\\n\",\n    \"-1\\n\",\n    \"180\\n\",\n    \"370\\n\",\n    \"-1\\n\",\n    \"403\\n\",\n    \"473\\n\",\n    \"-1\\n\",\n    \"376\\n\",\n    \"328\\n\",\n    \"-1\\n\",\n    \"438\\n\",\n    \"9\\n\",\n    \"23\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"178\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}