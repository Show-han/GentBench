{
    "problem": "You are an expert Python programmer, and here is your task: Two participants are each given a pair of distinct numbers from 1 to 9 such that there's exactly one number that is present in both pairs. They want to figure out the number that matches by using a communication channel you have access to without revealing it to you.\n\nBoth participants communicated to each other a set of pairs of numbers, that includes the pair given to them. Each pair in the communicated sets comprises two different numbers.\n\nDetermine if you can with certainty deduce the common number, or if you can determine with certainty that both participants know the number but you do not.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 12$) \u2014 the number of pairs the first participant communicated to the second and vice versa.\n\nThe second line contains $n$ pairs of integers, each between $1$ and $9$, \u2014 pairs of numbers communicated from first participant to the second.\n\nThe third line contains $m$ pairs of integers, each between $1$ and $9$, \u2014 pairs of numbers communicated from the second participant to the first.\n\nAll pairs within each set are distinct (in particular, if there is a pair $(1,2)$, there will be no pair $(2,1)$ within the same set), and no pair contains the same number twice.\n\nIt is guaranteed that the two sets do not contradict the statements, in other words, there is pair from the first set and a pair from the second set that share exactly one number.\n\n\n-----Output-----\n\nIf you can deduce the shared number with certainty, print that number.\n\nIf you can with certainty deduce that both participants know the shared number, but you do not know it, print $0$.\n\nOtherwise print $-1$.\n\n\n-----Examples-----\nInput\n2 2\n1 2 3 4\n1 5 3 4\n\nOutput\n1\n\nInput\n2 2\n1 2 3 4\n1 5 6 4\n\nOutput\n0\n\nInput\n2 3\n1 2 4 5\n1 2 1 3 2 3\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first example the first participant communicated pairs $(1,2)$ and $(3,4)$, and the second communicated $(1,5)$, $(3,4)$. Since we know that the actual pairs they received share exactly one number, it can't be that they both have $(3,4)$. Thus, the first participant has $(1,2)$ and the second has $(1,5)$, and at this point you already know the shared number is $1$.\n\nIn the second example either the first participant has $(1,2)$ and the second has $(1,5)$, or the first has $(3,4)$ and the second has $(6,4)$. In the first case both of them know the shared number is $1$, in the second case both of them know the shared number is $4$. You don't have enough information to tell $1$ and $4$ apart.\n\nIn the third case if the first participant was given $(1,2)$, they don't know what the shared number is, since from their perspective the second participant might have been given either $(1,3)$, in which case the shared number is $1$, or $(2,3)$, in which case the shared number is $2$. While the second participant does know the number with certainty, neither you nor the first participant do, so the output is $-1$.",
    "solution": "[\"\\nimport sys\\n#sys.stdin=open(\\\"data.txt\\\")\\ninput=sys.stdin.readline\\n\\nn,m=list(map(int,input().split()))\\n\\npossible1=[set() for _ in range(200)]\\npossible2=[set() for _ in range(200)]\\nweird=[0]*15\\n\\np1=list(map(int,input().split()))\\np2=list(map(int,input().split()))\\n\\nfor i in range(n):\\n    for j in range(m):\\n        a=sorted(p1[i*2:i*2+2])\\n        b=sorted(p2[j*2:j*2+2])\\n        if a==b: continue\\n        got=-1\\n        if a[0] in b: got=a[0]\\n        if a[1] in b: got=a[1]\\n        if got==-1: continue\\n        weird[got]=1\\n        possible1[a[0]*11+a[1]].add(got)\\n        possible2[b[0]*11+b[1]].add(got)\\n\\nif sum(weird)==1:\\n    print(weird.index(1))\\nelif max(len(i) for i in possible1)==1 and max(len(i) for i in possible2)==1:\\n    print(0)\\nelse:\\n    print(-1)\\n\", \"n, m = list(map(int, input().split()))\\np1 = list(map(int, input().split()))\\np2 = list(map(int, input().split()))\\ncand = set()\\ncc = [set() for i in range(n)]\\ndd = [set() for i in range(m)]\\nfor i in range(n):\\n    for j in range(m):\\n        a, b = p1[2 * i], p1[2 * i + 1]\\n        c, d = p2[2 * j], p2[2 * j + 1]\\n        if a not in (c, d) and b not in (c, d):\\n            continue\\n        if a in (c, d) and b in (c, d):\\n            continue\\n        if a in (c, d):\\n            kandidat = a\\n        else:\\n            kandidat = b\\n        cand.add(kandidat)\\n        cc[i].add(kandidat)\\n        dd[j].add(kandidat)\\nif len(cand) == 1:\\n    print(cand.pop())\\nelif max(len(cc[i]) for i in range(n)) <= 1 and\\\\\\n        max(len(dd[i]) for i in range(m)) <= 1:\\n    print(0)\\nelse:\\n    print(-1)\\n\", \"import sys\\nna, nb = list(map(int, sys.stdin.readline().split()))\\n\\nal, bl = list(map(int, sys.stdin.readline().split())), list(map(int, sys.stdin.readline().split()))\\n\\na = [set((al[2*i], al[2*i+1])) for i in range(na)]\\nb = [set((bl[2*i], bl[2*i+1])) for i in range(nb)]\\n\\naposs, bposs = set(), set()\\npossible_shared = set()\\ni_know_a_knows, i_know_b_knows = True, True\\n\\nfor ahas in a:\\n    bposshere = set()\\n    for bp in b:\\n        if len(ahas & bp) == 1:\\n            bposshere |= ahas & bp\\n    possible_shared |= bposshere\\n\\n    if len(bposshere) == 2:\\n        i_know_a_knows = False\\n\\nfor bhas in b:\\n    aposshere = set()\\n    for ap in a:\\n        if len(bhas & ap) == 1:\\n            aposshere |= bhas & ap\\n    possible_shared |= aposshere\\n\\n    if len(aposshere) == 2:\\n        i_know_b_knows = False\\n\\n\\nif len(possible_shared) == 1:\\n    print(list(possible_shared)[0])\\nelif i_know_a_knows and i_know_b_knows:\\n    print(0)\\nelse:\\n    print(-1)\\n\", \"n, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\ncan0 = set()\\ncan1 = [set() for i in range(n)]\\ncan2 = [set() for i in range(m)]\\n\\nfor i in range(n):\\n    for j in range(m):\\n        x1 = a[i * 2]\\n        x2 = a[i * 2 + 1]\\n        y1 = b[j * 2]\\n        y2 = b[j * 2 + 1]\\n        if x1 > x2: x1, x2 = x2, x1\\n        if y1 > y2: y1, y2 = y2, y1\\n        if x1 == y1 and x2 == y2: continue\\n        if x1 == y1:\\n            can1[i].add(y1)\\n            can2[j].add(y1)\\n            can0.add(y1)\\n        if x2 == y1:\\n            can1[i].add(y1)\\n            can2[j].add(y1)\\n            can0.add(y1)\\n        if x1 == y2:\\n            can1[i].add(y2)\\n            can2[j].add(y2)\\n            can0.add(y2)\\n        if x2 == y2:\\n            can1[i].add(y2)\\n            can2[j].add(y2)\\n            can0.add(y2)\\nif len(can0) == 1:\\n    print(min(can0))\\nelse:\\n    ok = True\\n    for i in can1:\\n        if len(i) > 1:\\n            ok = False\\n    for i in can2:\\n        if len(i) > 1:\\n            ok = False\\n    if ok: print(0)\\n    else: print(-1)\\n\", \"def readpts():\\n\\tip = list(map(int, input().split()))\\n\\treturn [(min(ip[i], ip[i+1]), max(ip[i], ip[i+1])) for i in range(0,len(ip),2)]\\n\\nN, M = list(map(int, input().split()))\\npts1 = readpts()\\npts2 = readpts()\\n#print(pts1)\\n#print(pts2)\\n\\ndef psb(a, b):\\n\\tif a == b: return False\\n\\treturn any(i in b for i in a)\\n\\ndef sb(a, b):\\n\\tfor i in a:\\n\\t\\tif i in b:\\n\\t\\t\\treturn i\\n\\treturn -1 # should not happen\\n\\ndef ipsv(pts1, pts2):\\n\\tans = False\\n\\tfor p1 in pts1:\\n\\t\\tgsb = set()\\n\\t\\tfor p2 in pts2:\\n\\t\\t\\tif psb(p1, p2):\\n\\t\\t\\t\\tgsb.add(sb(p1, p2))\\n\\t\\tif len(gsb) > 1: return False\\n\\t\\tif len(gsb) == 1: ans = True\\n\\treturn ans\\n\\ndef sv():\\n\\tgsb = set()\\n\\tfor p1 in pts1:\\n\\t\\tfor p2 in pts2:\\n\\t\\t\\tif psb(p1, p2):\\n\\t\\t\\t\\tgsb.add(sb(p1, p2))\\n\\tif len(gsb) == 0: return -1\\n\\tif len(gsb) == 1: return list(gsb)[0]\\n\\tif ipsv(pts1, pts2) and ipsv(pts2, pts1): return 0\\n\\treturn -1\\n\\nprint(sv())\\n\", \"from sys import stdin, stdout\\n\\n\\nn, m = map(int, stdin.readline().split())\\np1, p2 = [], []\\n\\nchallengers = list(map(int, stdin.readline().split()))\\nfor i in range(n):\\n    p1.append((challengers[i * 2], challengers[i * 2 + 1]))\\n    \\nchallengers = list(map(int, stdin.readline().split()))\\nfor i in range(m):\\n    p2.append((challengers[i * 2], challengers[i * 2 + 1]))    \\n\\n\\nlabel = -1\\nX = 10\\ncount = [0 for i in range(X)]\\n\\nfor x in range(1, X):\\n    for i in range(n):\\n        if x not in p1[i]:\\n            continue\\n        \\n        for j in range(m):\\n            if x not in p2[j]:\\n                continue\\n            \\n            if len(set(p1[i]) & set(p2[j])) == 1:\\n                count[x] += 1\\n                c = x\\n\\nif count.count(0) == 9:\\n    stdout.write(str(c))\\nelse:\\n    label = 1\\n    ind = 0\\n    \\n    for p11 in p1:\\n        cur = set()\\n        for p22 in p2:\\n            if len(set(p11) & set(p22)) == 1:\\n                cur |= set(p11) & set(p22)\\n        \\n        if len(cur) == 2:\\n            label = 0\\n        \\n    \\n    for p22 in p2:\\n        cur = set()\\n        for p11 in p1:\\n            if len(set(p11) & set(p22)) == 1:\\n                cur |= set(p11) & set(p22)\\n        \\n        if len(cur) == 2:\\n            label = 0\\n    \\n    \\n    if label == 1:\\n        stdout.write('0')\\n    else:\\n        stdout.write('-1')\", \"#     Codeforces Round #488 by NEAR (Div. 2)\\nimport collections\\nfrom functools import cmp_to_key\\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\\n\\nimport sys\\ndef getIntList():\\n    return list(map(int, input().split()))    \\n\\nimport bisect \\n\\ndef makePair(z):\\n    return  [(z[i], z[i+1]) for i in range(0,len(z),2) ]\\n            \\nN,M =  getIntList()\\np1 = getIntList()\\np1 = makePair(p1)\\np1 = list(map( set, p1))\\np2 = getIntList()\\np2 = makePair(p2)\\np2 = list(map( set, p2))\\n#print(p1)\\n\\nres = set()\\nfor x in p1:\\n    for y in p2:\\n        z = x&y\\n        if len(z) ==2 or len(z) ==0:continue\\n        res = res | z\\nif len(res) == 1:\\n    print(res.pop())\\n    return\\n\\nfor x in p1:\\n    nz = set()\\n    for y in p2:\\n        z = x&y\\n        if len(z) ==2 or len(z) ==0:continue        \\n        nz = nz | z\\n    if len(nz) == 2:\\n        print(-1)\\n        return\\n\\nfor x in p2:\\n    nz = set()\\n    for y in p1:\\n        z = x&y\\n        if len(z) ==2 or len(z) ==0:continue        \\n        nz = nz | z\\n    if len(nz) == 2:\\n        print(-1)\\n        return\\n\\nprint(0)\\n\", \"n, m = list(map(int, input().split()))\\naa = list(map(int, input().split()))\\nbb = list(map(int, input().split()))\\n\\na = []\\nb = []\\n\\nfor i in range(0, 2 * n, 2):\\n    a.append([aa[i], aa[i + 1]])\\n\\nfor i in range(0, 2 * m, 2):\\n    b.append([bb[i], bb[i + 1]])\\n\\naccept = []\\n\\nfor num in range(1, 10):\\n    ina = []\\n    inb = []\\n    for x in a:\\n        if num in x:\\n            ina.append(x)\\n    \\n    for x in b:\\n        if num in x:\\n            inb.append(x)\\n    \\n    x = 0\\n    for t in ina:\\n        t.sort()\\n        for p in inb:\\n            p.sort()\\n            if t != p:\\n                x += 1\\n    if x > 0:\\n        accept.append(num)\\n\\nif len(accept) == 1:\\n    print(accept[0])\\n    return\\n\\n#check fst\\nfor t in a:\\n    z = set()\\n    for p in b:\\n        if t != p:\\n            if t[0] in p: z.add(t[0])\\n            if t[1] in p: z.add(t[1])\\n    if len(z) > 1:\\n        print(-1)\\n        return\\n\\n#check scd\\nfor t in b:\\n    z = set()\\n    for p in a:\\n        if t != p:\\n            if t[0] in p: z.add(t[0])\\n            if t[1] in p: z.add(t[1])\\n    if len(z) > 1:\\n        print(-1)\\n        return\\nprint(0)\\n        \\n\\n\", \"iter=0\\nn,m=list(map(int,input().split()))\\ntemppair=[0,0]\\ni1=list(map(int,input().split()))\\ni2=list(map(int,input().split()))\\nl1=[]\\nl2=[]\\nd=0\\nfor i in i1:\\n    if(d==0):\\n        temppair[0]=i\\n        d=1\\n    else:\\n        temppair[1]=i\\n        d=0\\n        l1.append(sorted(temppair.copy()))\\nfor i in i2:\\n    if(d==0):\\n        temppair[0]=i\\n        d=1\\n    else:\\n        temppair[1]=i\\n        d=0\\n        l2.append(sorted(temppair.copy()))\\ndic1=dict()\\ndic2=dict()\\nfor i in range(len(l1)):\\n    l1[i]=(iter,l1[i])\\n    iter+=1\\nfor i in range(len(l2)):\\n    l2[i]=(iter,l2[i])\\n    iter+=1\\nfor e in l1:\\n    for e1 in l2:\\n        if(((e[1][0] in e1[1]) or (e[1][1] in e1[1])) and e[1]!=e1[1]):\\n            dic1[e[0]]=dic1.get(e[0],[])+[e1[1]]\\nfor e in l2:\\n    for e1 in l1:\\n        if(((e[1][0] in e1[1]) or (e[1][1] in e1[1])) and e[1]!=e1[1]):\\n            dic2[e[0]]=dic2.get(e[0],[])+[e1[1]]\\nmybool=True\\n# print(dic1)\\n# print(dic2)\\nfor k,v in list(dic1.items()):\\n    k=l1[k][1]\\n    mybool=mybool and (all([k[0] in p for p in v]) or all([k[1] in p for p in v]))\\nfor k,v in list(dic2.items()):\\n    k=k-len(l1)\\n    k=l2[k][1]\\n    mybool=mybool and (all([k[0] in p for p in v]) or all([k[1] in p for p in v]))\\n\\nc1=True\\ndk1=list(dic1)\\ndk1=list([l1[k][1] for k in dk1])\\nsameone=dk1[0][0]\\nc1=all([sameone in u for u in dk1])\\nfor v in list(dic1.values()):\\n    c1=c1 and all([sameone in u for u in v])\\n\\nif not c1:\\n    c1=True\\n    sameone=dk1[0][1]\\n    c1=all([sameone in u for u in dk1])\\n    for v in list(dic1.values()):\\n        c1=c1 and all([sameone in u for u in v])\\n\\n\\nif(c1):\\n    e,e1=list(dic1.items())[0]\\n    e=l1[e][1]\\n    e1=e1[0]\\n    if (e[0] in e1):\\n        print(e[0])\\n        quit()\\n    else:\\n        print(e[1])\\n        quit()\\nelif(mybool):\\n    print(0)\\n    quit()\\nelse:\\n    print(-1)\\n\", \"#!/usr/bin/env python3\\n\\n[n, m] = list(map(int, input().strip().split()))\\nais = list(map(int, input().strip().split()))\\nbis = list(map(int, input().strip().split()))\\n\\nais = [set(ais[2*i: 2*i + 2]) for i in range(n)]\\nbis = [set(bis[2*i: 2*i + 2]) for i in range(m)]\\n\\ndef check(pair, pairs):\\n\\tres = []\\n\\tfor p in pairs:\\n\\t\\ts = pair & p\\n\\t\\tif len(s) == 1:\\n\\t\\t\\tres.append(s.pop())\\n\\tres = list(set(res))\\n\\tif len(res) == 1:\\n\\t\\treturn res[0]\\n\\telif len(res) > 1:\\n\\t\\treturn -1\\n\\telse:\\n\\t\\treturn 0\\n\\n\\nva = [check(a, bis) for a in ais]\\nvb = [check(b, ais) for b in bis]\\n\\nvap = [v for v in va if v > 0]\\nvbp = [v for v in vb if v > 0]\\n\\nvap = set(vap)\\nvbp = set(vbp)\\n\\nvabp = vap & vbp\\n\\nif -1 in va or -1 in vb:\\n\\tprint(-1)\\nelif len(vabp) > 1:\\n\\tprint(0)\\nelse:\\n\\tprint(vabp.pop())\\n\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"def rp():\\n    cs = list(map(int, input().split(' ')))\\n    cs = list(zip(cs[0::2], cs[1::2]))\\n    return cs\\n\\ndef dist(p1, p2):\\n    return len(set(p1).union(set(p2))) - 2\\n\\ninput()\\n\\nps = [rp(), rp()]\\n\\ntheyCan = True\\nmyPos = set()\\n\\nfor ps1, ps2 in [ps, ps[::-1]]:\\n    for p1 in ps1:\\n        pos = set()\\n\\n        for p2 in ps2:\\n            if dist(p1, p2) == 1:\\n                pos = pos.union( set(p1).intersection(set(p2)) )\\n        \\n        if len(pos) >= 2:\\n            theyCan = False\\n        myPos = myPos.union(pos)\\n\\nprint(next(iter(myPos)) if len(myPos)==1 else 0 if theyCan else -1)\\n\", \"q=input()\\nq1=input().split()\\nq2=input().split()\\nparr1=[]\\nfor i in range(0,len(q1),2):\\n    pair=(q1[i],q1[i+1])\\n    parr1.append(pair)\\nparr2=[]\\nfor i in range(0,len(q2),2):\\n    pair=(q2[i],q2[i+1])\\n    parr2.append(pair)\\nmatches1={}\\nmatches2={}\\nfor i in parr1:\\n    for j in parr2:\\n        if (i[0]==j[0] and i[1]==j[1]) or (i[0]==j[1] and i[1]==j[0]):\\n            continue\\n        elif i[0]==j[0] or i[0]==j[1]:\\n            if matches1.get(i)==None or matches1.get(i)==i[0]:\\n                matches1[i]=i[0]\\n            else:\\n                print('-1')\\n                quit()\\n            if matches2.get(j)==None or matches2.get(j)==i[0]:\\n                matches2[j]=i[0]\\n            else:\\n                print('-1')\\n                quit()\\n        elif i[1]==j[1] or i[1]==j[0]:\\n            if matches1.get(i)==None or matches1.get(i)==i[1]:\\n                matches1[i]=i[1]\\n            else:\\n                print('-1')\\n                quit()\\n            if matches2.get(j)==None or matches2.get(j)==i[1]:\\n                matches2[j]=i[1]\\n            else:\\n                print('-1')\\n                quit()\\n        else:\\n            pass\\nmatches=list(matches1.values())\\nfor i in range(0,len(matches)):\\n    if matches[i]==matches[i-1]:\\n        pass\\n    else:\\n        print('0')\\n        quit()\\nprint(matches[0])\", \"q=input()\\nq1=input().split()\\nq2=input().split()\\nparr1=[]\\nfor i in range(0,len(q1),2):\\n    pair=(q1[i],q1[i+1])\\n    parr1.append(pair)\\nparr2=[]\\nfor i in range(0,len(q2),2):\\n    pair=(q2[i],q2[i+1])\\n    parr2.append(pair)\\nmatches1={}\\nmatches2={}\\nfor i in parr1:\\n    for j in parr2:\\n        if (i[0]==j[0] and i[1]==j[1]) or (i[0]==j[1] and i[1]==j[0]):\\n            continue\\n        elif i[0]==j[0] or i[0]==j[1]:\\n            if matches1.get(i)==None or matches1.get(i)==i[0]:\\n                matches1[i]=i[0]\\n            else:\\n                print('-1')\\n                quit()\\n            if matches2.get(j)==None or matches2.get(j)==i[0]:\\n                matches2[j]=i[0]\\n            else:\\n                print('-1')\\n                quit()\\n        elif i[1]==j[1] or i[1]==j[0]:\\n            if matches1.get(i)==None or matches1.get(i)==i[1]:\\n                matches1[i]=i[1]\\n            else:\\n                print('-1')\\n                quit()\\n            if matches2.get(j)==None or matches2.get(j)==i[1]:\\n                matches2[j]=i[1]\\n            else:\\n                print('-1')\\n                quit()\\n        else:\\n            pass\\nmatches=list(matches1.values())\\nfor i in range(0,len(matches)):\\n    if matches[i]==matches[i-1]:\\n        pass\\n    else:\\n        print('0')\\n        quit()\\nprint(matches[0])\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"2 2\\n1 2 3 4\\n1 5 3 4\\n\",\n    \"2 2\\n1 2 3 4\\n1 5 6 4\\n\",\n    \"2 3\\n1 2 4 5\\n1 2 1 3 2 3\\n\",\n    \"2 1\\n1 2 1 3\\n1 2\\n\",\n    \"4 4\\n1 2 3 4 5 6 7 8\\n2 3 4 5 6 7 8 1\\n\",\n    \"3 3\\n1 2 5 6 7 8\\n2 3 4 5 8 9\\n\",\n    \"4 3\\n1 2 4 5 6 7 8 9\\n1 2 8 9 3 1\\n\",\n    \"3 4\\n2 1 8 9 3 1\\n1 2 4 5 6 7 8 9\\n\",\n    \"3 8\\n8 9 8 5 9 2\\n8 4 8 3 2 6 4 2 4 3 3 7 3 6 1 6\\n\",\n    \"9 1\\n3 4 3 2 3 7 3 5 9 4 1 9 6 4 5 2 7 6\\n8 3\\n\",\n    \"5 6\\n4 7 7 3 4 3 9 4 3 9\\n7 5 7 8 1 7 7 2 6 2 1 2\\n\",\n    \"7 3\\n2 6 6 7 6 4 6 1 9 6 7 4 1 9\\n6 5 3 6 6 8\\n\",\n    \"9 2\\n9 6 1 6 2 5 7 3 8 1 7 2 9 1 2 8 3 8\\n6 4 4 5\\n\",\n    \"5 6\\n1 7 5 6 6 9 3 6 1 9\\n2 7 2 5 8 5 4 8 4 2 8 2\\n\",\n    \"3 9\\n9 7 9 2 7 2\\n9 8 1 9 3 9 6 3 8 6 4 6 1 3 5 4 5 3\\n\",\n    \"9 4\\n2 8 8 9 8 1 9 2 5 9 3 5 3 2 5 2 9 1\\n8 4 8 7 6 8 4 7\\n\",\n    \"1 12\\n6 8\\n8 4 8 2 5 8 9 8 8 3 8 7 8 1 1 3 1 9 4 3 7 3 5 7\\n\",\n    \"12 12\\n7 6 3 8 8 4 4 7 1 9 9 5 7 5 4 9 8 6 2 7 7 3 3 6\\n9 1 2 4 9 8 5 3 6 7 3 8 2 7 5 9 6 4 3 1 2 6 1 4\\n\",\n    \"12 12\\n1 6 2 6 8 3 6 4 4 8 7 2 7 5 9 4 2 4 9 5 8 5 3 6\\n2 8 6 9 2 6 7 4 6 5 6 3 5 8 7 8 7 1 1 9 9 7 7 3\\n\",\n    \"12 12\\n6 7 5 4 7 8 2 9 8 5 3 5 1 6 7 3 7 9 5 7 1 8 6 8\\n6 4 2 1 7 8 1 6 8 5 9 8 1 5 7 2 5 9 6 3 9 2 9 4\\n\",\n    \"1 10\\n3 9\\n3 2 3 4 5 3 5 7 8 6 2 5 7 8 2 4 1 7 5 1\\n\",\n    \"3 10\\n6 1 4 1 4 6\\n7 1 8 1 8 5 3 2 9 7 9 3 5 9 5 3 5 7 7 2\\n\",\n    \"2 7\\n2 7 2 5\\n7 1 9 7 8 9 4 9 8 1 3 9 3 8\\n\",\n    \"12 1\\n6 2 6 4 8 6 6 9 5 6 6 1 9 1 1 3 3 9 2 4 5 2 8 1\\n6 7\\n\",\n    \"2 11\\n6 1 3 6\\n1 7 1 2 1 5 1 4 5 3 3 2 9 8 4 2 7 5 4 9 2 9\\n\",\n    \"6 9\\n8 1 8 4 2 8 2 1 4 1 4 2\\n8 3 8 6 7 8 5 8 6 7 5 7 9 6 5 6 5 3\\n\",\n    \"6 4\\n2 7 3 2 8 3 1 5 7 4 3 5\\n2 6 9 8 8 6 6 9\\n\",\n    \"3 10\\n1 5 7 1 2 1\\n9 5 5 6 3 5 4 7 8 3 9 6 8 4 9 8 4 6 3 4\\n\",\n    \"1 7\\n8 4\\n9 8 8 2 6 8 8 1 7 8 2 1 9 5\\n\",\n    \"3 6\\n3 5 7 4 7 5\\n3 9 3 2 8 6 6 2 8 2 6 9\\n\",\n    \"8 5\\n7 9 6 7 4 7 2 1 4 9 2 9 4 2 9 6\\n8 7 1 8 8 5 3 5 3 8\\n\",\n    \"8 1\\n1 6 7 6 7 3 9 2 1 2 8 6 2 3 4 1\\n8 3\\n\",\n    \"12 5\\n9 2 6 7 7 8 3 4 8 4 7 1 2 1 7 3 7 2 5 6 3 8 1 5\\n3 7 7 5 7 4 5 8 4 6\\n\",\n    \"11 1\\n2 6 1 4 7 9 7 6 8 1 4 8 4 7 7 2 1 7 9 6 6 5\\n3 1\\n\",\n    \"10 2\\n4 9 2 1 5 1 6 2 6 7 2 7 5 8 1 7 5 3 9 1\\n9 7 1 4\\n\",\n    \"9 1\\n1 8 7 6 7 2 7 9 4 1 4 3 3 8 4 6 9 6\\n9 4\\n\",\n    \"4 7\\n9 2 4 1 2 3 2 7\\n6 1 5 4 7 5 6 3 1 5 8 1 1 4\\n\",\n    \"3 7\\n8 2 7 9 8 1\\n3 1 8 1 2 7 4 7 4 2 1 4 4 6\\n\",\n    \"12 2\\n3 1 8 2 6 9 2 6 5 4 4 3 4 1 4 2 6 3 9 7 9 4 3 2\\n7 1 4 1\\n\",\n    \"7 6\\n6 2 9 2 6 5 2 4 1 2 4 5 6 7\\n3 9 5 1 9 8 9 5 3 4 2 3\\n\",\n    \"4 12\\n2 8 3 1 2 1 9 4\\n9 5 5 3 1 6 3 7 7 1 8 5 6 5 4 6 1 9 1 4 2 5 9 8\\n\",\n    \"2 2\\n1 2 2 3\\n2 3 3 4\\n\",\n    \"2 2\\n1 2 1 3\\n1 2 1 3\\n\",\n    \"3 3\\n1 2 1 3 2 3\\n1 2 1 3 2 3\\n\",\n    \"2 3\\n1 2 1 3\\n1 2 1 3 2 3\\n\",\n    \"2 2\\n1 2 2 4\\n1 2 1 3\\n\",\n    \"2 1\\n4 5 6 7\\n4 7\\n\",\n    \"3 2\\n1 2 1 3 2 3\\n1 2 4 5\\n\",\n    \"4 4\\n1 2 1 3 6 7 6 8\\n1 4 1 5 6 1 6 9\\n\",\n    \"4 4\\n1 2 2 3 1 3 4 5\\n1 3 3 2 1 2 4 6\\n\",\n    \"3 2\\n1 2 4 5 6 7\\n4 7 1 3\\n\",\n    \"2 3\\n1 2 7 8\\n1 3 2 4 7 9\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n\",\n    \"0\\n\",\n    \"-1\\n\",\n    \"1\\n\",\n    \"-1\\n\",\n    \"0\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"0\\n\",\n    \"3\\n\",\n    \"7\\n\",\n    \"6\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"9\\n\",\n    \"8\\n\",\n    \"8\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"3\\n\",\n    \"1\\n\",\n    \"7\\n\",\n    \"6\\n\",\n    \"0\\n\",\n    \"8\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"8\\n\",\n    \"3\\n\",\n    \"0\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"0\\n\",\n    \"1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"0\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}