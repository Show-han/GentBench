{
    "problem": "You are an expert Python programmer, and here is your task: Sometimes Mister B has free evenings when he doesn't know what to do. Fortunately, Mister B found a new game, where the player can play against aliens.\n\nAll characters in this game are lowercase English letters. There are two players: Mister B and his competitor.\n\nInitially the players have a string s consisting of the first a English letters in alphabetical order (for example, if a = 5, then s equals to \"abcde\").\n\nThe players take turns appending letters to string s. Mister B moves first.\n\nMister B must append exactly b letters on each his move. He can arbitrary choose these letters. His opponent adds exactly a letters on each move.\n\nMister B quickly understood that his opponent was just a computer that used a simple algorithm. The computer on each turn considers the suffix of string s of length a and generates a string t of length a such that all letters in the string t are distinct and don't appear in the considered suffix. From multiple variants of t lexicographically minimal is chosen (if a = 4 and the suffix is \"bfdd\", the computer chooses string t equal to \"aceg\"). After that the chosen string t is appended to the end of s.\n\nMister B soon found the game boring and came up with the following question: what can be the minimum possible number of different letters in string s on the segment between positions l and r, inclusive. Letters of string s are numerated starting from 1.\n\n\n-----Input-----\n\nFirst and only line contains four space-separated integers: a, b, l and r (1 \u2264 a, b \u2264 12, 1 \u2264 l \u2264 r \u2264 10^9) \u2014 the numbers of letters each player appends and the bounds of the segment.\n\n\n-----Output-----\n\nPrint one integer \u2014 the minimum possible number of different letters in the segment from position l to position r, inclusive, in string s.\n\n\n-----Examples-----\nInput\n1 1 1 8\n\nOutput\n2\nInput\n4 2 2 6\n\nOutput\n3\nInput\n3 7 4 6\n\nOutput\n1\n\n\n-----Note-----\n\nIn the first sample test one of optimal strategies generate string s = \"abababab...\", that's why answer is 2.\n\nIn the second sample test string s = \"abcdbcaefg...\" can be obtained, chosen segment will look like \"bcdbc\", that's why answer is 3.\n\nIn the third sample test string s = \"abczzzacad...\" can be obtained, chosen, segment will look like \"zzz\", that's why answer is 1.",
    "solution": "[\"a,b,l,r=list(map(int, input().split()))\\nlength=int(l/(a+b))\\nif a==3 and b==1 and l==4 and r==10:\\n    print(4)\\n    return\\nl-=length*(a+b)\\nr-=length*(a+b)\\nif r>=4*a+4*b:\\n    r=4*a+4*b\\nif b>=a:\\n    _A=[]\\n    for i in range(a):\\n        _A.append(i+1)\\n    for i in range(b):\\n        _A.append(a)\\n    for i in range(a):\\n        _A.append(i+1)\\n    _A[2*a+b-1]+=1\\n    for i in range(b):\\n        _A.append(_A[2*a+b-1])\\n    for i in range(2*a+2*b):\\n        _A.append(_A[i])\\n    _B=[]\\n    for i in range(25):\\n        _B.append(0)\\n    cnt=0\\n    for i in range(r-l+1):\\n        if _B[_A[l+i-1]]==0:\\n            cnt+=1\\n            _B[_A[l+i-1]]=1\\nelse:\\n    _A=[]\\n    for i in range(a):\\n        _A.append(i+1)\\n    for i in range(b):\\n        _A.append(a)\\n    for i in range(a):\\n        if i+1<=b:\\n            _A.append(i+1)\\n        else:\\n            _A.append(a+i-b+2)\\n    for i in range(b):\\n        _A.append(_A[2*a+b-1])\\n    for i in range(2*a+2*b):\\n        _A.append(_A[i])\\n    _B=[]\\n    for i in range(25):\\n        _B.append(0)\\n    cnt=0\\n    for i in range(r-l+1):\\n        if _B[_A[l+i-1]]==0:\\n            cnt+=1\\n            _B[_A[l+i-1]]=1\\n# print(_A)\\nprint(cnt)\\n\", \"def main(a, b, l, r):\\n\\n    \\n\\n    qL = (l - 1) // (2 * a + 2 * b)\\n\\n    rL = (l - 1) % (2 * a + 2 * b) + 1\\n\\n    \\n\\n    qR = (r - 1) // (2 * a + 2 * b)\\n\\n    rR = (r - 1) % (2 * a + 2 * b) + 1\\n\\n    #print(qL, qR, rL, rR)\\n\\n    if qL == qR:\\n\\n        #In b segment\\n\\n        if a < rL <= a + b and a < rR <= a + b:\\n\\n            return 1\\n\\n        if 2 * a + b < rL and 2 * a + b < rR:\\n\\n            return 1\\n\\n        #In a segment\\n\\n        if 1 <= rL <= a and 1 <= rR <= a:\\n\\n            return rR - rL + 1\\n\\n        if a + b < rL <= 2 * a + b and a + b < rR <= 2 * a + b:\\n\\n            return rR - rL + 1\\n\\n        #In a + b segment\\n\\n        if 1 <= rL <= a + b and 1 <= rR <= a + b:\\n\\n            return a - rL + 1\\n\\n        if a + b < rL and a + b < rR:\\n\\n            return (2 * a + b) - rL + 1\\n\\n        if a < rL <= a + b and a + b < rR <= 2 * a + b:\\n\\n            return 1 + rR - (a + b)\\n\\n        if a < rL <= a + b and 2 * a + b < rR:\\n\\n            return 1 + a\\n\\n        if 1 <= rL <= a and a + b < rR <= 2 * a + b:\\n\\n            ans = a - rL + 1 + max(rR - (a + b + b), 0) + min(b, rR) - max(min(rR, b) - rL + 1, 0)\\n\\n            return ans\\n\\n        if 1 <= rL <= a and 2 * a + b < rR:\\n\\n            return a - rL + 1 + a - max(b - rL + 1, 0)\\n\\n    elif qL == qR - 1:\\n\\n        #abababab\\n\\n        newL = qL * (2 * a + 2 * b) + 1\\n\\n        newR = (qR + 1) * (2 * a + 2 * b)\\n\\n        \\n\\n        if 1 <= rL <= a + b and a + b + 1 <= rR:\\n\\n            return a + max(a - b, 0) + int(a <= b) \\n\\n            \\n\\n        if a + b + 1 <= rL <= 2 * (a + b) and (2 * a + 2 * b) + 1 <= rR <= a + b:\\n\\n            return main(a, b, l - (a + b), r - (a + b))\\n\\n        \\n\\n        if 1 <= rL <= a and 1 <= rR <= a:\\n\\n            return a + max(a - b, 0) + int(a <= b) + rR - max(rR - rL + 1, 0)\\n\\n        if 1 <= rL <= a and a + 1 <= rR <= a + b:\\n\\n            return a + max(a - b, 0) + int(a <= b)\\n\\n        \\n\\n        if a + 1 <= rL <= a + b and 1 <= rR <= a:\\n\\n            return 1 + a\\n\\n        if a + 1 <= rL <= a + b and a + 1 <= rR <= a + b:\\n\\n            return 1 + a + max(a - b, 0)\\n\\n        \\n\\n        return main(a, b, l - (a + b), r - (a + b))\\n\\n        \\n\\n    else:\\n\\n        return a + max(a - b, 0) + int(a <= b) # + main(a, b, l, (qL + 1) * (2 * a + 2 * b)) + main(a, b, qR * (2 * a + 2 * b) + 1, r)\\n\\n\\n\\na, b, l, r = [int(item) for item in input().split()]\\n\\n\\n\\nprint(main(a, b, l, r))\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"1 1 1 8\\n\",\n    \"4 2 2 6\\n\",\n    \"3 7 4 6\\n\",\n    \"4 5 1 1\\n\",\n    \"12 12 1 1000\\n\",\n    \"12 1 1000 1000\\n\",\n    \"3 4 701 703\\n\",\n    \"12 12 13 1000000000\\n\",\n    \"3 4 999999999 1000000000\\n\",\n    \"5 6 1000000000 1000000000\\n\",\n    \"1 1 1 1\\n\",\n    \"12 1 100000011 100000024\\n\",\n    \"10 12 220000011 220000032\\n\",\n    \"1 1 1 1000000000\\n\",\n    \"1 1 999999999 1000000000\\n\",\n    \"1 1 1000000000 1000000000\\n\",\n    \"12 12 1 24\\n\",\n    \"12 12 876543210 1000000000\\n\",\n    \"5 11 654321106 654321117\\n\",\n    \"5 11 654321117 654321140\\n\",\n    \"9 12 654321114 654321128\\n\",\n    \"5 12 654321101 654321140\\n\",\n    \"2 12 654321104 654321122\\n\",\n    \"6 1 654321100 654321115\\n\",\n    \"2 1 654321122 654321129\\n\",\n    \"6 2 654321100 654321140\\n\",\n    \"6 2 654321113 654321123\\n\",\n    \"1 7 654321103 654321105\\n\",\n    \"5 3 654321111 654321117\\n\",\n    \"1 3 654321122 654321140\\n\",\n    \"5 8 654321118 654321137\\n\",\n    \"5 8 654321103 654321106\\n\",\n    \"9 8 654321109 654321126\\n\",\n    \"2 2 987654333 987654335\\n\",\n    \"4 8 987654341 987654343\\n\",\n    \"3 12 987654345 987654347\\n\",\n    \"8 1 987654349 987654354\\n\",\n    \"6 8 987654322 987654327\\n\",\n    \"6 10 987654330 987654337\\n\",\n    \"11 4 987654330 987654343\\n\",\n    \"10 7 987654339 987654340\\n\",\n    \"12 12 987654321 987654328\\n\",\n    \"3 10 498103029 647879228\\n\",\n    \"11 3 378541409 796916287\\n\",\n    \"3 3 240953737 404170887\\n\",\n    \"3 8 280057261 834734290\\n\",\n    \"7 8 305686738 573739036\\n\",\n    \"3 8 36348920 167519590\\n\",\n    \"10 2 1 1000000000\\n\",\n    \"4 1 1 100000\\n\",\n    \"2 1 288 300\\n\",\n    \"5 1 1 100\\n\",\n    \"3 3 3 8\\n\",\n    \"5 1 1 100000\\n\",\n    \"5 1 1 1000\\n\",\n    \"6 1 1 10000\\n\",\n    \"12 1 1 100\\n\",\n    \"2 1 1 1000000\\n\",\n    \"10 1 100 1000000000\\n\",\n    \"2 2 7 12\\n\",\n    \"12 1 1 1000\\n\",\n    \"4 1 1 9\\n\",\n    \"5 2 5 1000\\n\",\n    \"3 1 4 10\\n\",\n    \"12 1 1 1000000\\n\",\n    \"10 5 1 1000000000\\n\",\n    \"10 10 1999 3998\\n\",\n    \"3 1 1 1000\\n\",\n    \"10 1 1 21\\n\",\n    \"5 3 15 18\\n\",\n    \"4 4 2 10\\n\"\n  ],\n  \"outputs\": [\n    \"2\",\n    \"3\",\n    \"1\",\n    \"1\",\n    \"13\",\n    \"1\",\n    \"3\",\n    \"13\",\n    \"1\",\n    \"1\",\n    \"1\",\n    \"13\",\n    \"11\",\n    \"2\",\n    \"1\",\n    \"1\",\n    \"12\",\n    \"13\",\n    \"4\",\n    \"6\",\n    \"4\",\n    \"6\",\n    \"3\",\n    \"11\",\n    \"3\",\n    \"10\",\n    \"7\",\n    \"2\",\n    \"6\",\n    \"2\",\n    \"6\",\n    \"1\",\n    \"10\",\n    \"2\",\n    \"1\",\n    \"3\",\n    \"6\",\n    \"3\",\n    \"2\",\n    \"12\",\n    \"2\",\n    \"4\",\n    \"4\",\n    \"19\",\n    \"4\",\n    \"4\",\n    \"8\",\n    \"4\",\n    \"18\",\n    \"7\",\n    \"3\",\n    \"9\",\n    \"3\",\n    \"9\",\n    \"9\",\n    \"11\",\n    \"23\",\n    \"3\",\n    \"19\",\n    \"3\",\n    \"23\",\n    \"7\",\n    \"8\",\n    \"4\",\n    \"23\",\n    \"15\",\n    \"11\",\n    \"5\",\n    \"19\",\n    \"3\",\n    \"4\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}