{
    "problem": "You are an expert Python programmer, and here is your task: For each string s consisting of characters '0' and '1' one can define four integers a_00, a_01, a_10 and a_11, where a_{xy} is the number of subsequences of length 2 of the string s equal to the sequence {x, y}. \n\nIn these problem you are given four integers a_00, a_01, a_10, a_11 and have to find any non-empty string s that matches them, or determine that there is no such string. One can prove that if at least one answer exists, there exists an answer of length no more than 1 000 000.\n\n\n-----Input-----\n\nThe only line of the input contains four non-negative integers a_00, a_01, a_10 and a_11. Each of them doesn't exceed 10^9.\n\n\n-----Output-----\n\nIf there exists a non-empty string that matches four integers from the input, print it in the only line of the output. Otherwise, print \"Impossible\". The length of your answer must not exceed 1 000 000.\n\n\n-----Examples-----\nInput\n1 2 3 4\n\nOutput\nImpossible\n\nInput\n1 2 2 1\n\nOutput\n0110",
    "solution": "[\"import math\\n\\ndef get_cnt(res):\\n    n = 1 + math.floor(math.sqrt(2 * res))\\n    if n * (n-1) / 2 == res:\\n        return n\\n    else:\\n        return -1\\n        \\ndef calc():\\n    cnt = list(map(int, input().split()))\\n    if cnt == [0,0,0,0]:\\n        return '0'\\n\\n    a = get_cnt(cnt[0])\\n    b = get_cnt(cnt[3])\\n\\n    if cnt == [0,0,0,cnt[3]]:\\n        a = 0\\n    if cnt == [cnt[0],0,0,0]:\\n        b = 0\\n\\n    if a == -1 or b == -1 or (a * b) != (cnt[1] + cnt[2]):\\n        return \\\"Impossible\\\"\\n\\n    ans = ['0'] * (a + b)\\n    i = 0\\n    while b > 0:\\n        while cnt[1] >= b:\\n            i = i + 1\\n            cnt[1] -= b\\n        b -= 1\\n        ans[i] = '1'\\n        i += 1\\n    return ''.join(ans)\\n            \\n\\nprint(calc())\\n\", \"def main():\\n    from itertools import product\\n    def f(a):\\n        x = int((a * 2. + .25) ** .5 + .51)\\n        if x * (x - 1) != a * 2:\\n            raise ValueError\\n        return x\\n\\n    a00, a01, a10, a11 = list(map(int, input().split()))\\n    try:\\n        for b, w in product([f(a00)] if a00 else [1, 0], [f(a11)] if a11 else [1, 0]):\\n            if b * w == a01 + a10:\\n                break\\n        else:\\n            raise ValueError\\n    except ValueError:\\n        print(\\\"Impossible\\\")\\n    else:\\n        if w:\\n            a01, rest = divmod(a01, w)\\n            if rest:\\n                l = ['0' * a01, '1' * (w - rest), '0', '1' * rest, '0' * (b - a01 - 1)]\\n            else:\\n                l = ['0' * a01, '1' * w, '0' * (b - a01)]\\n        else:\\n            l = ['0' * b]\\n        print(''.join(l))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"def main():\\n    from itertools import product\\n    def f(a):\\n        x = int((a * 2. + .25) ** .5 + .51)\\n        if x * (x - 1) != a * 2:\\n            raise ValueError\\n        return (x,) if a else (1, 0)\\n\\n    a00, a01, a10, a11 = list(map(int, input().split()))\\n    try:\\n        for b, w in product(f(a00), f(a11)):\\n            if b * w == a01 + a10:\\n                break\\n        else:\\n            raise ValueError\\n    except ValueError:\\n        print(\\\"Impossible\\\")\\n    else:\\n        a01, rest = divmod(a01, w) if w else (b, 0)\\n        if rest:\\n            l = ['0' * a01, '1' * (w - rest), '0', '1' * rest, '0' * (b - a01 - 1)]\\n        else:\\n            l = ['0' * a01, '1' * w, '0' * (b - a01)]\\n        print(''.join(l))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"def build(a0, a1, a01, a10, arr):\\n    #print(a0, a1, a01, a10)\\n    while True:\\n        if a0 + a1 == 0 and a01 + a10 > 0:\\n            return False, ''\\n    \\n        if a01 < a1 and a10 < a0:\\n            return False, ''\\n    \\n        if a01 + a10 == 0:\\n            if a0 > 0 and a1 > 0:\\n                return False, ''\\n        \\n            while a0 > 0:\\n                arr.append(0)\\n                a0 -=1\\n        \\n            while a1 > 0:\\n                arr.append(1)\\n                a1 -=1\\n            \\n            return True, arr\\n        \\n        if a01 >= a1:\\n            arr.append(0)\\n            a0 -= 1\\n            a01-= a1\\n        else:\\n            arr.append(1)\\n            a1 -= 1\\n            a10-= a0\\n            \\nval = [0] * 50000\\nfor i in range(1, 50000):\\n    val[i] = i*(i-1) // 2\\n\\nd   = {x: i for i, x in enumerate(val)}\\n\\na00, a01, a10, a11 = map(int, input().split())\\n\\ndef solve(a00, a01, a10, a11):\\n    a0_arr = []\\n    a1_arr = []\\n\\n    ans     = None \\n    flag    = False\\n    \\n    if a00 == 0:\\n        a0_arr = [0, 1]\\n    else:\\n        if a00 not in d:\\n            return flag, ans\\n        \\n        a0_arr.append(d[a00])\\n    \\n    if a11 == 0:\\n        a1_arr = [0, 1]\\n    else:\\n        if a11 not in d:\\n            return flag, ans\\n        \\n        a1_arr.append(d[a11])\\n    \\n    for a0 in a0_arr:\\n        for a1 in a1_arr:\\n            arr = []\\n            flg, arr = build(a0, a1, a01, a10, arr)\\n        \\n            if flg == True:\\n                flag=flg\\n                ans = arr\\n                break\\n                \\n    return flag, ans \\n\\nflag, ans = solve(a00, a01, a10, a11)\\nif flag == False:\\n    print('Impossible')\\nelse:\\n    print(''.join([str(x) for x in ans]))\", \"a00, a01, a10, a11 = list(map(int, input().split()))\\n \\nif sum([a00, a01, a10, a11]) == 0:\\n    print(0)\\n    return\\n \\nz, j = 0, 0\\nif a01 != 0 or a10 != 0:\\n    z = j = 1\\n \\nwhile z * (z - 1) // 2 < a00:\\n    z += 1\\nwhile j * (j - 1) // 2 < a11:\\n    j += 1\\n \\nif any([z * (z - 1) // 2 != a00, \\n        j * (j - 1) // 2 != a11,\\n        z * j != a10 + a01]):\\n    print('Impossible')\\n    return\\n \\nn = z + j\\nfor i in range(n):\\n    if z > 0 and a01 >= j:\\n        print('0', end='')\\n        a01 -= j\\n        z -= 1\\n    else:\\n        print('1', end='')\\n        j -= 1\"]",
    "test": "{\"inputs\": [\"1 2 3 4\\n\", \"1 2 2 1\\n\", \"10 7 28 21\\n\", \"0 0 0 0\\n\", \"49995000 11667 4308334 93096\\n\", \"499928010 601314341 398636540 499991253\\n\", \"0 2548 1752 650\\n\", \"0 0 0 45\\n\", \"105 2 598 780\\n\", \"1 0 0 0\\n\", \"0 0 0 1\\n\", \"0 0 1 0\\n\", \"0 1 0 0\\n\", \"487577 9219238 1758432 61721604\\n\", \"1000000000 0 0 0\\n\", \"0 1000000000 0 0\\n\", \"0 0 1000000000 0\\n\", \"0 0 0 1000000000\\n\", \"0 1 1 1\\n\", \"1 1 1 0\\n\", \"1 20000 20001 200010000\\n\", \"1 1 1 3\\n\", \"1000000000 1000000000 1000000000 1000000000\\n\", \"321451234 456748672 987936461 785645414\\n\", \"123456789 987654321 123456789 1\\n\", \"20946628 10679306 272734526 958497438\\n\", \"49995000 584 9417 0\\n\", \"105 14 588 780\\n\", \"4950 15963710 22674282 11352058\\n\", \"12497500 129337096 141847619 166302785\\n\", \"511984000 6502095 8718005 17279400\\n\", \"0 36 7 2\\n\", \"496 41513 39598 43143\\n\", \"127765 3290 752 1579\\n\", \"93096 1351848 3613069 9687152\\n\", \"89253 254334 736333 2741312\\n\", \"499928010 25040 6580 2\\n\", \"999961560 0 0 999961560\\n\", \"499959631 14240 17384 2\\n\", \"450014999 312276555 663878 54397664\\n\", \"45 0 100 45\\n\", \"0 0 0 2\\n\", \"10 0 0 10\\n\", \"6 4 0 0\\n\", \"3 0 0 0\\n\", \"3 10 10 0\\n\", \"0 0 0 4\\n\", \"6 0 0 0\\n\", \"1 4 4 1\\n\", \"10 0 0 6\\n\", \"0 0 4 6\\n\", \"3 0 0 3\\n\", \"0 0 0 6\\n\", \"0 1 1 0\\n\", \"1 0 2 0\\n\", \"0 0 2 1\\n\"], \"outputs\": [\"Impossible\\n\", \"0110\\n\", \"011111110000\\n\", \"0\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"1111111111\\n\", \"1111111111111111111111111111111111111101100000000000000\\n\", \"00\\n\", \"11\\n\", \"10\\n\", \"01\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"101\\n\", \"010\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"Impossible\\n\", \"11111111110000000000\\n\", \"Impossible\\n\", \"Impossible\\n\", \"00001\\n\", \"000\\n\", \"Impossible\\n\", \"Impossible\\n\", \"0000\\n\", \"Impossible\\n\", \"Impossible\\n\", \"11110\\n\", \"Impossible\\n\", \"1111\\n\", \"Impossible\\n\", \"100\\n\", \"110\\n\"]}",
    "tags": [
        "reasoning/coding"
    ]
}