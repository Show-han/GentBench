{
    "problem": "You are an expert Python programmer, and here is your task: Today Pari and Arya are playing a game called Remainders.\n\nPari chooses two positive integer x and k, and tells Arya k but not x. Arya have to find the value $x \\text{mod} k$. There are n ancient numbers c_1, c_2, ..., c_{n} and Pari has to tell Arya $x \\operatorname{mod} c_{i}$ if Arya wants. Given k and the ancient values, tell us if Arya has a winning strategy independent of value of x or not. Formally, is it true that Arya can understand the value $x \\text{mod} k$ for any positive integer x?\n\nNote, that $x \\text{mod} y$ means the remainder of x after dividing it by y.\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and k (1 \u2264 n,  k \u2264 1 000 000)\u00a0\u2014 the number of ancient integers and value k that is chosen by Pari.\n\nThe second line contains n integers c_1, c_2, ..., c_{n} (1 \u2264 c_{i} \u2264 1 000 000).\n\n\n-----Output-----\n\nPrint \"Yes\" (without quotes) if Arya has a winning strategy independent of value of x, or \"No\" (without quotes) otherwise.\n\n\n-----Examples-----\nInput\n4 5\n2 3 5 12\n\nOutput\nYes\n\nInput\n2 7\n2 3\n\nOutput\nNo\n\n\n\n-----Note-----\n\nIn the first sample, Arya can understand $x \\operatorname{mod} 5$ because 5 is one of the ancient numbers.\n\nIn the second sample, Arya can't be sure what $x \\text{mod} 7$ is. For example 1 and 7 have the same remainders after dividing by 2 and 3, but they differ in remainders after dividing by 7.",
    "solution": "[\"from math import *\\nfrom sys import *\\nn, k = map(int, stdin.readline().split(\\\" \\\"))\\na = 1;\\nfor c in map(int, stdin.readline().split(\\\" \\\")):\\n  a = a * (gcd(k, c)//gcd(a, c))\\nif a%k == 0:\\n  print(\\\"Yes\\\")\\nelse:\\n  print(\\\"No\\\")\", \"import math\\nn, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\ng = 1\\nfor i in a:\\n    g = math.gcd(k, i * g//math.gcd(i, g))\\nif g == k:\\n    print('Yes')\\nelse:\\n    print('No')\\n\", \"def sieze_prime(n):\\n    sieze = [True]*(n+1)\\n    sieze[0] = sieze[1] = False\\n    i = 2\\n    while i * i <= n:\\n        if sieze[i]:\\n            for j in range(2*i, n+1, i):\\n                sieze[j] = False\\n            # end for\\n        # end if\\n        i = i + 1\\n    # end while\\n    primes = range(0, n+1)\\n    primes = filter(lambda x : sieze[x], primes)\\n    return primes\\n# end def\\n\\ndef factorize(n):\\n    nonlocal primes\\n    factors = []\\n    i = 0;\\n    while primes[i]**2 <= n:\\n        p = primes[i]\\n        if n % p == 0:\\n            factor = [primes[i], 1]\\n            n //= p\\n            while n % p == 0:\\n                n //= p\\n                factor[1] += 1\\n            # end while\\n            factors.append(factor)\\n        # end if\\n        i += 1\\n    # end while\\n    if not n==1: factors.append([n, 1])\\n    return factors\\n# end def\\n\\nprimes = None\\n\\ndef gcd(a, b):\\n    if a % b == 0:\\n        return b\\n    return gcd(b, a % b)\\n\\ndef lcm(a, b):\\n    return (a * b) // gcd(a, b)\\n\\n\\ndef main():\\n    nonlocal primes\\n    primes = list(sieze_prime(1000000))\\n    n, k = map(lambda x : int(x), input().split())\\n    c = set(map(lambda x : int(x), input().split()))\\n    factors = factorize(k)\\n    success = True\\n    for prime, power in factors:\\n        factor = prime**power\\n        if any(map(lambda x : int(x) % factor==0, c)):\\n            continue\\n        else:\\n            success = False\\n            break\\n    if success: print(\\\"Yes\\\")\\n    else: print(\\\"No\\\")\\n\\nmain()\", \"from math import gcd\\n\\n\\ndef lcm(a, b):\\n\\treturn (a * b) // gcd(a, b)\\n\\n\\ndef main():\\n\\tn, k = list(map(int, input().split()))\\n\\tans = 1\\n\\ta = list(map(int, input().split()))\\n\\tfor i in range(n):\\n\\t\\ttc = a[i]\\n\\t\\tgc = gcd(tc, k)\\n\\t\\tans = lcm(ans, gc)\\n\\tif ans == k:\\n\\t\\tprint('Yes')\\n\\telse:\\n\\t\\tprint('No')\\nmain()\\n\", \"import math\\nn, k = list(map(int, input().split()))\\na = 1;\\nar = list(map(int, input().split()))\\nfor c in ar:\\n\\ta *=  math.gcd(k,c) //math.gcd(a, c)\\nif a % k == 0:\\n\\tprint(\\\"Yes\\\")\\nelse:\\n\\tprint(\\\"No\\\")\\n\\n\", \"import sys\\ninput=sys.stdin.readline\\nimport math\\nn, k = list(map(int, input().split()))\\na = 1;\\nar = list(map(int, input().split()))\\nfor c in ar:\\n    a *=  math.gcd(k,c)//math.gcd(a,c) \\n    #print(a,c)\\nif a % k == 0:\\n\\tprint(\\\"Yes\\\")\\nelse:\\n\\tprint(\\\"No\\\")\\n\", \"\\nimport sys\\ninput=sys.stdin.readline\\nimport math\\nn, k = list(map(int, input().split()))\\na = 1;\\nar = list(map(int, input().split()))\\nfor c in ar:\\n    a *=  math.gcd(k,c)//math.gcd(a,c) \\n    #print(a,c)\\nif a==k:\\n\\tprint(\\\"Yes\\\")\\nelse:\\n\\tprint(\\\"No\\\")\\n\", \"import sys\\nimport math\\nn,k = list(map(int,sys.stdin.readline().split()))\\narr = list(map(int,sys.stdin.readline().split()))\\nans = 1\\nfor i in arr:\\n    ans = math.gcd(k,i*ans//math.gcd(i,ans))\\nif ans == k:\\n    print('Yes')\\nelse:\\n    print('No')\\n\\n\\n\", \"# https://codeforces.com/problemset/problem/687/B\\nMAX = 1000000\\nn,k = map(int,input().split())\\nancient = [int(x) for x in input().split()]\\n\\nisPrime = [0 for x in range(MAX+1)]\\ncount = [0 for x in range(MAX+1)]\\n\\nfor x in range(2,MAX+1):\\n    if not isPrime[x]:\\n        for y in range(x,MAX+1,x):\\n            isPrime[y] = x\\n\\nfor val in ancient:\\n    while val > 1:\\n        p = isPrime[val]\\n        c = 0\\n        while val%p == 0:\\n            c+=1\\n            val = val//p\\n        count[p] = max(count[p],c)\\n\\nflag = True \\nwhile k > 1:\\n    flag &= (count[isPrime[k]] > 0)\\n    count[isPrime[k]] -= 1\\n    k = k//isPrime[k]\\nprint(\\\"Yes\\\" if flag else \\\"No\\\")\", \"# *********************************************************************\\n# *-------------------------------------------------------------------*\\n# *                                                                   *\\n# *   Life is just a life. Lead it, Feel it & Enjoy It Properly.      *\\n# *   Nothing is impossible. Just believe in yourself & Almighty.     *\\n# *                                                                   *\\n# *-------------------------------------------------------------------*\\n# *********************************************************************\\nimport math\\n\\ndef LCM(a,b):\\n    return int(a/math.gcd(a,b))*b\\n\\ndef DenTofieM():\\n    n, k = list(map(int,input().split()))\\n    ar = list(map(int,input().split()))\\n\\n    L=1\\n    for i in ar:\\n        G=math.gcd(i,k)\\n        L=LCM(L,G)\\n    if L==k: print(\\\"Yes\\\")\\n    else: print(\\\"No\\\")\\n\\nDenTofieM()\\n\", \"# *********************************************************************\\n# *-------------------------------------------------------------------*\\n# *                                                                   *\\n# *   Life is just a life. Lead it, Feel it & Enjoy It Properly.      *\\n# *   Nothing is impossible. Just believe in yourself & Almighty.     *\\n# *                                                                   *\\n# *-------------------------------------------------------------------*\\n# *********************************************************************\\nimport math\\n\\ndef LCM(a,b):\\n    return int(a/math.gcd(a,b))*b\\n\\ndef DenTofieM():\\n    n, k = list(map(int,input().split()))\\n    ar = list(map(int,input().split()))\\n\\n    L=1\\n    for i in ar:\\n        G=math.gcd(i,k)\\n        L=LCM(L,G)\\n    if L==k: print(\\\"Yes\\\")\\n    else: print(\\\"No\\\")\\n\\nDenTofieM()\\n\\n\", \"import sys\\nfrom functools  import reduce\\nfrom math import gcd\\nI=sys.stdin.readline\\n\\nans=\\\"\\\"\\n\\nn,k=map(int,I().split())\\n\\nc=list(map(int,I().split()))\\n\\n\\ni=0\\nx=1\\nwhile i<n:\\n\\tg=gcd(c[i],k)\\n\\tx=(x*g)//gcd(g,x)\\n\\ti+=1\\n\\n\\n\\n\\nif x==k:\\n\\tans+=\\\"Yes\\\\n\\\"\\nelse:\\n\\tans+=\\\"No\\\\n\\\"\\n\\n\\nprint(ans)\", \"from math import gcd\\ndef lcm(x,y):\\n\\treturn x*y//gcd(x,y)\\nn,k=map(int,input().split())\\nlst=[]\\nkk=k\\ni=2\\nwhile i<=kk:\\n\\tc=0\\n\\twhile kk%i==0:\\n\\t\\tc+=1\\n\\t\\tkk//=i\\n\\tif c:\\n\\t\\tlst.append([i,c])\\n\\ti+=1\\narr=list(map(int,input().split()))\\nflag=True\\nfor j in lst:\\n\\tma=0\\n\\tfor i in range(n):\\n\\t\\tc=0\\n\\t\\twhile arr[i]%j[0]==0:\\n\\t\\t\\tc+=1\\n\\t\\t\\tarr[i]//=j[0]\\n\\t\\tma=max(c,ma)\\n\\tif ma<j[1]:\\n\\t\\tflag=False\\n\\t\\tbreak\\nprint(\\\"Yes\\\") if flag else print(\\\"No\\\")\", \"# from math import gcd\\n# def lcm(x,y):\\n# \\treturn x*y//gcd(x,y)\\n# n,k=map(int,input().split())\\n# lst=[]\\n# kk=k\\n# i=2\\n# while i<=kk:\\n# \\tc=0\\n# \\twhile kk%i==0:\\n# \\t\\tc+=1\\n# \\t\\tkk//=i\\n# \\tif c:\\n# \\t\\tlst.append([i,c])\\n# \\ti+=1\\n# arr=list(map(int,input().split()))\\n# flag=True\\n# for j in lst:\\n# \\tma=0\\n# \\tfor i in range(n):\\n# \\t\\tc=0\\n# \\t\\twhile arr[i]%j[0]==0:\\n# \\t\\t\\tc+=1\\n# \\t\\t\\tarr[i]//=j[0]\\n# \\t\\tma=max(c,ma)\\n# \\tif ma<j[1]:\\n# \\t\\tflag=False\\n# \\t\\tbreak\\n# print(\\\"Yes\\\") if flag else print(\\\"No\\\")\\n\\nfrom math import gcd\\ndef lcm(x,y):\\n\\treturn x*y//gcd(x,y)\\nn,k=map(int,input().split())\\narr=list(map(int,input().split()))\\nl=1\\nfor x in arr:\\n\\tl=gcd(k,lcm(l,x))\\nprint(\\\"Yes\\\") if l==k else print(\\\"No\\\")\", \"import math\\ndef gcd(a, b):\\n    if b == 0:\\n        return a;\\n    else:\\n        return gcd(b, a % b);\\n\\ndef lcm(a, b):\\n    return a * b // math.gcd(a, b);\\n\\ndef solve(n, k):\\n    ans = 1;\\n    a = list(map(int, input().split()));\\n    #print(a);\\n    for i in range(n):\\n        ans = math.gcd(k, lcm(ans, a[i]));\\n    return ans == k;\\n\\nwhile True:\\n    try:\\n        n, k = list(map(int, input().split()));\\n        p = solve(n, k);\\n        if p:\\n            print(\\\"Yes\\\");\\n        else:\\n            print(\\\"No\\\");\\n    except EOFError:\\n        break\\n\", \"from math import gcd\\nn, k = list(map(int, input().split()))\\nans = 1\\nfor e in input().split():\\n  e = int(e)\\n  ans = ans // gcd(ans, e) * e % k\\nprint('No' if ans else 'Yes')\\n\\n\", \"def gcd(x, y): \\n  \\n   while(y): \\n       x, y = y, x % y \\n  \\n   return x \\n\\nn, k = list(map(int, input().split()))\\nl = list(map(int, input().split()))\\n\\nlcm = 1\\n\\nfor v in l:\\n    lcm = lcm * v // gcd(lcm, v)\\n    lcm = gcd(lcm, k)\\n\\nif k == lcm:\\n    print('Yes')\\nelse:\\n    print('No')\\n\", \"import sys\\nfrom math import gcd\\ninput = sys.stdin.readline\\nn, k = map(int, input().split())\\nv = list(map(int, input().split()))\\nlcm = 1\\nfor u in v:\\n    lcm = lcm * u // gcd(u, lcm)\\n    lcm = gcd(lcm, k)\\nprint ([\\\"No\\\", \\\"Yes\\\"][lcm == k])\", \"import math\\n\\ndef main():\\n    n,k = list(map(int,input().split()))\\n    C = list(map(int,input().split()))\\n    l=C[0]\\n    for c in C:\\n        l = l*c//math.gcd(l,c)%k\\n        if(l==0):\\n            print(\\\"Yes\\\")\\n            return\\n    print(\\\"No\\\")\\n\\nmain()\\n\", \"import sys, math\\ninput = sys.stdin.readline\\n\\ndef getInts():\\n    return [int(s) for s in input().split()]\\n\\ndef getInt():\\n    return int(input())\\n\\ndef getStrs():\\n    return [s for s in input().split()]\\n\\ndef getStr():\\n    return input().strip()\\n\\ndef listStr():\\n    return list(input().strip())\\n\\nimport collections as col\\nimport math\\n\\ndef solve():\\n    #we need to know whether, amongst the C values, there are two or more pairwise coprime values whose product equals K\\n    N, K = getInts()\\n    C = getInts()\\n    lcm = 1\\n    for c in C:\\n        lcm = lcm*c//math.gcd(lcm,c)\\n        lcm = math.gcd(lcm,K)\\n    return \\\"Yes\\\" if lcm == K else \\\"No\\\"\\n    \\n#for _ in range(getInt()):\\nprint(solve())\\n    \\n\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"4 5\\n2 3 5 12\\n\",\n    \"2 7\\n2 3\\n\",\n    \"1 6\\n8\\n\",\n    \"2 3\\n9 4\\n\",\n    \"4 16\\n19 16 13 9\\n\",\n    \"5 10\\n5 16 19 9 17\\n\",\n    \"11 95\\n31 49 8 139 169 121 71 17 43 29 125\\n\",\n    \"17 71\\n173 43 139 73 169 199 49 81 11 89 131 107 23 29 125 152 17\\n\",\n    \"13 86\\n41 64 17 31 13 97 19 25 81 47 61 37 71\\n\",\n    \"15 91\\n49 121 83 67 128 125 27 113 41 169 149 19 37 29 71\\n\",\n    \"2 4\\n2 2\\n\",\n    \"14 87\\n1619 1619 1619 1619 1619 1619 1619 1619 1619 1619 1619 1619 1619 1619\\n\",\n    \"12 100\\n1766 1766 1766 1766 1766 1766 1766 1766 1766 1766 1766 1766\\n\",\n    \"1 994619\\n216000\\n\",\n    \"1 651040\\n911250\\n\",\n    \"1 620622\\n60060\\n\",\n    \"1 1\\n559872\\n\",\n    \"88 935089\\n967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967 967\\n\",\n    \"93 181476\\n426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426 426\\n\",\n    \"91 4900\\n630 630 70 630 910 630 630 630 770 70 770 630 630 770 70 630 70 630 70 630 70 630 630 70 910 630 630 630 770 630 630 630 70 910 70 630 70 630 770 630 630 70 630 770 70 630 70 70 630 630 70 70 70 70 630 70 70 770 910 630 70 630 770 70 910 70 630 910 630 70 770 70 70 630 770 630 70 630 70 70 630 70 630 770 630 70 630 630 70 910 630\\n\",\n    \"61 531012\\n698043 698043 698043 963349 698043 698043 698043 963349 698043 698043 698043 963349 698043 698043 698043 698043 966694 698043 698043 698043 698043 698043 698043 636247 698043 963349 698043 698043 698043 698043 697838 698043 963349 698043 698043 966694 698043 698043 698043 698043 698043 698043 698043 698043 698043 698043 698043 698043 698043 698043 698043 698043 698043 698043 963349 698043 698043 698043 698043 963349 698043\\n\",\n    \"1 216000\\n648000\\n\",\n    \"2 8\\n4 4\\n\",\n    \"3 8\\n4 4 4\\n\",\n    \"2 8\\n2 4\\n\",\n    \"3 12\\n2 2 3\\n\",\n    \"10 4\\n2 2 2 2 2 2 2 2 2 2\\n\",\n    \"10 1024\\n1 2 4 8 16 32 64 128 256 512\\n\",\n    \"3 24\\n2 2 3\\n\",\n    \"1 8\\n2\\n\",\n    \"2 9\\n3 3\\n\",\n    \"3 4\\n2 2 2\\n\",\n    \"3 4\\n1 2 2\\n\",\n    \"1 4\\n2\\n\",\n    \"1 100003\\n2\\n\",\n    \"1 2\\n12\\n\",\n    \"2 988027\\n989018 995006\\n\",\n    \"3 9\\n3 3 3\\n\",\n    \"1 49\\n7\\n\",\n    \"2 600000\\n200000 300000\\n\",\n    \"3 8\\n2 2 2\\n\",\n    \"7 510510\\n524288 531441 390625 823543 161051 371293 83521\\n\",\n    \"2 30\\n6 10\\n\",\n    \"2 27000\\n5400 4500\\n\",\n    \"3 8\\n1 2 4\\n\",\n    \"4 16\\n2 2 2 2\\n\",\n    \"2 16\\n4 8\\n\",\n    \"2 8\\n4 2\\n\",\n    \"3 4\\n2 2 3\\n\",\n    \"1 8\\n4\\n\",\n    \"1 999983\\n2\\n\",\n    \"3 16\\n2 4 8\\n\",\n    \"2 216\\n12 18\\n\",\n    \"2 16\\n8 8\\n\",\n    \"2 36\\n18 12\\n\",\n    \"2 36\\n12 18\\n\",\n    \"2 1000000\\n1000000 1000000\\n\",\n    \"3 20\\n2 2 5\\n\",\n    \"1 2\\n6\\n\",\n    \"4 4\\n2 3 6 5\\n\",\n    \"1 2\\n1\\n\",\n    \"1 6\\n6\\n\",\n    \"2 16\\n4 4\\n\",\n    \"2 3779\\n1 2\\n\",\n    \"2 8\\n4 12\\n\",\n    \"2 24\\n4 6\\n\",\n    \"1 1\\n5\\n\",\n    \"10 255255\\n1000000 700000 300000 110000 130000 170000 190000 230000 290000 310000\\n\",\n    \"2 1000\\n500 2\\n\",\n    \"4 8\\n2 2 2 2\\n\",\n    \"1 666013\\n1\\n\",\n    \"1 999983\\n1\\n\",\n    \"1 125\\n5\\n\",\n    \"2 32\\n4 8\\n\",\n    \"3 32\\n2 4 8\\n\",\n    \"3 8\\n2 4 11\\n\",\n    \"1 32\\n2\\n\",\n    \"4 4\\n2 2 2 2\\n\",\n    \"8 32\\n2 2 2 2 2 2 2 2\\n\",\n    \"3 24\\n2 4 3\\n\",\n    \"2 4\\n2 6\\n\",\n    \"2 24\\n6 4\\n\",\n    \"1 20998\\n2\\n\",\n    \"1 1\\n1\\n\",\n    \"2 20998\\n2 10499\\n\",\n    \"1 5\\n1\\n\",\n    \"2 25\\n5 5\\n\",\n    \"5 2\\n2 2 2 2 2\\n\",\n    \"3 12\\n2 3 6\\n\",\n    \"1 1\\n3\\n\",\n    \"2 16\\n8 4\\n\",\n    \"40 10\\n2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\\n\"\n  ],\n  \"outputs\": [\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}