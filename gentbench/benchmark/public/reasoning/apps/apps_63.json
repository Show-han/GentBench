{
    "problem": "You are an expert Python programmer, and here is your task: Slime has a sequence of positive integers $a_1, a_2, \\ldots, a_n$.\n\nIn one operation Orac can choose an arbitrary subsegment $[l \\ldots r]$ of this sequence and replace all values $a_l, a_{l + 1}, \\ldots, a_r$ to the value of median of $\\{a_l, a_{l + 1}, \\ldots, a_r\\}$.\n\nIn this problem, for the integer multiset $s$, the median of $s$ is equal to the $\\lfloor \\frac{|s|+1}{2}\\rfloor$-th smallest number in it. For example, the median of $\\{1,4,4,6,5\\}$ is $4$, and the median of $\\{1,7,5,8\\}$ is $5$.\n\nSlime wants Orac to make $a_1 = a_2 = \\ldots = a_n = k$ using these operations.\n\nOrac thinks that it is impossible, and he does not want to waste his time, so he decided to ask you if it is possible to satisfy the Slime's requirement, he may ask you these questions several times.\n\n\n-----Input-----\n\nThe first line of the input is a single integer $t$: the number of queries.\n\nThe first line of each query contains two integers $n\\ (1\\le n\\le 100\\,000)$ and $k\\ (1\\le k\\le 10^9)$, the second line contains $n$ positive integers $a_1,a_2,\\dots,a_n\\ (1\\le a_i\\le 10^9)$\n\nThe total sum of $n$ is at most $100\\,000$.\n\n\n-----Output-----\n\nThe output should contain $t$ lines. The $i$-th line should be equal to 'yes' if it is possible to make all integers $k$ in some number of operations or 'no', otherwise. You can print each letter in lowercase or uppercase.\n\n\n-----Example-----\nInput\n5\n5 3\n1 5 2 6 1\n1 6\n6\n3 2\n1 2 3\n4 3\n3 1 2 3\n10 3\n1 2 3 4 5 6 7 8 9 10\n\nOutput\nno\nyes\nyes\nno\nyes\n\n\n\n-----Note-----\n\nIn the first query, Orac can't turn all elements into $3$.\n\nIn the second query, $a_1=6$ is already satisfied.\n\nIn the third query, Orac can select the complete array and turn all elements into $2$.\n\nIn the fourth query, Orac can't turn all elements into $3$.\n\nIn the fifth query, Orac can select $[1,6]$ at first and then select $[2,10]$.",
    "solution": "[\"import sys\\ninput = lambda: sys.stdin.readline().rstrip()\\nT = int(input())\\nfor _ in range(T):\\n    N, K = list(map(int, input().split()))\\n    A = [int(a) for a in input().split()]\\n    if K not in A:\\n        print(\\\"no\\\")\\n        continue\\n    \\n    if N == 1 or (A[0] >= K and A[1] >= K):\\n        print(\\\"yes\\\")\\n        continue\\n    \\n    for i in range(2, N):\\n        if A[i] >= K and (A[i-1] >= K or A[i-2] >= K):\\n            print(\\\"yes\\\")\\n            break\\n    else:\\n        print(\\\"no\\\")\\n        continue\\n\", \"import sys\\nreadline = sys.stdin.readline\\n\\nT = int(readline())\\nAns = ['no']*T\\n\\nfor qu in range(T):\\n    N, K = list(map(int, readline().split()))\\n    A = list(map(int, readline().split()))\\n    A = [-1 if a < K else 0 if a == K else 1 for a in A]\\n    if 0 not in A:\\n        continue\\n    for i in range(1, N-1):\\n        if A[i] < 0 and A[i-1] >= 0 and A[i+1] >= 0:\\n            A[i] = 1\\n    for i in range(2, N):\\n        if A[i] < 0 and A[i-1] >= 0 and A[i-2] >= 0:\\n            A[i] = 1\\n    for i in range(N-3, -1, -1):\\n        if A[i] < 0 and A[i+1] >= 0 and A[i+2] >= 0:\\n            A[i] = 1\\n    for i in range(1, N):\\n        if A[i] == 1 and A[i-1] == 0:\\n            A[i] = 0\\n    for i in range(N-2, -1, -1):\\n        if A[i] == 1 and A[i+1] == 0:\\n            A[i] = 0\\n    A.sort()\\n    if A[-1-(-N//2)] == 0:\\n        Ans[qu] = 'yes'\\nprint('\\\\n'.join(Ans))\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nQ = int(input())\\nQuery = []\\nfor _ in range(Q):\\n    N, K = map(int, input().split())\\n    A = list(map(int, input().split()))\\n    Query.append((N, K, A))\\n\\nfor N, K, A in Query:\\n    Inds = []\\n    exists = False\\n    for i, a in enumerate(A):\\n        if a == K: exists = True\\n        if a >= K:\\n            Inds.append(i)\\n    \\n    if not exists:\\n        ok = False\\n    elif N == 1:\\n        ok = True\\n    else:\\n        ok = False\\n        for ind in Inds:\\n            if ind < N-1 and A[ind+1] >= A[ind]:\\n                ok = True\\n            elif ind > 0 and A[ind-1] >= A[ind]:\\n                ok = True\\n            elif ind > 1 and A[ind-2] >= A[ind]:\\n                ok = True\\n            elif ind < N-2 and A[ind+2] >= A[ind]:\\n                ok = True\\n    print(\\\"yes\\\" if ok else \\\"no\\\")\"]",
    "test": "{\n  \"inputs\": [\n    \"5\\n5 3\\n1 5 2 6 1\\n1 6\\n6\\n3 2\\n1 2 3\\n4 3\\n3 1 2 3\\n10 3\\n1 2 3 4 5 6 7 8 9 10\\n\",\n    \"2\\n1 1\\n1000000000\\n3 1000000000\\n1000000000 996 251\\n\",\n    \"1\\n7 2\\n5 5 1 1 2 1 1\\n\",\n    \"1\\n10 2\\n1 1 2 1 1 1 1 5 1 5\\n\",\n    \"1\\n10 10\\n10 1 1 1 1 1 1 11 1 11\\n\",\n    \"1\\n9 3\\n3 1 1 1 1 1 4 1 4\\n\",\n    \"1\\n7 3\\n3 2 2 2 4 2 4\\n\",\n    \"1\\n9 5\\n6 4 6 1 1 1 1 1 5\\n\",\n    \"1\\n6 3\\n3 1 1 6 1 6\\n\",\n    \"1\\n6 3\\n4 1 4 1 1 3\\n\",\n    \"1\\n7 2\\n2 1 1 1 3 1 3\\n\",\n    \"1\\n5 2\\n2 1 5 1 1\\n\",\n    \"1\\n7 3\\n4 1 4 1 1 1 3\\n\",\n    \"1\\n7 3\\n3 1 1 1 4 1 4\\n\",\n    \"1\\n6 2\\n3 1 3 1 1 2\\n\",\n    \"1\\n6 3\\n5 1 5 2 2 3\\n\",\n    \"1\\n7 2\\n3 3 1 1 2 1 1\\n\",\n    \"1\\n14 3\\n1 1 10 1 13 1 1 1 1 1 3 1 1 3\\n\",\n    \"1\\n7 10\\n15 1 15 1 1 1 10\\n\",\n    \"1\\n10 2\\n2 1 1 1 1 1 1 1 3 3\\n\",\n    \"1\\n17 15\\n3 5 4 6 10 2 16 10 18 8 5 1 2 7 15 14 8\\n\",\n    \"1\\n6 5\\n5 1 1 7 1 7\\n\",\n    \"1\\n10 2\\n3 1 3 1 1 1 1 1 1 2\\n\",\n    \"1\\n7 2\\n3 1 3 1 1 1 2\\n\"\n  ],\n  \"outputs\": [\n    \"no\\nyes\\nyes\\nno\\nyes\\n\",\n    \"no\\nno\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\",\n    \"yes\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}