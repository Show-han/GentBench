{
    "problem": "You are an expert Python programmer, and here is your task: Mad scientist Mike has just finished constructing a new device to search for extraterrestrial intelligence! He was in such a hurry to launch it for the first time that he plugged in the power wires without giving it a proper glance and started experimenting right away. After a while Mike observed that the wires ended up entangled and now have to be untangled again.\n\nThe device is powered by two wires \"plus\" and \"minus\". The wires run along the floor from the wall (on the left) to the device (on the right). Both the wall and the device have two contacts in them on the same level, into which the wires are plugged in some order. The wires are considered entangled if there are one or more places where one wire runs above the other one. For example, the picture below has four such places (top view): [Image] \n\nMike knows the sequence in which the wires run above each other. Mike also noticed that on the left side, the \"plus\" wire is always plugged into the top contact (as seen on the picture). He would like to untangle the wires without unplugging them and without moving the device. Determine if it is possible to do that. A wire can be freely moved and stretched on the floor, but cannot be cut.\n\nTo understand the problem better please read the notes to the test samples.\n\n\n-----Input-----\n\nThe single line of the input contains a sequence of characters \"+\" and \"-\" of length n (1 \u2264 n \u2264 100000). The i-th (1 \u2264 i \u2264 n) position of the sequence contains the character \"+\", if on the i-th step from the wall the \"plus\" wire runs above the \"minus\" wire, and the character \"-\" otherwise.\n\n\n-----Output-----\n\nPrint either \"Yes\" (without the quotes) if the wires can be untangled or \"No\" (without the quotes) if the wires cannot be untangled.\n\n\n-----Examples-----\nInput\n-++-\n\nOutput\nYes\n\nInput\n+-\n\nOutput\nNo\n\nInput\n++\n\nOutput\nYes\n\nInput\n-\n\nOutput\nNo\n\n\n\n-----Note-----\n\nThe first testcase corresponds to the picture in the statement. To untangle the wires, one can first move the \"plus\" wire lower, thus eliminating the two crosses in the middle, and then draw it under the \"minus\" wire, eliminating also the remaining two crosses.\n\nIn the second testcase the \"plus\" wire makes one full revolution around the \"minus\" wire. Thus the wires cannot be untangled:  [Image] \n\nIn the third testcase the \"plus\" wire simply runs above the \"minus\" wire twice in sequence. The wires can be untangled by lifting \"plus\" and moving it higher:  [Image] \n\nIn the fourth testcase the \"minus\" wire runs above the \"plus\" wire once. The wires cannot be untangled without moving the device itself:  [Image]",
    "solution": "[\"l = []\\n\\nfor c in input():\\n    if len(l) > 0 and l[-1] == c:\\n        l.pop()\\n    else:\\n        l.append(c)\\n\\nprint('Yes' if len(l) == 0 else 'No')\\n\", \"s=input()\\n\\nif(len(s)%2==1):\\n    print(\\\"No\\\")\\n\\nelse:\\n    x=len(s)-1\\n    start=1\\n    while(len(s)!=x):\\n        x=len(s)\\n        n=x\\n        for i in range(max(start,1),x):\\n            l=i-1\\n            r=i\\n            if(s[l]==s[r]):\\n                while(l>=0 and r<n and s[l]==s[r]):\\n                    r+=1\\n                    l-=1\\n                l+=1\\n                r-=1\\n                s=s[:l]+s[r+1:]\\n                start=l\\n                break\\n\\n    if(len(s)==0):\\n        print(\\\"Yes\\\")\\n    else:\\n        print(\\\"No\\\")\\n    \\n        \\n\", \"s = input()\\nans = [0] * len(s)\\nn = 0\\nfor x in s:\\n  if n and ans[n-1] == x:\\n    n -= 1\\n  else:\\n    ans[n] = x\\n    n += 1\\nprint('No' if n else 'Yes')\\n\\n\", \"s=input()\\nx=1\\nif(len(s)%2==1):\\n    print(\\\"No\\\")\\n\\nelse:\\n    x=len(s)-1\\n    start=1\\n    while(len(s)!=x):\\n        x=len(s)\\n        n=x\\n        for i in range(max(start,1),x):\\n            l=i-1\\n            r=i\\n            if(s[l]==s[r]):\\n                while(l>=0 and r<n and s[l]==s[r]):\\n                    r+=1\\n                    l-=1\\n                l+=1\\n                r-=1\\n                s=s[:l]+s[r+1:]\\n                start=l\\n                break\\n\\n    if(len(s)==0):\\n        print(\\\"Yes\\\")\\n    else:\\n        print(\\\"No\\\")\\n    \\n        \\n\", \"#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\n\\nstack = ['#']\\nfor c in input():\\n    if stack[-1] == c:\\n        stack.pop()\\n    else:\\n        stack.append(c)\\n\\nstack.pop()\\nprint(\\\"No\\\" if len(stack) else \\\"Yes\\\")\\n\", \"s = input()\\nstk = []\\nfor ch in s:\\n  if len(stk) > 0 and stk[-1] == ch:\\n    stk.pop()\\n  else:\\n    stk.append(ch)\\nif len(stk) == 0:\\n  print(\\\"Yes\\\")\\nelse:\\n  print(\\\"No\\\")\\n\", \"from collections import deque\\na = input().rstrip()                                                                         \\nq = deque()\\nfor i in a:   \\n  if len(q) > 0 and i == q[-1]:\\n    q.pop()  \\n  else:\\n    q.append(i)\\nprint('Yes' if len(q) == 0 else 'No')\\n\", \"a = []\\nfor ch in input():\\n    if a and a[-1] == ch:\\n        a.pop()\\n    else:\\n        a.append(ch)\\nprint('Yes' if not a else 'No')\\n\", \"import sys\\nimport collections\\ndef solve():\\n    vals = list(input())\\n    q = collections.deque()\\n    for cur in vals:\\n        if len(q) > 0 and q[0] == cur:\\n            q.popleft()\\n        else:\\n            q.appendleft(cur)\\n    if len(q) == 0: return \\\"Yes\\\"\\n    return \\\"No\\\"\\n\\n    \\ndef read(mode=2):\\n    inputs = input().strip()\\n    if mode == 0: return inputs  # String\\n    if mode == 1: return inputs.split()  # List of strings\\n    if mode == 2: return list(map(int, inputs.split()))  # List of integers\\ndef write(s=\\\"\\\\n\\\"):\\n    if s is None: s = \\\"\\\"\\n    if isinstance(s, list): s = \\\" \\\".join(map(str, s))\\n    if isinstance(s, tuple): s = \\\" \\\".join(map(str, s))\\n    s = str(s)\\n    print(s, end=\\\"\\\")\\ndef run():\\n    # if sys.hexversion == 50594544 : sys.stdin = open(\\\"test.txt\\\")\\n    res = solve()\\n    write(res)\\nrun()\", \"import sys\\nimport collections\\ndef solve():\\n    vals = list(input())\\n    q = collections.deque()\\n    for cur in vals:\\n        if len(q) > 0 and q[0] == cur:\\n            q.popleft()\\n        else:\\n            q.appendleft(cur)\\n    if len(q) == 0: return \\\"Yes\\\"\\n    return \\\"No\\\"\\n\\n    \\ndef read(mode=2):\\n    inputs = input().strip()\\n    if mode == 0: return inputs  # String\\n    if mode == 1: return inputs.split()  # List of strings\\n    if mode == 2: return list(map(int, inputs.split()))  # List of integers\\ndef write(s=\\\"\\\\n\\\"):\\n    if s is None: s = \\\"\\\"\\n    if isinstance(s, list): s = \\\" \\\".join(map(str, s))\\n    if isinstance(s, tuple): s = \\\" \\\".join(map(str, s))\\n    s = str(s)\\n    print(s, end=\\\"\\\")\\ndef run():\\n    # if sys.hexversion == 50594544 : sys.stdin = open(\\\"test.txt\\\")\\n    res = solve()\\n    write(res)\\nrun()\", \"import sys\\nimport math\\n \\nst = input()\\nmystack = [st[0]]\\n\\nfor i in range(1, len(st)):\\n    if(mystack != []):\\n        v = mystack.pop()\\n        if(v != st[i]):\\n            mystack.append(v)\\n            mystack.append(st[i])\\n    else:\\n        mystack.append(st[i])\\n\\nif(mystack == []):\\n    print(\\\"Yes\\\")\\nelse:\\n    print(\\\"No\\\")\", \"def main():\\n    stack = []\\n    for c in input():\\n        if stack and c == stack[-1]:\\n            del stack[-1]\\n        else:\\n            stack.append(c)\\n    print((\\\"Yes\\\", \\\"No\\\")[bool(stack)])\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"s=[]\\nfor c in input():\\n     if len(s) and s[-1]==c:\\n          s.pop()\\n     else:\\n          s.append(c)\\nif len(s):\\n     print('No')\\nelse:\\n     print('Yes')\", \"l=input()\\nl=list(l)\\n\\np=[]\\n\\nfor i in l:\\n\\tif len(p)==0:\\n\\t\\tp.append(i)\\n\\telif p[-1]==i:\\n\\t\\tp.pop()\\n\\telse:\\n\\t\\tp.append(i)\\n\\t#print(p)\\nif len(p)==0:\\n\\tprint('Yes')\\nelse:\\n\\tprint('No')\", \"stack=[]\\nfor i in input().strip():\\n    if len(stack)==0:\\n        stack.append(i)\\n    elif stack[-1]==i:\\n        stack.pop()\\n    else:\\n        stack.append(i)\\nif len(stack)==0:\\n    print('Yes')\\nelse:\\n    print('No')\\n\", \"s = input().strip()\\nst = ['!']\\nfor si in s:\\n    if st[-1]==si:\\n        st.pop()\\n    else:\\n        st.append(si)\\nprint('Yes' if len(st)==1 else 'No')\", \"from sys import stdin\\n\\nlines, line_index = stdin.readlines(), -1\\n\\n\\ndef get_line():\\n  nonlocal lines, line_index\\n\\n  line_index += 1\\n  return lines[line_index]\\n\\ndef main():\\n  string = get_line().strip()\\n\\n  stack = []\\n\\n  for c in string:\\n    if not stack:\\n      stack.append(c)\\n    elif stack[-1] == c:\\n      stack.pop()\\n    else:\\n      stack.append(c)\\n\\n  if not stack:\\n    print('Yes')\\n  else:\\n    print('No')\\n\\nmain()\", \"sequence = input().strip()\\n\\nif len(sequence) % 2 != 0:\\n    print('No')\\nelse:\\n    stack = []\\n    for s in sequence:\\n        if stack and s == stack[-1]:\\n            stack.pop()\\n        else:\\n            stack.append(s)\\n\\n    if stack:\\n        print('No')\\n    else:\\n        print('Yes')\", \"def Untangled(exp):\\n    stack = []\\n    for i in exp:\\n        if( (not stack) or (stack[-1] != i) ):\\n            stack.append(i)\\n        else:\\n            stack.pop()\\n    return \\\"No\\\" if stack else \\\"Yes\\\"\\n\\nexp = input().strip()\\nprint(Untangled(exp))\", \"ans = []\\nfor c in input():\\n  if len(ans) and ans[-1] == c:\\n    ans.pop()\\n  else:\\n    ans += [c]\\nprint('No' if len(ans) else 'Yes')\\n\", \"wires = input()\\nc = 0\\nd = 0\\nfor i in range(len(wires)):\\n    if (wires[i] == '+'):\\n        c+=2*(i%2) - 1\\n    if (wires[i] == '-'):\\n        d+=2*(i%2) - 1\\nif c==0 and d==0:\\n    print(\\\"Yes\\\")\\nelse:\\n    print(\\\"No\\\")\\n# 1532030829894\\n\", \"X=input()\\nL=[]\\nfor i in X:\\n    if L==[]:\\n        L.append(str(i))\\n    else:\\n        if i==L[len(L)-1]:\\n            L.pop()\\n        else:\\n            L.append(i)\\nif L==[]:\\n    print('Yes')\\nelse:\\n    print('No')\\n\\n# 1532039711851\\n\", \"s = input()\\n\\nif len(s)%2:print('No');return\\n\\nif s[::2].count('+')-s[1::2].count('+')==0:print('Yes');return\\n\\nprint('No')\\n\\n\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"-++-\\n\",\n    \"+-\\n\",\n    \"++\\n\",\n    \"-\\n\",\n    \"+-+-\\n\",\n    \"-+-\\n\",\n    \"-++-+--+\\n\",\n    \"+\\n\",\n    \"-+\\n\",\n    \"--\\n\",\n    \"+++\\n\",\n    \"--+\\n\",\n    \"++--++\\n\",\n    \"+-++-+\\n\",\n    \"+-+--+\\n\",\n    \"--++-+\\n\",\n    \"-+-+--\\n\",\n    \"+-+++-\\n\",\n    \"-+-+-+\\n\",\n    \"-++-+--++--+-++-\\n\",\n    \"+-----+-++---+------+++-++++\\n\",\n    \"-+-++--+++-++++---+--+----+--+-+-+++-+++-+---++-++++-+--+--+--+-+-++-+-+-++++++---++--+++++-+--++--+-+--++-----+--+-++---+++---++----+++-++++--++-++-\\n\",\n    \"-+-----++++--++-+-++\\n\",\n    \"+--+--+------+++++++-+-+++--++---+--+-+---+--+++-+++-------+++++-+-++++--+-+-+++++++----+----+++----+-+++-+++-----+++-+-++-+-+++++-+--++----+--+-++-----+-+-++++---+++---+-+-+-++++--+--+++---+++++-+---+-----+++-++--+++---++-++-+-+++-+-+-+---+++--+--++++-+-+--++-------+--+---++-----+++--+-+++--++-+-+++-++--+++-++++++++++-++-++++++-+++--+--++-+++--+++-++++----+++---+-+----++++-+-+\\n\",\n    \"-+-+-++-+-+-\\n\",\n    \"-+-++-+-\\n\",\n    \"-+-++-+-+-\\n\",\n    \"++-+-+-+-+--+\\n\",\n    \"+++---\\n\",\n    \"+-+-+-+-+--+-+-+-+-++--++--+\\n\",\n    \"+-+-++\\n\",\n    \"-++--+--+++-+-+-+-+-\\n\",\n    \"+---+-+-\\n\",\n    \"+-+--+-+\\n\",\n    \"+++---+++---\\n\",\n    \"-+++++\\n\",\n    \"-+-+-+-+-+-+-++-+-+-+-+-+-+-\\n\",\n    \"-+++--\\n\",\n    \"+---+\\n\",\n    \"-++\\n\",\n    \"-+--+-\\n\",\n    \"+---++--++\\n\",\n    \"+++-\\n\",\n    \"--+++\\n\",\n    \"++-+\\n\"\n  ],\n  \"outputs\": [\n    \"Yes\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"Yes\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\",\n    \"No\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}