{
    "problem": "You are an expert Python programmer, and here is your task: Emuskald is an avid horticulturist and owns the world's longest greenhouse \u2014 it is effectively infinite in length.\n\nOver the years Emuskald has cultivated n plants in his greenhouse, of m different plant species numbered from 1 to m. His greenhouse is very narrow and can be viewed as an infinite line, with each plant occupying a single point on that line.\n\nEmuskald has discovered that each species thrives at a different temperature, so he wants to arrange m - 1 borders that would divide the greenhouse into m sections numbered from 1 to m from left to right with each section housing a single species. He is free to place the borders, but in the end all of the i-th species plants must reside in i-th section from the left.\n\nOf course, it is not always possible to place the borders in such way, so Emuskald needs to replant some of his plants. He can remove each plant from its position and place it anywhere in the greenhouse (at any real coordinate) with no plant already in it. Since replanting is a lot of stress for the plants, help Emuskald find the minimum number of plants he has to replant to be able to place the borders.\n\n\n-----Input-----\n\nThe first line of input contains two space-separated integers n and m (1 \u2264 n, m \u2264 5000, n \u2265 m), the number of plants and the number of different species. Each of the following n lines contain two space-separated numbers: one integer number s_{i} (1 \u2264 s_{i} \u2264 m), and one real number x_{i} (0 \u2264 x_{i} \u2264 10^9), the species and position of the i-th plant. Each x_{i} will contain no more than 6 digits after the decimal point.\n\nIt is guaranteed that all x_{i} are different; there is at least one plant of each species; the plants are given in order \"from left to the right\", that is in the ascending order of their x_{i} coordinates (x_{i} < x_{i} + 1, 1 \u2264 i < n).\n\n\n-----Output-----\n\nOutput a single integer \u2014 the minimum number of plants to be replanted.\n\n\n-----Examples-----\nInput\n3 2\n2 1\n1 2.0\n1 3.100\n\nOutput\n1\n\nInput\n3 3\n1 5.0\n2 5.5\n3 6.0\n\nOutput\n0\n\nInput\n6 3\n1 14.284235\n2 17.921382\n1 20.328172\n3 20.842331\n1 25.790145\n1 27.204125\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first test case, Emuskald can replant the first plant to the right of the last plant, so the answer is 1.\n\nIn the second test case, the species are already in the correct order, so no replanting is needed.",
    "solution": "[\"n, m = map(int, input().split())\\nt = [int(input().split()[0]) for i in range(n)]\\np = [0] * (m + 1)\\nfor i, j in enumerate(t): p[j] = min(p[j], min(p[: j])) - 1\\nprint(n + min(p))\", \"from bisect import bisect_right\\nn = int(input().split()[0])\\nt = [int(input().split()[0]) for i in range(n)]\\np, k = [], 0\\nfor i in t:\\n    x = bisect_right(p, i)\\n    if x < k: p[x] = i\\n    else:\\n        p.append(i)\\n        k += 1\\nprint(n - k)\", \"n, m = map(int, input().split())\\nt = [int(input().split()[0]) for i in range(n)]\\np = [0] * (m + 1)\\nfor i, j in enumerate(t): p[j] = min(p[j], min(p[: j])) - 1\\nprint(n + min(p))\", \"numbers, types = list(map(int, input().split()))\\n\\nposition = [0] * (numbers)\\nbinary_search_array = [1] * (numbers)\\n\\nfor i in range(numbers):\\n    position[i] = int(input().split()[0])\\n\\nmax_length = int(0)\\n\\nfor i in range(numbers):\\n    low = int(0)\\n    high = int(max_length)\\n\\n    while (low < high):\\n        mid = int((low + high) / 2)\\n        if (binary_search_array[mid] <= position[i]):\\n            low = mid + 1\\n        else:\\n            high = mid\\n\\n    binary_search_array[low] = position[i]\\n    if (low == max_length):\\n        max_length += 1\\n\\n\\nprint(numbers - max_length)\\n\", \"'''n, m, k = [int(x) for x in input().split()]\\n\\ntrees = tuple([int(x) for x in input().split()])\\n\\ncosts = []\\nfor x in range(n):\\n    costs.append([0] + [int(x) for x in input().split()])\\n\\ndp = [[[float('inf') for z in range(m + 1)] for y in range(k + 1)] for x in range(n)]\\n\\nif trees[0] == 0:\\n    for k in range(len(dp[0][0])):\\n        dp[0][1][k] = cost[0][k]\\nelse:\\n    dp[0][0][trees[0]] = cost[0][trees[0]]\\n\\nfor i in range(1, len(dp)):\\n    for j in range(1, len(dp[0])):\\n        for k in range(1, len(dp[0][0])):\\n            if trees\\n            for l in range(len(dp[0][0])):\\n                if k == l:\\n                    dp[i][j][k] = dp[i - 1][j][k] + cost[i][k]\\n                else:\\n                    dp[i][j][k] = dp[i - 1][j - 1][l] + cost[i][k]'''\\n\\n\\n\\nn, m = [int(x) for x in input().split()]\\nplant = [int(input().split()[0]) for x in range(n)]\\ndp = [1 for x in range(n)]\\n\\n\\n\\nfor i in range(len(plant)):\\n    for j in range(0, i):\\n        if plant[j] > plant[i]:\\n            continue\\n        dp[i] = max(dp[i], dp[j] + 1)\\n#print(dp)\\nprint(n - max(dp))\\n\\n\\n\\n\\n\\n'''for i in range(1, n):\\n    for k in range(plant[i], 0, -1):\\n        dp[plant[i]] = max(dp[plant[i]], 1 + dp[k])\\nprint(n - max(dp) - 1)'''\\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\", \"n, m = map(int, input().split())\\ntype = [0]\\nfor x in range(n):\\n\\ttype.append(int(input().split()[0]))\\n\\ndp = [[0] * (m + 1) for x in range(2)]\\nfor i in range(1, n + 1):\\n\\tdp[i & 1][0] = 1e9\\n\\tfor j in range (1, m + 1):\\n\\t\\tif type[i] == j:\\n\\t\\t\\tdp[i & 1][j] = dp[1 - (i & 1)][j]\\n\\t\\telif type[i] > j:\\n\\t\\t\\tdp[i & 1][j] = 1 + dp[1 - (i & 1)][j]\\n\\t\\telse:\\n\\t\\t\\tif j >= 1:\\n\\t\\t\\t\\tdp[i & 1][j] = min(dp[i & 1][j - 1], 1 + dp[1 - (i & 1)][j])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp[i & 1][j] = dp[1 - (i & 1)][j]\\nprint (dp[n & 1][m])\", \"n, m = list(map(int, input().split()))\\n\\nt = [int(input().split()[0]) for i in range(n)]\\n\\np = [0] * (m + 1)\\n\\nfor i, j in enumerate(t): p[j] = min(p[j], min(p[: j])) - 1\\n\\nprint(n + min(p))\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"n, m = list(map(int, input().split()))\\nt = [int(input().split()[0]) for i in range(n)]\\np = [0] * (m + 1)\\nfor i in t: p[i] = max(p[1:i+1])+1\\nprint(n - max(p))\\n\", \"n, m = list(map(int, input().split()))\\nt = [int(input().split()[0]) for i in range(n)]\\np = [0] * (m + 1)\\nfor i, j in enumerate(t): p[j] = min(p[: j+1]) - 1\\nprint(n + min(p))\\n\", \"n, m = [int(x) for x in input().split()]\\nd = [0 for i in range(m)]\\nfor i in range(n):\\n    c, x = [x for x in input().split()]\\n    c = int(c)\\n\\n    d[c-1] = max(d[:c])+1\\nprint(n-max(d))\\n        \\n\", \"def CeilIndex(A, l, r, key): \\n  \\n    while (r - l > 1): \\n      \\n        m = l + (r - l)//2\\n        if (A[m] > key): \\n            r = m \\n        else: \\n            l = m \\n    return r \\n   \\ndef LongestIncreasingSubsequenceLength(A, size): \\n  \\n    # Add boundary case, \\n    # when array size is one \\n   \\n    tailTable = [0 for i in range(size + 1)] \\n    len = 0 # always points empty slot \\n   \\n    tailTable[0] = A[0] \\n    len = 1\\n    for i in range(1, size): \\n      \\n        if (A[i] < tailTable[0]): \\n  \\n            # new smallest value \\n            tailTable[0] = A[i] \\n   \\n        elif (A[i] >= tailTable[len-1]): \\n  \\n            # A[i] wants to extend \\n            # largest subsequence \\n            tailTable[len] = A[i] \\n            len+= 1\\n   \\n        else: \\n            # A[i] wants to be current \\n            # end candidate of an existing \\n            # subsequence. It will replace \\n            # ceil value in tailTable \\n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \\n          \\n   \\n    return len\\n  \\n# driver code \\narr = [] \\nn,m=list(map(int,input().split()))\\nfor i in range(n) :\\n    a,b=list(map(float,input().split()))\\n    arr.append(a)\\n   \\nprint(n-LongestIncreasingSubsequenceLength(arr, n)) \\n  \\n# This code is contributed \\n# by Anant Agarwal. \\n\", \"# -*- coding:utf-8 -*-\\n\\n\\\"\\\"\\\"\\n\\ncreated by shuangquan.huang at 1/10/20\\n\\nLIS\\n\\n\\\"\\\"\\\"\\n\\nimport collections\\nimport time\\nimport os\\nimport sys\\nimport bisect\\nimport heapq\\nfrom typing import List\\n\\n\\ndef solve(N, M, A):\\n    \\n    bit = [0 for _ in range(N)]\\n    \\n    def add(index, val):\\n        while index < N:\\n            bit[index] = max(bit[index], val)\\n            index |= index + 1\\n    \\n    def query(index):\\n        s = 0\\n        while index >= 0:\\n            s = max(s, bit[index])\\n            index = (index & (index + 1)) - 1\\n        \\n        return s\\n    \\n    q = [(v, i) for i, v in enumerate(A)]\\n    q.sort()\\n    \\n    s = 0\\n    for v, i in q:\\n        t = query(i) + 1\\n        add(i, t)\\n        s = max(s, t)\\n    \\n    return N-s\\n    \\n    \\n    \\n\\n\\nN, M = map(int, input().split())\\nA = []\\nfor i in range(N):\\n    x, y = input().split()\\n    A.append(int(x))\\n\\nprint(solve(N, M, A))\", \"def solve(n, a):\\n    lis = [0] * n\\n    for i in range(0, n):\\n        for j in range(0, i):\\n            if a[i] >= a[j]:\\n                lis[i] = max(lis[i], lis[j] + 1)\\n        if lis[i] == 0:\\n            lis[i] = 1\\n    print(n - max(lis))\\n\\n\\ndef main():\\n    inp = lambda: int(input().split()[0])\\n    n = inp()\\n    a = [inp() for _ in range(n)]\\n    solve(n, a)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n\\n__starting_point()\", \"# Basta encontrar la medida del mayor subarray que es no-decreciente.\\n# Con cada inserci\\u00f3n podemos aumentar este n\\u00famero en 1.\\n\\nn = int(input().split()[0])\\na = []\\nfor _ in range(n):\\n    a.append(int(input().split()[0]))\\ndp = [0]*n\\nfor i in range(n):\\n    dp[i] = 1\\n    for j in range(i):\\n        if a[j] <= a[i] and dp[j] >= dp[i]:\\n            dp[i] = dp[j] + 1\\nprint(n - max(dp))\\n\\n\", \"import math\\nimport sys\\ninput=sys.stdin.readline\\n#t=int(input())\\nt=1\\nfor _ in range(t):\\n    #n=int(input())\\n    n,m=list(map(int,input().split()))\\n    #l=list(map(int,input().split()))\\n    l=[]\\n    for __ in range(n):\\n        s,x=list(map(float,input().split()))\\n        l.append(int(s))\\n    dp=[0]*(n+1)\\n    for i in range(n):\\n        j=l[i]\\n        for j1 in range(j,-1,-1):\\n            dp[j]=max(dp[j],1+dp[j1])\\n    maxi=max(dp[:])\\n    print(n-maxi)\\n\", \"\\nn,m = list(map(int,input().split()))\\narr = []\\nfor i in range(n):\\n    l = list(map(float,input().split()))\\n    arr.append(int(l[0]))\\ndp = [1 for i in range(n)]\\n\\nfor i in range(1,n):\\n    for j in range(i):\\n        if arr[j]<=arr[i]:\\n            dp[i] = max(dp[i],dp[j]+1)\\nprint(n-max(dp))\", \"from math import ceil,sqrt\\nfrom collections import defaultdict\\n\\n\\n\\n\\ndef solve():\\n\\n\\n    n,m = list(map(int,input().split()))\\n\\n    l = []\\n    for i in range(n):\\n        a,b = list(map(float,input().split()))\\n        l.append(a)\\n\\n    dp = [0]*(n)\\n\\n    for i in range(n):\\n        maxi = 0\\n        for j in range(i):\\n           if l[i]>=l[j]:\\n             maxi = max(dp[j],maxi)\\n\\n        dp[i] = maxi+1\\n    # print(dp)\\n    print(n-max(dp))\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# t = int(input())\\n# for _ in range(t):\\n\\nsolve()\\n\\n\\n\", \"n,m=map(int,input().split())\\nl=[]\\nfor i in range(n):\\n\\ta,b=input().split()\\n\\tl.append(int(a))\\ndp=[1]*n\\nfor i in range(1,n):\\n\\tfor j in range(0,i):\\n\\t\\tif l[i]>=l[j]:\\t\\n\\t\\t\\tdp[i]=max(dp[i],dp[j]+1)\\nprint(n-max(dp))\"]",
    "test": "{\n  \"inputs\": [\n    \"3 2\\n2 1\\n1 2.0\\n1 3.100\\n\",\n    \"3 3\\n1 5.0\\n2 5.5\\n3 6.0\\n\",\n    \"6 3\\n1 14.284235\\n2 17.921382\\n1 20.328172\\n3 20.842331\\n1 25.790145\\n1 27.204125\\n\",\n    \"1 1\\n1 0\\n\",\n    \"8 2\\n1 0.000000\\n1 1.000000\\n1 2.000000\\n2 2.000001\\n1 999999997.000000\\n2 999999998.000000\\n2 999999999.999999\\n2 1000000000.000000\\n\",\n    \"15 5\\n4 6.039627\\n2 7.255149\\n2 14.469785\\n2 15.108572\\n4 22.570081\\n5 26.642253\\n5 32.129202\\n5 44.288220\\n5 53.231909\\n5 60.548042\\n4 62.386581\\n2 77.828816\\n1 87.998512\\n3 96.163559\\n2 99.412872\\n\",\n    \"10 7\\n4 70882.412953\\n1 100461.912159\\n3 100813.254090\\n7 121632.112636\\n2 424085.529781\\n6 510966.713362\\n6 543441.105338\\n7 680094.776949\\n1 721404.212606\\n5 838754.272757\\n\",\n    \"5 5\\n5 0\\n4 1\\n3 2\\n2 3\\n1 4\\n\",\n    \"12 5\\n2 0\\n2 1\\n3 2\\n3 3\\n3 4\\n1 5\\n5 6\\n3 7\\n3 8\\n3 9\\n4 999999999\\n4 1000000000\\n\",\n    \"3 3\\n2 0\\n1 1\\n3 2\\n\",\n    \"3 3\\n3 0\\n1 1\\n2 2\\n\",\n    \"4 2\\n1 10\\n2 20\\n1 30\\n2 40\\n\",\n    \"20 10\\n1 0.000000\\n2 0.000001\\n3 0.000002\\n4 0.000003\\n5 0.000004\\n6 0.000005\\n7 0.000006\\n8 0.000007\\n9 0.000008\\n10 0.000009\\n1 999999999.999990\\n2 999999999.999991\\n3 999999999.999992\\n4 999999999.999993\\n5 999999999.999994\\n6 999999999.999995\\n7 999999999.999996\\n8 999999999.999997\\n9 999999999.999998\\n10 999999999.999999\\n\",\n    \"12 4\\n3 0\\n3 1\\n3 2\\n3 3\\n3 4\\n1 5\\n1 6\\n2 7\\n4 8\\n4 9\\n2 10\\n3 11\\n\",\n    \"16 2\\n1 0\\n1 1\\n2 2\\n2 3\\n2 4\\n2 5\\n1 6\\n1 7\\n2 8\\n2 9\\n1 10\\n1 11\\n2 12\\n2 13\\n2 14\\n2 15\\n\",\n    \"10 10\\n1 100\\n2 101\\n3 102\\n5 103\\n9 1000\\n8 10000\\n6 100000\\n7 1000000\\n4 10000000\\n10 100000000\\n\",\n    \"10 6\\n5 50837.108162\\n3 111993.624183\\n1 207268.919250\\n6 567963.419694\\n1 621364.247371\\n2 630118.065585\\n1 642135.221942\\n6 642673.884754\\n5 647004.198361\\n4 735196.102629\\n\",\n    \"20 2\\n1 39277.770446\\n1 131242.472574\\n2 131745.437889\\n1 261920.593789\\n2 323611.256365\\n1 341693.666730\\n2 378611.498102\\n2 568433.562368\\n1 667757.789581\\n1 674662.040626\\n2 690065.099817\\n2 724737.429934\\n1 774858.513301\\n2 783681.914774\\n1 808327.402925\\n2 867697.070403\\n1 880911.396984\\n1 929807.064277\\n2 942269.265950\\n1 999503.792481\\n\",\n    \"20 15\\n6 8719.787178\\n10 13066.663722\\n15 58623.690996\\n9 184321.819759\\n3 227999.294560\\n2 279836.330518\\n9 282806.308675\\n8 311056.507765\\n1 312315.562927\\n5 459200.373445\\n14 563454.265947\\n7 647364.984868\\n13 679761.613732\\n4 684192.647497\\n1 733119.607626\\n7 748637.778398\\n12 828048.945890\\n11 893690.736585\\n8 965323.895167\\n5 967641.708962\\n\",\n    \"15 3\\n1 0\\n2 1\\n3 2\\n1 3\\n2 4\\n3 5\\n1 6\\n2 7\\n3 8\\n1 9\\n2 10\\n3 11\\n1 12\\n2 13\\n3 14\\n\",\n    \"10 2\\n2 0\\n2 1\\n2 2\\n2 3\\n2 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\\n\",\n    \"11 3\\n2 0\\n2 1\\n2 2\\n2 3\\n2 4\\n3 5\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n\",\n    \"0\\n\",\n    \"2\\n\",\n    \"0\\n\",\n    \"1\\n\",\n    \"6\\n\",\n    \"5\\n\",\n    \"4\\n\",\n    \"2\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"9\\n\",\n    \"5\\n\",\n    \"4\\n\",\n    \"3\\n\",\n    \"6\\n\",\n    \"9\\n\",\n    \"15\\n\",\n    \"8\\n\",\n    \"5\\n\",\n    \"5\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}