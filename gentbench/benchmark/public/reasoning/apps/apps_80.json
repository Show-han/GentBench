{
    "problem": "You are an expert Python programmer, and here is your task: The famous global economic crisis is approaching rapidly, so the states of Berman, Berance and Bertaly formed an alliance and allowed the residents of all member states to freely pass through the territory of any of them. In addition, it was decided that a road between the states should be built to guarantee so that one could any point of any country can be reached from any point of any other State.\n\nSince roads are always expensive, the governments of the states of the newly formed alliance asked you to help them assess the costs. To do this, you have been issued a map that can be represented as a rectangle table consisting of n rows and m columns. Any cell of the map either belongs to one of three states, or is an area where it is allowed to build a road, or is an area where the construction of the road is not allowed. A cell is called passable, if it belongs to one of the states, or the road was built in this cell. From any passable cells you can move up, down, right and left, if the cell that corresponds to the movement exists and is passable.\n\nYour task is to construct a road inside a minimum number of cells, so that it would be possible to get from any cell of any state to any cell of any other state using only passable cells.\n\nIt is guaranteed that initially it is possible to reach any cell of any state from any cell of this state, moving only along its cells. It is also guaranteed that for any state there is at least one cell that belongs to it.\n\n\n-----Input-----\n\nThe first line of the input contains the dimensions of the map n and m (1 \u2264 n, m \u2264 1000)\u00a0\u2014 the number of rows and columns respectively.\n\nEach of the next n lines contain m characters, describing the rows of the map. Digits from 1 to 3 represent the accessory to the corresponding state. The character '.' corresponds to the cell where it is allowed to build a road and the character '#' means no construction is allowed in this cell.\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the minimum number of cells you need to build a road inside in order to connect all the cells of all states. If such a goal is unachievable, print -1.\n\n\n-----Examples-----\nInput\n4 5\n11..2\n#..22\n#.323\n.#333\nOutput\n2\nInput\n1 5\n1#2#3\n\nOutput\n-1",
    "solution": "[\"#!/usr/bin/env python3\\n#\\n# Three States\\n#\\nimport sys, os\\nfrom collections import deque\\nfrom pprint import pprint\\n\\ndef read_ints(): return list(map(int, input().split()))\\ndef read_str(): return input().strip()\\n\\nn, m = read_ints()\\ns = [read_str() for _ in range(n)]\\n\\nt = [set(), set(), set()]\\n\\nfor i in range(n):\\n\\tfor j in range(m):\\n\\t\\tif s[i][j] in '123':\\n\\t\\t\\tfor ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\\n\\t\\t\\t\\tif 0 <= ii < n and 0 <= jj < m:\\n\\t\\t\\t\\t\\tif s[ii][jj] in '123.' and s[i][j] != s[ii][jj]:\\n\\t\\t\\t\\t\\t\\tt[int(s[i][j]) - 1].add((i, j))\\n\\t\\t\\t\\t\\t\\tbreak\\n\\nz = [[[1e18] * 3 for j in range(m)] for i in range(n)]\\nans = 1e18\\nfor root in range(3):\\n\\tq = deque()\\n\\tvi = [[False] * m for _ in range(n)]\\n\\tfor i, j in t[root]:\\n\\t\\tq.append((i, j, 0))\\n\\t\\tvi[i][j] = True\\n\\t\\tz[i][j][root] = 0\\n\\tdist = [1e18] * 3\\n\\tdist[root] = 0\\n\\twhile q:\\n\\t\\ti, j, d = q.popleft()\\n\\t\\tfor ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\\n\\t\\t\\tif 0 <= ii < n and 0 <= jj < m and not vi[ii][jj]:\\n\\t\\t\\t\\tif s[ii][jj] == '.':\\n\\t\\t\\t\\t\\tvi[ii][jj] = True\\n\\t\\t\\t\\t\\tq.append((ii, jj, d + 1))\\n\\t\\t\\t\\t\\tz[ii][jj][root] = min(z[ii][jj][root], d + 1)\\n\\t\\t\\t\\telif s[ii][jj] != s[i][j] and s[ii][jj] in '123':\\n\\t\\t\\t\\t\\tdist[int(s[ii][jj]) - 1] = min(dist[int(s[ii][jj]) - 1], d)\\n\\tans = min(ans, sum(dist))\\n\\nif ans >= 1e18:\\n\\tprint(-1)\\nelse:\\n\\tfor i in range(n):\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif s[i][j] == '.':\\n\\t\\t\\t\\tans = min(ans, sum(z[i][j]) - 2)\\n\\tprint(ans)\\n\", \"#!/usr/bin/env python3\\n#\\n# Three States\\n#\\nimport sys, os\\nfrom collections import deque\\nfrom pprint import pprint\\n\\ndef read_ints(): return list(map(int, input().split()))\\ndef read_str(): return input().strip()\\n\\nn, m = read_ints()\\ns = [read_str() for _ in range(n)]\\n\\nt = [set(), set(), set()]\\n\\nfor i in range(n):\\n\\tfor j in range(m):\\n\\t\\tif s[i][j] in '123':\\n\\t\\t\\tfor ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\\n\\t\\t\\t\\tif 0 <= ii < n and 0 <= jj < m:\\n\\t\\t\\t\\t\\tif s[ii][jj] in '123.' and s[i][j] != s[ii][jj]:\\n\\t\\t\\t\\t\\t\\tt[int(s[i][j]) - 1].add((i, j))\\n\\t\\t\\t\\t\\t\\tbreak\\n\\nz = [[[1e18] * 3 for j in range(m)] for i in range(n)]\\nans = 1e18\\nfor root in range(3):\\n\\tq = deque()\\n\\tvi = [[False] * m for _ in range(n)]\\n\\tfor i, j in t[root]:\\n\\t\\tq.append((i, j, 0))\\n\\t\\tvi[i][j] = True\\n\\t\\tz[i][j][root] = 0\\n\\tdist = [1e18] * 3\\n\\tdist[root] = 0\\n\\twhile q:\\n\\t\\ti, j, d = q.popleft()\\n\\t\\tfor ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\\n\\t\\t\\tif 0 <= ii < n and 0 <= jj < m and not vi[ii][jj]:\\n\\t\\t\\t\\tif s[ii][jj] == '.':\\n\\t\\t\\t\\t\\tvi[ii][jj] = True\\n\\t\\t\\t\\t\\tq.append((ii, jj, d + 1))\\n\\t\\t\\t\\t\\tz[ii][jj][root] = min(z[ii][jj][root], d + 1)\\n\\t\\t\\t\\telif s[ii][jj] != s[i][j] and s[ii][jj] in '123':\\n\\t\\t\\t\\t\\tdist[int(s[ii][jj]) - 1] = min(dist[int(s[ii][jj]) - 1], d)\\n\\tans = min(ans, sum(dist))\\n\\nif ans >= 1e18:\\n\\tprint(-1)\\nelse:\\n\\tfor i in range(n):\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif s[i][j] == '.':\\n\\t\\t\\t\\tans = min(ans, sum(z[i][j]) - 2)\\n\\tprint(ans)\\n\\n\", \"# lista doble enlazada o(1) operaciones en los bordes es mejor que si se implementa en el propio lenguaje\\nfrom collections import deque\\nn, m = input().split()\\nn = int(n)\\nm = int(m)\\n\\n\\ndef idx(i, j):\\n    return i*m + j\\n\\n\\nmax = n*m*2\\ngraph = \\\"\\\"\\nvirtDist = [[], [], []]\\nvirtVertex = [deque(), deque(), deque()]\\nvirtNodesDst = [max, max, max]\\ncode = ord(\\\"1\\\")\\nfor i in range(0, n):\\n    s = input()\\n    graph += s\\n    for j in range(0, m):\\n        virtDist[0].append(max)\\n        virtDist[1].append(max)\\n        virtDist[2].append(max)\\n        indx = ord(s[j])-code\\n        if 0 > indx or indx > 2:\\n            continue\\n        virtVertex[indx].append((i, j))\\n        i2 = idx(i, j)\\n        virtDist[indx][-1] = 0\\n\\n\\ndef bfs01(queue, distance):\\n    while queue:\\n        pi, pj = queue.popleft()\\n        for i, j in [(pi, pj-1), (pi, pj+1), (pi-1, pj), (pi+1, pj)]:\\n            indx = idx(i, j)\\n            if 0 > i or i >= n or 0 > j or j >= m or graph[indx] == '#':\\n                continue\\n            isRoad = graph[indx] == \\\".\\\"\\n            newDistance = distance[idx(pi, pj)] + (1 if isRoad else 0)\\n            if distance[indx] > newDistance:  # relax\\n                distance[indx] = newDistance\\n                if isRoad:\\n                    queue.append((i, j))\\n                else:\\n                    queue.appendleft((i, j))\\n\\n\\nbfs01(virtVertex[0], virtDist[0])\\nbfs01(virtVertex[1], virtDist[1])\\nbfs01(virtVertex[2], virtDist[2])\\n\\noutput = max\\nfor i in range(0, n*m):\\n    output = min(virtDist[0][i] + virtDist[1][i] + virtDist[2]\\n                 [i] - (2 if graph[i] == \\\".\\\"else 0), output)\\n\\nprint(output if output < max else -1)\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"4 5\\n11..2\\n#..22\\n#.323\\n.#333\\n\",\n    \"1 5\\n1#2#3\\n\",\n    \"3 4\\n.2..\\n...3\\n.1#.\\n\",\n    \"10 10\\n##.#..#.#2\\n...###....\\n#..#....##\\n.....#....\\n.#........\\n.....#####\\n...#..#...\\n....###...\\n###.##...#\\n.#...1#.3.\\n\",\n    \"4 3\\n..#\\n.3.\\n..2\\n..1\\n\",\n    \"5 5\\n.2...\\n#2.3.\\n.#..#\\n.#.11\\n#..#.\\n\",\n    \"1 3\\n231\\n\",\n    \"3 1\\n3\\n1\\n2\\n\",\n    \"1 4\\n12#3\\n\",\n    \"10 10\\n..#..###.#\\n..##......\\n#...#..#..\\n.....##...\\n2...#.#.##\\n#..1.#....\\n#.....3...\\n#.###.##..\\n...#..##.#\\n.#........\\n\",\n    \"10 10\\n#...33.#.#\\n#.#.33.#1.\\n2.....#.11\\n222#.#.#..\\n####...#.#\\n#.........\\n.#....#...\\n..#..#.##.\\n##.....#.#\\n#..#....#.\\n\",\n    \"10 10\\n..#.....#.\\n.#.##...#.\\n..#.......\\n..111.....\\n#..#.....#\\n.#...2....\\n.....2....\\n.....222..\\n..........\\n#.3....#..\\n\",\n    \"10 10\\n##.#.##.##\\n#.#..####.\\n#.###.333.\\n..#..#3.2#\\n...###3..#\\n..#.#..#.#\\n...#.#.#..\\n...##.1..#\\n.##.#.1#.#\\n..#.#.11..\\n\",\n    \"10 10\\n###..#.#.#\\n#....####.\\n##1###.#.#\\n#.11######\\n##11#####.\\n..#####..#\\n####...#.3\\n.#.#..2223\\n#####..#33\\n#.########\\n\",\n    \"3 10\\n........2.\\n......1...\\n.........3\\n\",\n    \"10 10\\n1111.22222\\n1111.22222\\n11......22\\n11......22\\n..........\\n3333333333\\n3333333333\\n3333333333\\n3333333333\\n3333333333\\n\",\n    \"4 4\\n3###\\n.222\\n.#.2\\n1222\\n\",\n    \"3 3\\n##3\\n1..\\n222\\n\",\n    \"4 4\\n1...\\n.222\\n....\\n...3\\n\",\n    \"1 9\\n111222333\\n\",\n    \"1 10\\n111222333.\\n\",\n    \"1 15\\n111112222233333\\n\",\n    \"5 4\\n2..3\\n2..3\\n....\\n1..1\\n1111\\n\",\n    \"10 1\\n1\\n.\\n2\\n2\\n2\\n2\\n2\\n.\\n3\\n.\\n\",\n    \"3 3\\n#2#\\n1.3\\n1.#\\n\",\n    \"1 9\\n1.22222.3\\n\",\n    \"3 3\\n1.2\\n1.2\\n333\\n\",\n    \"4 7\\n2..1..3\\n2##.##3\\n2##.##3\\n2.....3\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n\",\n    \"-1\\n\",\n    \"2\\n\",\n    \"-1\\n\",\n    \"1\\n\",\n    \"2\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"-1\\n\",\n    \"6\\n\",\n    \"12\\n\",\n    \"6\\n\",\n    \"2\\n\",\n    \"-1\\n\",\n    \"3\\n\",\n    \"2\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"2\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"1\\n\",\n    \"2\\n\",\n    \"0\\n\",\n    \"4\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}