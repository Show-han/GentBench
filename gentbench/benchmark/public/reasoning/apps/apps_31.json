{
    "problem": "You are an expert Python programmer, and here is your task: We have N gemstones labeled 1 through N.\nYou can perform the following operation any number of times (possibly zero).\n - Select a positive integer x, and smash all the gems labeled with multiples of x.\nThen, for each i, if the gem labeled i remains without getting smashed, you will receive a_i yen (the currency of Japan).\nHowever, a_i may be negative, in which case you will be charged money.\nBy optimally performing the operation, how much yen can you earn?\n\n-----Constraints-----\n - All input values are integers.\n - 1 \\leq N \\leq 100\n - |a_i| \\leq 10^9\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\na_1 a_2 ... a_N\n\n-----Output-----\nPrint the maximum amount of money that can be earned.\n\n-----Sample Input-----\n6\n1 2 -6 4 5 3\n\n-----Sample Output-----\n12\n\nIt is optimal to smash Gem 3 and 6.",
    "solution": "[\"from collections import deque\\n \\n \\nclass Dinic:\\n    def __init__(self, n: int):\\n        \\\"\\\"\\\"\\u9802\\u70b9\\u6570\\u3092n\\u3068\\u3059\\u308b\\\"\\\"\\\"\\n        self.INF = float(\\\"inf\\\")\\n        self.n = n\\n        self.graph = [[] for _ in range(n)]\\n \\n    def add_edge(self, _from: int, to: int, capacity: int):\\n        \\\"\\\"\\\"\\u6b8b\\u4f59\\u30b0\\u30e9\\u30d5\\u3092\\u69cb\\u7bc9\\n        1. _from\\u304b\\u3089to\\u3078\\u5411\\u304b\\u3046\\u5bb9\\u91cfcapacity\\u306e\\u8fba\\u3092\\u30b0\\u30e9\\u30d5\\u306b\\u8ffd\\u52a0\\u3059\\u308b\\n        2. to\\u304b\\u3089_from\\u3078\\u5411\\u304b\\u3046\\u5bb9\\u91cf0\\u306e\\u8fba\\u3092\\u30b0\\u30e9\\u30d5\\u306b\\u8ffd\\u52a0\\u3059\\u308b\\n        \\\"\\\"\\\"\\n        forward = [to, capacity, None]\\n        forward[2] = backward = [_from, 0, forward]\\n        self.graph[_from].append(forward)\\n        self.graph[to].append(backward)\\n \\n    def bfs(self, s: int, t: int):\\n        \\\"\\\"\\\"capacity\\u304c\\u6b63\\u306e\\u8fba\\u306e\\u307f\\u3092\\u901a\\u3063\\u3066s\\u304b\\u3089t\\u306b\\u79fb\\u52d5\\u53ef\\u80fd\\u304b\\u3069\\u3046\\u304bBFS\\u3067\\u63a2\\u7d22\\n        level: s\\u304b\\u3089\\u306e\\u6700\\u77ed\\u8def\\u306e\\u9577\\u3055\\n        \\\"\\\"\\\"\\n        self.level = [-1] * self.n\\n        q = deque([s])\\n        self.level[s] = 0\\n        while q:\\n            _from = q.popleft()\\n            for to, capacity, _ in self.graph[_from]:\\n                if capacity > 0 and self.level[to] < 0:\\n                    self.level[to] = self.level[_from] + 1\\n                    q.append(to)\\n \\n    def dfs(self, _from: int, t: int, f: int) -> int:\\n        \\\"\\\"\\\"\\u6d41\\u91cf\\u304c\\u5897\\u52a0\\u3059\\u308b\\u30d1\\u30b9\\u3092DFS\\u3067\\u63a2\\u7d22\\n        BFS\\u306b\\u3088\\u3063\\u3066\\u4f5c\\u3089\\u308c\\u305f\\u6700\\u77ed\\u8def\\u306b\\u5f93\\u3063\\u3066f\\u3092\\u66f4\\u65b0\\u3059\\u308b\\n        \\\"\\\"\\\"\\n        if _from == t:\\n            return f\\n        for edge in self.itr[_from]:\\n            to, capacity, reverse_edge = edge\\n            if capacity > 0 and self.level[_from] < self.level[to]:\\n                d = self.dfs(to, t, min(f, capacity))\\n                if d > 0:\\n                    edge[1] -= d\\n                    reverse_edge[1] += d\\n                    return d\\n        return 0\\n \\n    def max_flow(self, s: int, t: int):\\n        \\\"\\\"\\\"s-t\\u30d1\\u30b9\\u4e0a\\u306e\\u6700\\u5927\\u6d41\\u3092\\u6c42\\u3081\\u308b\\n        \\u8a08\\u7b97\\u91cf: O(|E||V|^2)\\n        \\\"\\\"\\\"\\n        flow = 0\\n        while True:\\n            self.bfs(s, t)\\n            if self.level[t] < 0:\\n                break\\n            self.itr = list(map(iter, self.graph))\\n            f = self.dfs(s, t, self.INF)\\n            while f > 0:\\n                flow += f\\n                f = self.dfs(s, t, self.INF)\\n        return flow\\n\\nn = int(input())\\na = list(map(int, input().split()))\\n\\ndinic = Dinic(n + 2)\\ns = 0\\nt = n + 1\\n_sum = 0\\nfor i in range(0, n):\\n    if a[i] > 0:\\n        dinic.add_edge(s, i+1, 0)\\n        dinic.add_edge(i+1, t, a[i])\\n        _sum += a[i]\\n    elif a[i] < 0:\\n        dinic.add_edge(s, i+1, -a[i])\\n        dinic.add_edge(i+1, t, 0)\\n    else:\\n        dinic.add_edge(s, i+1, 0)\\n        dinic.add_edge(i+1, t, 0)\\n\\nfor i in range(n):\\n    num = i+1\\n    next_num = 2 * num\\n    while next_num <= n:\\n        dinic.add_edge(num, next_num, 10**18)\\n        next_num += num\\n\\nprint(_sum - dinic.max_flow(s, t))\", \"#!usr/bin/env python3\\nfrom collections import defaultdict,deque\\nfrom heapq import heappush, heappop\\nimport sys\\nimport math\\nimport bisect\\nimport random\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\ndef I(): return int(sys.stdin.readline())\\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\\ndef S():\\n    res = list(sys.stdin.readline())\\n    if res[-1] == \\\"\\\\n\\\":\\n        return res[:-1]\\n    return res\\ndef IR(n):\\n    return [I() for i in range(n)]\\ndef LIR(n):\\n    return [LI() for i in range(n)]\\ndef SR(n):\\n    return [S() for i in range(n)]\\ndef LSR(n):\\n    return [LS() for i in range(n)]\\n\\nsys.setrecursionlimit(1000000)\\nmod = 1000000007\\n\\n#A\\ndef A():\\n\\n    return\\n\\n#B\\ndef B():\\n\\n    return\\n\\n#C\\ndef C():\\n    def bfs(s,g,n):\\n        bfs_map = [-1 for i in range(n)]\\n        bfs_map[s] = 0\\n        q = deque()\\n        q.append(s)\\n        fin = False\\n        while q:\\n            x = q.popleft()\\n            for y in v[x]:\\n                if c[x][y] > 0 and bfs_map[y] < 0:\\n                    bfs_map[y] = bfs_map[x]+1\\n                    if y == g:\\n                        fin = True\\n                        break\\n                    q.append(y)\\n            if fin:\\n                break\\n\\n        if bfs_map[g] == -1:\\n            return None,0\\n        path = [None]*(bfs_map[g]+1)\\n        m = float(\\\"inf\\\")\\n        path[bfs_map[g]] = g\\n        y = g\\n        for i in range(bfs_map[g])[::-1]:\\n            for x in v[y]:\\n                if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\\n                    path[i] = x\\n                    if c[x][y] < m:\\n                        m = c[x][y]\\n                    y = x\\n                    break\\n        return path,m\\n\\n    def ford_fulkerson(s,g,c,n):\\n        f = 0\\n        while 1:\\n            p,m = bfs(s,g,n)\\n            if not m:break\\n            f += m\\n            for i in range(len(p)-1):\\n                c[p[i]][p[i+1]] -= m\\n                c[p[i+1]][p[i]] += m\\n        return f\\n\\n    n = I()\\n    a = LI()\\n    e = n+2\\n    ma = 10**9\\n    c = [[0]*e for i in range(e)]\\n    v = [[] for i in range(e)]\\n    for i in range(n):\\n        d = i+1\\n        j = 2*d\\n        c[0][d] = ma\\n        v[0].append(d)\\n        v[d].append(0)\\n        c[d][n+1] = ma-a[i]\\n        v[d].append(n+1)\\n        v[n+1].append(d)\\n        while j <= n:\\n            c[j][d] = float(\\\"inf\\\")\\n            v[j].append(d)\\n            v[d].append(j)\\n            j += d\\n    print((ma*n-ford_fulkerson(0,n+1,c,e)))\\n    return\\n\\n#D\\ndef D():\\n\\n    return\\n\\n#E\\ndef E():\\n\\n    return\\n\\n#F\\ndef F():\\n\\n    return\\n\\n#Solve\\ndef __starting_point():\\n    C()\\n\\n__starting_point()\", \"N=int(input())\\nalist=[0]+list(map(int,input().split()))\\nxlist=list(range(1,N+1))\\n#print(alist,xlist)\\n\\n# Ford-Fulkerson algorithm\\nclass FordFulkerson:\\n  def __init__(self, N):\\n    self.N = N\\n    self.G = [[] for i in range(N)]\\n\\n  def add_edge(self, fr, to, cap):\\n    forward = [to, cap, None]\\n    forward[2] = backward = [fr, 0, forward]\\n    self.G[fr].append(forward)\\n    self.G[to].append(backward)\\n\\n  def add_multi_edge(self, v1, v2, cap1, cap2):\\n    edge1 = [v2, cap1, None]\\n    edge1[2] = edge2 = [v1, cap2, edge1]\\n    self.G[v1].append(edge1)\\n    self.G[v2].append(edge2)\\n\\n  def dfs(self, v, t, f):\\n    if v == t:\\n      return f\\n    used = self.used\\n    used[v] = 1\\n    for e in self.G[v]:\\n      w, cap, rev = e\\n      if cap and not used[w]:\\n        d = self.dfs(w, t, min(f, cap))\\n        if d:\\n          e[1] -= d\\n          rev[1] += d\\n          return d\\n    return 0\\n\\n  def flow(self, s, t):\\n    flow = 0\\n    f = INF = 10**9 + 7\\n    N = self.N \\n    while f:\\n      self.used = [0]*N\\n      f = self.dfs(s, t, INF)\\n      flow += f\\n    return flow\\n\\nasum_pos=0  \\n## \\u70b9\\u6570N\\u3001\\u8fba\\u6570M\\u3001\\u59cb\\u70b9s\\u3001\\u7d42\\u70b9t\\nff = FordFulkerson(N+2)\\nfor i in range(1,N+1):\\n  a=alist[i]\\n  if a<=0:\\n    ff.add_edge(0,i,-a)\\n  else:\\n    ff.add_edge(i,N+1,a)\\n    asum_pos+=a\\n\\nfor i in range(1,N+1):\\n  for j in range(2*i,N+1,i):\\n    ff.add_edge(i,j,float(\\\"inf\\\"))\\n\\npenalty=ff.flow(0,N+1)\\nprint(asum_pos-penalty)\", \"N=int(input())\\nalist=[0]+list(map(int,input().split()))\\nxlist=list(range(1,N+1))\\n#print(alist,xlist)\\n\\n# Ford-Fulkerson algorithm\\nclass FordFulkerson:\\n  def __init__(self, vlist):\\n    self.G = {}\\n    for v in vlist:\\n      self.G[v] = []\\n\\n  def add_edge(self, fr, to, cap):\\n    forward = [to, cap, None]\\n    forward[2] = backward = [fr, 0, forward]\\n    self.G[fr].append(forward)\\n    self.G[to].append(backward)\\n\\n  def add_multi_edge(self, v1, v2, cap1, cap2):\\n    edge1 = [v2, cap1, None]\\n    edge1[2] = edge2 = [v1, cap2, edge1]\\n    self.G[v1].append(edge1)\\n    self.G[v2].append(edge2)\\n\\n  def dfs(self, v, t, f):\\n    if v == t:\\n      return f\\n    used = self.used\\n    used[v] = True\\n    for e in self.G[v]:\\n      w, cap, rev = e\\n      if cap and not used[w]:\\n        d = self.dfs(w, t, min(f, cap))\\n        if d:\\n          e[1] -= d\\n          rev[1] += d\\n          return d\\n    return 0\\n\\n  def flow(self, s, t):\\n    flow = 0\\n    f = INF = 10**9 + 7\\n    while f:\\n      self.used = {}\\n      for v in self.G:\\n        self.used[v]=False\\n      f = self.dfs(s, t, INF)\\n      flow += f\\n    return flow\\n  \\nasum_pos=0  \\n## \\u70b9\\u6570N\\u3001\\u8fba\\u6570M\\u3001\\u59cb\\u70b9s\\u3001\\u7d42\\u70b9t\\nff = FordFulkerson(range(N+2))\\nfor i in range(1,N+1):\\n  a=alist[i]\\n  if a<=0:\\n    ff.add_edge(0,i,-a)\\n  else:\\n    ff.add_edge(i,N+1,a)\\n    asum_pos+=a\\n\\nfor i in range(1,N+1):\\n  for j in range(2*i,N+1,i):\\n    ff.add_edge(i,j,float(\\\"inf\\\"))\\n\\npenalty=ff.flow(0,N+1)\\nprint(asum_pos-penalty)\", \"#  --*-coding:utf-8-*--\\n\\nINF = float('inf');\\n\\ndef fulkerson(graph, src, sink):\\n    n = len(graph)\\n\\n    matrix = [[0]*n for i in range(n)]\\n    bothDirGraph = [[] for i in range(n)]\\n\\n    for nodeId, edges in enumerate(graph):\\n        for nodeId2, flowLimit in edges:\\n            matrix[nodeId][nodeId2] = flowLimit\\n            bothDirGraph[nodeId].append(nodeId2)\\n            bothDirGraph[nodeId2].append(nodeId)\\n\\n    while True:\\n        path = findPath(bothDirGraph, matrix, src, sink)\\n\\n        if path == None:\\n            break\\n\\n        v = min(matrix[path[i]][path[i+1]] \\n                for i in range(len(path)-1))\\n\\n        for i in range(len(path)-1):\\n            node1 = path[i]\\n            node2 = path[i+1]\\n            \\n            matrix[node1][node2] -= v\\n            matrix[node2][node1] += v\\n\\n    return (sum(c for _, c in graph[src]) - \\n            sum(c for c in matrix[src]))\\n\\n\\ndef findPath(bothDirGraph, matrix, src, sink):\\n    prevs = [None]*len(matrix)\\n    q = set([src])\\n    prevs[src] = src\\n\\n    while len(q) > 0:\\n        node = q.pop()\\n\\n        for nextNode in bothDirGraph[node]:\\n            if prevs[nextNode] == None and matrix[node][nextNode] > 0:\\n                prevs[nextNode] = node\\n                \\n                if nextNode == sink:\\n                    path = []\\n                    pathNode = sink\\n\\n                    while pathNode != src:\\n                        path.append(pathNode)\\n                        pathNode = prevs[pathNode]\\n\\n                    path.append(src)\\n                    return list(reversed(path))\\n\\n                q.add(nextNode)\\n\\n    return None\\n                    \\ndef f(N, A):\\n    graph = [[] for i in range(N+2)]\\n    srcId = 0\\n    dstId = N+1\\n\\n    for nodeId, a in enumerate(A, 1):\\n        if a < 0:\\n            graph[0].append((nodeId, -a))\\n        else:\\n            graph[nodeId].append((N+1, a))\\n\\n        for k in range(2, N//nodeId+1):\\n            graph[nodeId].append((nodeId*k, INF))\\n\\n    return (sum([a for a in A if a>0]) - \\n            fulkerson(graph, 0, N+1))\\n\\ndef main():\\n    N = int(input())\\n    A = list(map(int, input().split()))\\n\\n    print((f(N, A)))\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from collections import deque\\n\\n# \\u30b0\\u30e9\\u30d5\\u306b\\u8fba\\u3092\\u8ffd\\u52a0\\u3059\\u308b\\ndef addEdge(adjL, vFr, vTo, cap):\\n    adjL[vFr].append([vTo, cap, len(adjL[vTo])])\\n    adjL[vTo].append([vFr, 0, len(adjL[vFr]) - 1]) # \\u9006\\u8fba\\n\\n\\n# Edmonds-Karp\\u6cd5\\uff08\\u6700\\u5927\\u30d5\\u30ed\\u30fc\\u3092\\u6c42\\u3081\\u308b\\uff09\\ndef Edmonds_Karp(adjL, vSt, vEn):\\n\\n    # \\u6b8b\\u4f59\\u30b0\\u30e9\\u30d5\\u306e\\u59cb\\u70b9\\u304b\\u3089\\u7d42\\u70b9\\u307e\\u3067\\u306e\\u7d4c\\u8def\\uff08\\u5897\\u52a0\\u30d1\\u30b9\\uff09\\u3092\\u3001BFS\\u3067\\u63a2\\u7d22\\u3059\\u308b\\n    def BFS(vSt, vEn):\\n        prev = [-1] * numV\\n        prev[vSt] = None\\n        iE = [-1] * numV\\n        df = 0\\n        Q = deque([(vSt, float('inf'))])\\n        while Q:\\n            vNow, fNow = Q.popleft()\\n            if vNow == vEn:\\n                # \\u7d42\\u70b9\\u306b\\u5230\\u9054\\u3057\\u305f\\u3089\\u3001\\u30eb\\u30fc\\u30d7\\u3092\\u629c\\u3051\\u308b\\n                df = fNow\\n                break\\n\\n            for i, (v2, cap, iRev) in enumerate(adjL[vNow]):\\n                if prev[v2] == -1 and cap > 0:\\n                    # \\u672a\\u63a2\\u7d22\\u306e\\u9802\\u70b9\\u3078\\u306e\\u8fba\\u306e\\u5bb9\\u91cf\\u306b\\u7a7a\\u304d\\u304c\\u3042\\u308b\\u5834\\u5408\\u3001\\u63a2\\u7d22\\u3059\\u308b\\n                    prev[v2] = vNow\\n                    iE[v2] = (i, iRev)\\n                    Q.append((v2, min(fNow, cap)))\\n\\n        if df > 0:\\n            # \\u59cb\\u70b9\\u304b\\u3089\\u7d42\\u70b9\\u307e\\u3067\\u306e\\u7d4c\\u8def\\u3092\\u9061\\u3063\\u3066\\u3001\\u8fba\\u306e\\u30d5\\u30ed\\u30fc\\u3092\\u5909\\u66f4\\u3059\\u308b\\n            vNow = vEn\\n            while vNow != vSt:\\n                v0 = prev[vNow]\\n                e, iRev = iE[vNow]\\n                adjL[v0][e][1] -= df\\n                adjL[vNow][iRev][1] += df\\n                vNow = v0\\n\\n        # \\u30d5\\u30ed\\u30fc\\u306e\\u5897\\u52a0\\u91cf\\u3092\\u8fd4\\u3059\\n        return df\\n\\n\\n    numV = len(adjL)\\n    MaximumFlow = 0\\n    while True:\\n        # \\u6b8b\\u4f59\\u30b0\\u30e9\\u30d5\\u306e\\u59cb\\u70b9\\u304b\\u3089\\u7d42\\u70b9\\u307e\\u3067\\u306e\\u7d4c\\u8def\\uff08\\u5897\\u52a0\\u30d1\\u30b9\\uff09\\u3092\\u3001BFS\\u3067\\u63a2\\u7d22\\u3059\\u308b\\n        df = BFS(vSt, vEn)\\n\\n        if df == 0:\\n            # \\u7d4c\\u8def\\u304c\\u898b\\u3064\\u304b\\u3089\\u306a\\u3044\\u5834\\u5408\\u3001\\u6700\\u5927\\u30d5\\u30ed\\u30fc\\u306e\\u5024\\u3092\\u8fd4\\u3059\\n            return MaximumFlow\\n\\n        # \\u30d5\\u30ed\\u30fc\\u3092\\u52a0\\u7b97\\u3059\\u308b\\n        MaximumFlow += df\\n\\n\\nN = int(input())\\nAs = list(map(int, input().split()))\\n\\nadjList = [[] for v in range(N + 2)]\\nfor i, A in enumerate(As, 1):\\n    if A <= 0:\\n        addEdge(adjList, 0, i, -A)\\n    else:\\n        addEdge(adjList, i, N + 1, A)\\n\\nfor i in range(1, N + 1):\\n    for j in range(2 * i, N + 1, i):\\n        addEdge(adjList, i, j, float('inf'))\\n\\n# Edmonds-Karp\\u6cd5\\uff08\\u6700\\u5927\\u30d5\\u30ed\\u30fc\\u3092\\u6c42\\u3081\\u308b\\uff09\\nmf = Edmonds_Karp(adjList, 0, N + 1)\\nprint((sum([A for A in As if A > 0]) - mf))\\n\", \"import collections\\n\\n\\nclass MaxFlow:\\n    \\\"\\\"\\\"Dinic Algorithm: find max-flow\\n       complexity: O(EV^2)\\n       used in GRL6A(AOJ)\\n    \\\"\\\"\\\"\\n    class Edge:\\n        def __init__(self, to, cap, rev):\\n            self.to, self.cap, self.rev = to, cap, rev\\n\\n    def __init__(self, V):\\n        \\\"\\\"\\\" V: the number of vertexes\\n            E: adjacency list\\n            source: start point\\n            sink: goal point\\n        \\\"\\\"\\\"\\n        self.V = V\\n        self.E = [[] for _ in range(V)]\\n\\n    def add_edge(self, fr, to, cap):\\n        self.E[fr].append(self.Edge(to, cap, len(self.E[to])))\\n        self.E[to].append(self.Edge(fr, 0, len(self.E[fr])-1))\\n\\n    def dinic(self, source, sink, INF=10**9):\\n        \\\"\\\"\\\"find max-flow\\\"\\\"\\\"\\n        maxflow = 0\\n        while True:\\n            self.bfs(source)\\n            if self.level[sink] < 0:\\n                return maxflow\\n            self.itr = [0] * self.V\\n            while True:\\n                flow = self.dfs(source, sink, INF)\\n                if flow > 0:\\n                    maxflow += flow\\n                else:\\n                    break\\n\\n    def dfs(self, vertex, sink, flow):\\n        \\\"\\\"\\\"find augmenting path\\\"\\\"\\\"\\n        if vertex == sink:\\n            return flow\\n        for i in range(self.itr[vertex], len(self.E[vertex])):\\n            self.itr[vertex] = i\\n            e = self.E[vertex][i]\\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\\n                d = self.dfs(e.to, sink, min(flow, e.cap))\\n                if d > 0:\\n                    e.cap -= d\\n                    self.E[e.to][e.rev].cap += d\\n                    return d\\n        return 0\\n\\n    def bfs(self, start):\\n        \\\"\\\"\\\"find shortest path from start\\\"\\\"\\\"\\n        que = collections.deque()\\n        self.level = [-1] * self.V\\n        que.append(start)\\n        self.level[start] = 0\\n\\n        while que:\\n            fr = que.popleft()\\n            for e in self.E[fr]:\\n                if e.cap > 0 and self.level[e.to] < 0:\\n                    self.level[e.to] = self.level[fr] + 1\\n                    que.append(e.to)\\n\\n\\ndef main():\\n    INF = 10 ** 9\\n    N = int(input())\\n    A = [int(x) for x in input().split()]\\n    flow = MaxFlow(N + 2)\\n    source, sink = N, N + 1\\n    for i, a in enumerate(A):\\n        if a >= 0:\\n            flow.add_edge(source, i, a)\\n        else:\\n            flow.add_edge(i, sink, abs(a))\\n    for i in range(1, N + 1):\\n        for j in range(i, N + 1):\\n            if j % i == 0:\\n                flow.add_edge(j - 1, i - 1, INF)\\n    cost = flow.dinic(source, sink, INF)\\n    print((sum(a for a in A if a > 0) - cost))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\\n\\nsys.setrecursionlimit(10**7)\\ninf = 10**20\\neps = 1.0 / 10**15\\nmod = 10**9+7\\n\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\\ndef LS(): return sys.stdin.readline().split()\\ndef I(): return int(sys.stdin.readline())\\ndef F(): return float(sys.stdin.readline())\\ndef S(): return input()\\ndef pf(s): return print(s, flush=True)\\ndef divisions(n):\\n    sq = int(math.sqrt(n)+1)\\n    d = collections.defaultdict(int)\\n    while n % 2 == 0:\\n        n //= 2\\n        d[2] += 1\\n    i = 3\\n    while n > 1 and sq >= i:\\n        if n % i == 0:\\n            n //= i\\n            d[i] += 1\\n        else:\\n            i += 2\\n\\n    if n > 1:\\n        d[n] += 1\\n\\n    r = [1]\\n    for k, v in d.items():\\n        for c in r[:]:\\n            for i in range(1,v+1):\\n                r.append(c*(k**i))\\n\\n    return sorted(r)\\n\\ndef main():\\n    n = I()\\n    a = LI()\\n    s = set()\\n    for i in range(n,0,-1):\\n        d = divisions(i)\\n        ld = len(d)\\n        for j in range(1,2**ld):\\n            c = []\\n            ff = True\\n            for k in range(ld):\\n                if j & (1<<k):\\n                    f = True\\n                    for e in c:\\n                        if d[k] % e == 0:\\n                            f = False\\n                            ff = False\\n                            break\\n                    if f:\\n                        c.append(d[k])\\n                if not ff:\\n                    break\\n            if ff:\\n                s.add(tuple(c + [n+1]))\\n    b = sorted(list(s), reverse=True)\\n    for c in b:\\n        t = 0\\n        for j in range(1,n+1):\\n            f = False\\n            for e in c:\\n                if j%e == 0:\\n                    f = True\\n                    break\\n            if f:\\n                t += a[j-1]\\n        if t < 0:\\n            for j in range(1,n+1):\\n                f = False\\n                for e in c:\\n                    if j%e == 0:\\n                        f = True\\n                        break\\n                if f:\\n                    a[j-1] = 0\\n\\n    return sum(a)\\n\\n\\n\\nprint(main())\\n\\n\\n\", \"from collections import deque\\n\\n\\nclass Dinic:\\n    def __init__(self, n):\\n        self.n = n\\n        self.links = [[] for _ in range(n)]\\n        self.depth = None\\n        self.progress = None\\n\\n    def add_link(self, _from, to, cap):\\n        self.links[_from].append([cap, to, len(self.links[to])])\\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\\n\\n    def bfs(self, s):\\n        depth = [-1] * self.n\\n        depth[s] = 0\\n        q = deque([s])\\n        while q:\\n            v = q.popleft()\\n            for cap, to, rev in self.links[v]:\\n                if cap > 0 and depth[to] < 0:\\n                    depth[to] = depth[v] + 1\\n                    q.append(to)\\n        self.depth = depth\\n\\n    def dfs(self, v, t, flow):\\n        if v == t:\\n            return flow\\n        for i, link in enumerate(self.links[v]):\\n            if i < self.progress[v]:\\n                continue\\n            self.progress[v] = i\\n            cap, to, rev = link\\n            if cap == 0 or self.depth[v] >= self.depth[to]:\\n                continue\\n            d = self.dfs(to, t, min(flow, cap))\\n            if d == 0:\\n                continue\\n            link[0] -= d\\n            self.links[to][rev][0] += d\\n            return d\\n        return 0\\n\\n    def max_flow(self, s, t):\\n        flow = 0\\n        while True:\\n            self.bfs(s)\\n            if self.depth[t] < 0:\\n                return flow\\n            self.progress = [0] * self.n\\n            current_flow = self.dfs(s, t, float('inf'))\\n            while current_flow > 0:\\n                flow += current_flow\\n                current_flow = self.dfs(s, t, float('inf'))\\n\\n\\nn = int(input())\\nan = list(map(int, input().split()))\\nmf = Dinic(n + 2)\\nmax_value = 0\\nfor i, a in enumerate(an):\\n    i += 1\\n    if a > 0:\\n        max_value += a\\n        mf.add_link(i, n + 1, a)\\n    else:\\n        mf.add_link(0, i, -a)\\n    for j in range(2 * i, n + 1, i):\\n        mf.add_link(i, j, float('inf'))\\nprint((max_value - mf.max_flow(0, n + 1)))\\n\", \"class Ford_Fulkerson:\\n\\n\\tdef __init__(self, v, inf=float(\\\"inf\\\")):\\n\\t\\tself.V = v\\n\\t\\tself.inf = inf\\n\\t\\tself.G = [[] for _ in range(v)]\\n\\t\\tself.used = [False for _ in range(v)]\\n\\n\\tdef addEdge(self, fm, to, cap):\\n\\t\\t'''\\n\\t\\tto:\\u884c\\u304d\\u5148\\n\\t\\tcap:\\u5bb9\\u91cf\\n\\t\\trev:\\u53cd\\u5bfe\\u5074\\u306e\\u8fba\\n\\t\\t'''\\n\\t\\tself.G[fm].append({'to':to, 'cap':cap, 'rev':len(self.G[to])})\\n\\t\\tself.G[to].append({'to':fm, 'cap':0, 'rev':len(self.G[fm])-1})\\n\\n\\n\\tdef dfs(self, v, t, f):\\n\\t\\tif v == t: return f\\n\\t\\tself.used[v] = True\\n\\n\\t\\tfor i in range(len(self.G[v])):\\n\\t\\t\\te = self.G[v][i]\\n\\t\\t\\tif self.used[e[\\\"to\\\"]] != True and e['cap'] > 0:\\n\\t\\t\\t\\td = self.dfs(e['to'], t ,min(f, e['cap']))\\n\\t\\t\\t\\tif d > 0:\\n\\t\\t\\t\\t\\te['cap'] -= d\\n\\t\\t\\t\\t\\tself.G[e['to']][e['rev']]['cap'] += d\\n\\t\\t\\t\\t\\treturn d\\n\\t\\treturn 0\\n\\n\\tdef max_flow(self,s,t):\\n\\t\\tflow = 0\\n\\t\\twhile True:\\n\\t\\t\\tself.used = [False for i in range(self.V)]\\n\\t\\t\\tf = self.dfs(s,t,self.inf)\\n\\t\\t\\tif f == 0: return flow\\n\\t\\t\\tflow += f\\n\\n\\n\\nfrom sys import stdin, setrecursionlimit\\ndef IL():return list(map(int, stdin.readline().split()))\\n \\nsetrecursionlimit(1000000)\\n\\ndef main():\\n\\tN = int(input())\\n\\ta = IL()\\n\\td = Ford_Fulkerson(N+2)\\n\\tres = 0\\n\\tfor i in range(N):\\n\\t    d.addEdge(N,i, max(0, -a[i]))\\n\\t    d.addEdge(i,N+1, max(0,a[i]))\\n\\t    res+=max(0,a[i])\\n\\t    t = 2*i+2\\n\\t    while t<=N:\\n\\t        d.addEdge(i,t-1,float('inf'))\\n\\t        t+=i+1\\n\\tprint(res-d.max_flow(N,N+1))\\n\\t\\n\\t\\ndef __starting_point(): main()\\n__starting_point()\", \"import sys\\ninput = sys.stdin.readline\\nfrom scipy.sparse.csgraph import dijkstra\\nimport numpy as np\\n\\n\\\"\\\"\\\"\\n\\u6700\\u5c0f\\u30ab\\u30c3\\u30c8\\n\\\"\\\"\\\"\\n\\nN = int(input())\\nstart = 0\\ngoal = N+1\\n\\nA = [0] + [int(x) for x in input().split()]\\n\\nINF = 10 ** 12\\ngraph = np.zeros((N+2,N+2),dtype=np.int64)\\nfor i,a in enumerate(A[1:],1):\\n    if a >= 0:\\n        graph[start,i] = a\\n    else:\\n        graph[i,goal] = -a\\nfor i in range(1,N+1):\\n    for j in range(2*i,N+1,i):\\n        if A[i] < 0 and A[j] > 0:\\n            graph[j][i] = INF\\n\\ndef max_flow(graph):\\n    flow = 0\\n    while True:\\n        dist,pred = dijkstra(graph, indices = start, return_predecessors = True, unweighted = True)\\n        if dist[goal] == np.inf:\\n            return flow\\n        path = []\\n        v = goal\\n        while True:\\n            path.append((pred[v],v))\\n            v = pred[v]\\n            if v == start:\\n                break\\n        add_flow = min(graph[x][y] for x,y in path)\\n        for x,y in path:\\n            graph[x][y] -= add_flow\\n            graph[y][x] += add_flow\\n        flow += add_flow\\n\\nanswer = sum(x for x in A if x > 0) - max_flow(graph)\\nprint(answer)\", \"# Dinic's algorithm\\nfrom collections import deque\\nclass Dinic:\\n    def __init__(self, N):\\n        self.N = N\\n        self.G = [[] for i in range(N)]\\n\\n    def add_edge(self, fr, to, cap):\\n        forward = [to, cap, None]\\n        forward[2] = backward = [fr, 0, forward]\\n        self.G[fr].append(forward)\\n        self.G[to].append(backward)\\n\\n    def add_multi_edge(self, v1, v2, cap1, cap2):\\n        edge1 = [v2, cap1, None]\\n        edge1[2] = edge2 = [v1, cap2, edge1]\\n        self.G[v1].append(edge1)\\n        self.G[v2].append(edge2)\\n\\n    def bfs(self, s, t):\\n        self.level = level = [None]*self.N\\n        deq = deque([s])\\n        level[s] = 0\\n        G = self.G\\n        while deq:\\n            v = deq.popleft()\\n            lv = level[v] + 1\\n            for w, cap, _ in G[v]:\\n                if cap and level[w] is None:\\n                    level[w] = lv\\n                    deq.append(w)\\n        return level[t] is not None\\n\\n    def dfs(self, v, t, f):\\n        if v == t:\\n            return f\\n        level = self.level\\n        for e in self.it[v]:\\n            w, cap, rev = e\\n            if cap and level[v] < level[w]:\\n                d = self.dfs(w, t, min(f, cap))\\n                if d:\\n                    e[1] -= d\\n                    rev[1] += d\\n                    return d\\n        return 0\\n\\n    def flow(self, s, t):\\n        flow = 0\\n        INF = 10**9 + 7\\n        G = self.G\\n        while self.bfs(s, t):\\n            *self.it, = map(iter, self.G)\\n            f = INF\\n            while f:\\n                f = self.dfs(s, t, INF)\\n                flow += f\\n        return flow\\n\\n\\nimport sys\\nsys.setrecursionlimit(10 ** 7)\\ninput = sys.stdin.readline\\n\\nn = int(input())\\na = list( map(int, input().split()))\\n\\nscore = 0\\nINF = float('inf')\\ngraph = Dinic(n+2)\\n\\nfor i in range(n):\\n    if a[i]>0:\\n        graph.add_edge(i+1,n+1,a[i])\\n        score += a[i]\\n    elif a[i]<0:\\n        graph.add_edge(0,i+1,-a[i])\\n\\nfor i in range(1,n//2+1):\\n    for j in range(2*i,n+1,i):\\n        graph.add_edge(i,j,INF)\\n\\nprint(score-graph.flow(0,n+1))\", \"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\\nimport time,random\\n\\nsys.setrecursionlimit(10**7)\\ninf = 10**20\\neps = 1.0 / 10**10\\nmod = 10**9+7\\nmod2 = 998244353\\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\\n\\ndef LI(): return list(map(int, sys.stdin.readline().split()))\\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\\ndef LS(): return sys.stdin.readline().split()\\ndef I(): return int(sys.stdin.readline())\\ndef F(): return float(sys.stdin.readline())\\ndef S(): return input()\\ndef pf(s): return print(s, flush=True)\\ndef pe(s): return print(str(s), file=sys.stderr)\\ndef JA(a, sep): return sep.join(map(str, a))\\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\\n\\n\\nclass Flow():\\n    def __init__(self, e, N):\\n        self.E = e\\n        self.N = N\\n\\n    def max_flow(self, s, t):\\n        r = 0\\n        e = self.E\\n\\n        def f(c, cap):\\n            v = self.v\\n            v[c] = 1\\n            if c == t:\\n                return cap\\n            for i in range(self.N):\\n                if v[i] or e[c][i] <= 0:\\n                    continue\\n                cp = min(cap, e[c][i])\\n                k = f(i, cp)\\n                if k > 0:\\n                    e[c][i] -= k\\n                    e[i][c] += k\\n                    return k\\n            return 0\\n\\n        while True:\\n            self.v = [None] * self.N\\n            fs = f(s, inf)\\n            if fs == 0:\\n                break\\n            r += fs\\n\\n        return r\\n\\n\\ndef main():\\n    n = I()\\n    a = LI()\\n\\n    s = n\\n    t = n + 1\\n    e = [[0] * (n+2) for _ in range(n+2)]\\n    for i in range(n):\\n        c = a[i]\\n        if c < 0:\\n            e[s][i] = -c\\n            ii = i + 1\\n            for j in range(ii*2, n+1, ii):\\n                e[i][j-1] = inf\\n        else:\\n            e[i][t] = c\\n\\n\\n    fl = Flow(e, n+2)\\n    r = fl.max_flow(s,t)\\n\\n    return sum(map(lambda x: max(0,x), a)) - r\\n\\n# start = time.time()\\nprint(main())\\n# pe(time.time() - start)\\n\\n\\n\\n\", \"from networkx import*\\nn,*A=map(int,open(s:=0).read().split())\\nG=DiGraph()\\nG.add_nodes_from(range(n+2))\\nfor i,a in enumerate(A,1):\\n if a>0:\\n  s+=a\\n  G.add_edge(i,n+1,capacity=a)\\n else:G.add_edge(0,i,capacity=-a)\\n for j in range(i+i,n+1,i):G.add_edge(i,j,capacity=9e20)\\nprint(s-maximum_flow(G,0,n+1)[0])\", \"#!/usr/bin/env python3\\n\\nimport math\\n\\ndef gcd(a, b):\\n    if a < b:\\n        a, b = b, a\\n    q, r = a, b\\n    while r:\\n        q, r = r, q % r\\n\\n    return q\\n\\n\\ndef lcm(a, b):\\n    return a * b // gcd(a, b)\\n\\nMAX_N = 102\\nINF = 10 ** 12\\nSRC = 0\\nDST = MAX_N - 1\\ng = [[0] * MAX_N for _ in range(MAX_N)]\\nlevel = []\\nvisited = []\\nn = 0\\n\\n\\ndef bfs(s):\\n    nonlocal level\\n\\n    level = [-1] * MAX_N\\n    level[s] = 0\\n    que = [s]\\n    while 0 < len(que):\\n        v = que.pop(0)\\n        for w in range(MAX_N):\\n            if 0 < g[v][w] and level[w] < 0:\\n                level[w] = level[v] + 1\\n                que.append(w)\\n\\n\\ndef dfs(v, t, f):\\n    nonlocal g, visited\\n\\n    if v == t:\\n        return f\\n    for w in range(visited[v], MAX_N):\\n        visited[v] = w\\n        if 0 < g[v][w] and level[v] < level[w]:\\n            d = dfs(w, t, min(f, g[v][w]))\\n            if 0 < d:\\n                g[v][w] -= d\\n                g[w][v] += d\\n                return d\\n\\n    return 0\\n\\n\\ndef max_flow():\\n    nonlocal visited\\n\\n    flow = 0\\n    while True:\\n        bfs(SRC)\\n        if level[DST] < 0:\\n            return flow\\n        visited = [0] * MAX_N\\n        f = dfs(SRC, DST, INF)\\n        while 0 < f:\\n            flow += f\\n            f = dfs(SRC, DST, INF)\\n\\n\\ndef solve(n, a):\\n    nonlocal g\\n\\n    sum_positive = sum([v for v in a if 0 < v])\\n\\n    for i in range(1, n + 1):\\n        if 0 < a[i]:\\n            g[SRC][i] = a[i]\\n        elif a[i] < 0:\\n            g[i][DST] = -a[i]\\n            for j in range(i * 2, n + 1, i):\\n                if 0 < a[j]:\\n                    g[j][i] = INF\\n\\n    return sum_positive - max_flow()\\n\\n\\ndef main():\\n    nonlocal n\\n\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    a = [0] + a\\n\\n    print((solve(n, a)))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n\\n__starting_point()\", \"# Dinic's algorithm by @yaketake08\\n# https://tjkendev.github.io/procon-library/python/max_flow/dinic.html\\nfrom collections import deque\\nINF = 10**30\\nclass Dinic:\\n\\tdef __init__(self, n):\\n\\t\\tself.n = n\\n\\t\\tself.g = [[] for i in range(n)]\\n\\n\\tdef add_edge(self, fr, to, cap):\\n\\t\\tforward = [to, cap, None]\\n\\t\\tforward[2] = backward = [fr, 0, forward]\\n\\t\\tself.g[fr].append(forward)\\n\\t\\tself.g[to].append(backward)\\n\\n\\tdef add_bidirectional_edge(self, v1, v2, cap1, cap2):\\n\\t\\tedge1 = [v2, cap1, None]\\n\\t\\tedge1[2] = edge2 = [v1, cap2, edge1]\\n\\t\\tself.g[v1].append(edge1)\\n\\t\\tself.g[v2].append(edge2)\\n\\n\\tdef bfs(self, s, t):\\n\\t\\tself.level = level = [None]*self.n\\n\\t\\tdeq = deque([s])\\n\\t\\tlevel[s] = 0\\n\\t\\tg = self.g\\n\\t\\twhile deq:\\n\\t\\t\\tv = deq.popleft()\\n\\t\\t\\tlv = level[v] + 1\\n\\t\\t\\tfor w, cap, _ in g[v]:\\n\\t\\t\\t\\tif cap and level[w] is None:\\n\\t\\t\\t\\t\\tlevel[w] = lv\\n\\t\\t\\t\\t\\tdeq.append(w)\\n\\t\\treturn level[t] is not None\\n\\n\\tdef dfs(self, v, t, f):\\n\\t\\tif v == t:\\n\\t\\t\\treturn f\\n\\t\\tlevel = self.level\\n\\t\\tfor e in self.it[v]:\\n\\t\\t\\tw, cap, rev = e\\n\\t\\t\\tif cap and level[v] < level[w]:\\n\\t\\t\\t\\td = self.dfs(w, t, min(f, cap))\\n\\t\\t\\t\\tif d:\\n\\t\\t\\t\\t\\te[1] -= d\\n\\t\\t\\t\\t\\trev[1] += d\\n\\t\\t\\t\\t\\treturn d\\n\\t\\treturn 0\\n\\n\\tdef flow(self, s, t):\\n\\t\\tflow = 0\\n\\t\\tg = self.g\\n\\t\\twhile self.bfs(s, t):\\n\\t\\t\\t*self.it, = map(iter, self.g)\\n\\t\\t\\tf = INF\\n\\t\\t\\twhile f:\\n\\t\\t\\t\\tf = self.dfs(s, t, INF)\\n\\t\\t\\t\\tflow += f\\n\\t\\treturn flow\\n\\nn = int(input())\\na = [-1] + list(map(int, input().split()))\\nd = Dinic(n+2)\\ns, t = 0, n+1\\n\\nfor i in range(1, n+1):\\n\\tif a[i] > 0:\\n\\t\\td.add_edge(i, t, a[i])\\n\\telif a[i] < 0:\\n\\t\\td.add_edge(s, i, -a[i])\\n\\tfor j in range(2*i, n+1, i):\\n\\t\\td.add_edge(i, j, INF)\\n\\nres = d.flow(s, t)\\nprint(sum([x for x in a if x>0]) - res)\", \"#!usr/bin/env python3\\nfrom collections import defaultdict,deque\\nfrom heapq import heappush, heappop\\nimport sys\\nimport math\\nimport bisect\\nimport random\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\ndef I(): return int(sys.stdin.readline())\\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\\ndef S():\\n    res = list(sys.stdin.readline())\\n    if res[-1] == \\\"\\\\n\\\":\\n        return res[:-1]\\n    return res\\ndef IR(n):\\n    return [I() for i in range(n)]\\ndef LIR(n):\\n    return [LI() for i in range(n)]\\ndef SR(n):\\n    return [S() for i in range(n)]\\ndef LSR(n):\\n    return [LS() for i in range(n)]\\n\\nsys.setrecursionlimit(1000000)\\nmod = 1000000007\\n\\n#A\\ndef A():\\n\\n    return\\n\\n#B\\ndef B():\\n\\n    return\\n\\n#C\\ndef C():\\n    def bfs(s,g,n):\\n        bfs_map = [-1 for i in range(n)]\\n        bfs_map[s] = 0\\n        q = deque()\\n        q.append(s)\\n        fin = False\\n        while q:\\n            x = q.popleft()\\n            for y in range(n):\\n                if c[x][y] > 0 and bfs_map[y] < 0:\\n                    bfs_map[y] = bfs_map[x]+1\\n                    if y == g:\\n                        fin = True\\n                        break\\n                    q.append(y)\\n            if fin:\\n                break\\n\\n        if bfs_map[g] == -1:\\n            return [None,0]\\n        path = [None for i in range(bfs_map[g]+1)]\\n        m = float(\\\"inf\\\")\\n        path[bfs_map[g]] = g\\n        y = g\\n        for i in range(bfs_map[g])[::-1]:\\n            for x in range(n+1):\\n                if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\\n                    path[i] = x\\n                    if c[x][y] < m:\\n                        m = c[x][y]\\n                    y = x\\n                    break\\n        return [path,m]\\n\\n    def ford_fulkerson(s,g,c,n):\\n        while 1:\\n            p,m = bfs(s,g,n)\\n            if not m:break\\n            for i in range(len(p)-1):\\n                c[p[i]][p[i+1]] -= m\\n                c[p[i+1]][p[i]] += m\\n        return sum(c[g])\\n\\n    n = I()\\n    a = LI()\\n    e = n+2\\n    ma = 10**9\\n    c = [[0]*e for i in range(e)]\\n    for i in range(n):\\n        d = i+1\\n        j = 2*d\\n        c[0][d] = ma\\n        c[d][n+1] = ma-a[i]\\n        while j <= n:\\n            c[j][d] = float(\\\"inf\\\")\\n            j += d\\n    print((ma*n-ford_fulkerson(0,n+1,c,e)))\\n    return\\n\\n#D\\ndef D():\\n\\n    return\\n\\n#E\\ndef E():\\n\\n    return\\n\\n#F\\ndef F():\\n\\n    return\\n\\n#Solve\\ndef __starting_point():\\n    C()\\n\\n__starting_point()\", \"from collections import deque\\n\\nN = int(input())\\nA = list(map(int,input().split()))\\n\\nP = N+2\\nes = [[] for i in range(P)] # [[to1,cap1,rev1], ...]\\n\\ndef add_edge(fr,to,cap):\\n    es[fr].append([to,cap,len(es[to])])\\n    es[to].append([fr,0,len(es[fr])-1])\\n\\nINF = float('inf')\\nscore = 0\\nfor i,a in enumerate(A):\\n    if a < 0:\\n        add_edge(0,i+1,-a)\\n    elif a > 0:\\n        add_edge(i+1,N+1,a)\\n        score += a\\nfor n in range(1,N//2+1):\\n    for m in range(2*n,N+1,n):\\n        add_edge(n,m,INF)\\n\\nlevel = [0] * P\\niters = [0] * P\\n\\ndef dinic_max_flow(s,t):\\n    nonlocal iters\\n\\n    def _bfs(s):\\n        nonlocal level\\n        level = [-1] * P\\n        level[s] = 0\\n        q = deque([s])\\n        while q:\\n            v = q.popleft()\\n            for to,cap,rev in es[v]:\\n                if cap > 0 and level[to] < 0:\\n                    level[to] = level[v] + 1\\n                    q.append(to)\\n\\n    def _dfs(v,t,f):\\n        if v == t: return f\\n        for i in range(iters[v],len(es[v])):\\n            iters[v] += 1\\n            to,cap,rev = es[v][i]\\n            if es[v][i][1] > 0 and level[v] < level[to]:\\n                d = _dfs(to,t,min(f,es[v][i][1]))\\n                if d > 0:\\n                    es[v][i][1] -= d #cap\\n                    es[to][rev][1] += d\\n                    return d\\n        return 0\\n\\n    flow = 0\\n    while True:\\n        _bfs(s)\\n        if level[t] < 0: return flow\\n        iters = [0] * P\\n        f = 0\\n        while True:\\n            f = _dfs(s,t,INF)\\n            if f <= 0: break\\n            flow += f\\n\\nprint(score - dinic_max_flow(0,N+1))\", \"N=int(input())\\nP=[int(i) for i in input().split()]\\ninf = 10**20\\ntable=[[0]*(N+2) for i in range(N+2)]\\nfor i in range(1,N+1):\\n    if P[i-1]>0:\\n        table[i][N+1]=P[i-1]\\n    else:\\n        table[0][i]=-P[i-1]\\n    for j in range(2*i,N+1,i):\\n        table[i][j]=inf\\n#print(table)\\ndef fk(x,t,f):\\n    #print(x)\\n    visit[x]=True\\n    if x==t:\\n        return f\\n    for i in range(N+2):\\n        if (not visit[i]) and table[x][i]>0:\\n            df=fk(i,t,min(f,table[x][i]))\\n            if df>0:\\n                table[x][i]-=df\\n                table[i][x]+=df\\n                return df\\n    return 0\\n\\nans=0\\nwhile True:\\n    visit=[False]*(N+2)\\n    df=fk(0,N+1,inf)\\n    if df>0:\\n        ans+=df\\n    else:\\n        break\\nnum=sum([p for p in P if p>0])\\nprint(num-ans)\", \"from collections import deque\\nclass Dinic:\\n    def __init__(self, N):\\n        self.N = N\\n        self.G = [[] for i in range(N)]\\n\\n    def add_edge(self, fr, to, cap):\\n        forward = [to, cap, None]\\n        forward[2] = backward = [fr, 0, forward]\\n        self.G[fr].append(forward)\\n        self.G[to].append(backward)\\n\\n    def add_multi_edge(self, v1, v2, cap1, cap2):\\n        edge1 = [v2, cap1, None]\\n        edge1[2] = edge2 = [v1, cap2, edge1]\\n        self.G[v1].append(edge1)\\n        self.G[v2].append(edge2)\\n\\n    def bfs(self, s, t):\\n        self.level = level = [None]*self.N\\n        deq = deque([s])\\n        level[s] = 0\\n        G = self.G\\n        while deq:\\n            v = deq.popleft()\\n            lv = level[v] + 1\\n            for w, cap, _ in G[v]:\\n                if cap and level[w] is None:\\n                    level[w] = lv\\n                    deq.append(w)\\n        return level[t] is not None\\n\\n    def dfs(self, v, t, f):\\n        if v == t:\\n            return f\\n        level = self.level\\n        for e in self.it[v]:\\n            w, cap, rev = e\\n            if cap and level[v] < level[w]:\\n                d = self.dfs(w, t, min(f, cap))\\n                if d:\\n                    e[1] -= d\\n                    rev[1] += d\\n                    return d\\n        return 0\\n\\n    def flow(self, s, t):\\n        flow = 0\\n        INF = 10**9 + 7\\n        G = self.G\\n        while self.bfs(s, t):\\n            *self.it, = list(map(iter, self.G))\\n            f = INF\\n            while f:\\n                f = self.dfs(s, t, INF)\\n                flow += f\\n        return flow\\n\\n\\nimport sys\\nsys.setrecursionlimit(10 ** 7)\\ninput = sys.stdin.readline\\n\\nn = int(input())\\na = list( map(int, input().split()))\\n\\nscore = 0\\nINF = float('inf')\\ngraph = Dinic(n+2)\\n\\nfor i in range(n):\\n    if a[i]>0:\\n        graph.add_edge(i+1,n+1,a[i])\\n        score += a[i]\\n    elif a[i]<0:\\n        graph.add_edge(0,i+1,-a[i])\\n\\nfor i in range(1,n//2+1):\\n    for j in range(2*i,n+1,i):\\n        graph.add_edge(i,j,INF)\\n\\nprint((score-graph.flow(0,n+1)))\\n\\n\\n\", \"\\n\\\"\\\"\\\"\\nhttps://atcoder.jp/contests/arc085/tasks/arc085_c\\n\\n\\\"\\\"\\\"\\n\\nfrom collections import defaultdict\\nfrom collections import deque\\n\\ndef Ford_Fulkerson_Func(s,g,lines,cost):\\n\\n    N = len(cost)\\n    ans = 0\\n    queue = deque([ [s,float(\\\"inf\\\")] ])\\n\\n\\n    ed = [True] * N\\n    ed[s] = False\\n\\n    route = [0] * N\\n    route[s] = -1\\n\\n    while queue:\\n\\n        now,flow = queue.pop()\\n        for nex in lines[now]:\\n\\n            if ed[nex]: \\n                flow = min(cost[now][nex],flow)\\n                route[nex] = now\\n                queue.append([nex,flow])\\n                ed[nex] = False\\n\\n                if nex == g:\\n                    ans += flow\\n                    break\\n            \\n        else:\\n            continue\\n        break\\n\\n    else:\\n        return False,ans\\n\\n\\n    t = g\\n    s = route[t]\\n\\n    while s != -1:\\n        cost[s][t] -= flow\\n        if cost[s][t] == 0:\\n            lines[s].remove(t)\\n\\n        if cost[t][s] == 0:\\n            lines[t].add(s)\\n        cost[t][s] += flow\\n        t = s\\n        s = route[t]\\n\\n    return True,ans\\n\\ndef Ford_Fulkerson(s,g,lines,cost):\\n\\n    ans = 0\\n\\n    while True:\\n        fl,nans = Ford_Fulkerson_Func(s,g,lines,cost)\\n\\n        if fl:\\n            ans += nans\\n            continue\\n        else:\\n            break\\n    \\n    return ans\\n\\nN = int(input())\\na = list(map(int,input().split()))\\n\\nS = N+1\\nT = N+2\\n\\nlis = defaultdict(set)\\ncost = [[0] * (N+3) for i in range(N+3)]\\n\\nfor i in range(N):\\n\\n    if a[i] > 0:\\n        lis[i+1].add(T)\\n        cost[i+1][T] += a[i]\\n\\n    elif a[i] < 0:\\n        lis[S].add(i+1)\\n        cost[S][i+1] -= a[i]\\n\\nfor i in range(1,N+1):\\n\\n    for j in range(i*2,N+1,i):\\n\\n        lis[i].add(j)\\n        cost[i][j] += float(\\\"inf\\\")\\n\\n\\nm = Ford_Fulkerson(S,T,lis,cost)\\n\\nss = 0\\nfor i in range(N):\\n    if a[i] > 0:\\n        ss += a[i]\\nprint (ss-m)\", \"class FK:\\n    def __init__(self,n):\\n        self.table=[[0]*n for i in range(n)]\\n        self.n=n\\n    \\n    def add(self,x,y,f):\\n        self.table[x][y]=f\\n        \\n    def ford(self,s,t,f):\\n        self.visit[s]=True\\n        if s==t:\\n            return f\\n        for i in range(self.n):\\n            if (not self.visit[i]) and self.table[s][i]>0:\\n                df=self.ford(i,t,min(f,self.table[s][i]))\\n                if df>0:\\n                    self.table[s][i]-=df\\n                    self.table[i][s]+=df\\n                    return df\\n        return 0\\n    \\n    def flow(self,s,t):\\n        ans=0\\n        inf=10**20\\n        while True:\\n            self.visit=[False]*(self.n)\\n            df=self.ford(s,t,inf)\\n            if df==0:\\n                break\\n            ans+=df\\n        return ans\\n\\nN=int(input())\\nP=[int(i) for i in input().split()]\\ninf=10**20\\nmaxflow=FK(N+2)\\nfor i in range(1,N+1):\\n    if P[i-1]>0:\\n        maxflow.add(i,N+1,P[i-1])\\n    else:\\n        maxflow.add(0,i,-P[i-1])\\n    for j in range(2*i,N+1,i):\\n        maxflow.add(i,j,inf)\\nans=maxflow.flow(0,N+1)\\nnum=sum([p for p in P if p>0])\\nprint(num-ans)\", \"def edmonds_karp(s, t, C):\\n    import copy\\n    import collections\\n\\n    r = copy.deepcopy(c)\\n    maxf = 0\\n\\n    while True:\\n        q, found = collections.deque(), False\\n        q.append(([S], 10 ** 15))\\n        while len(q) > 0 and not found:\\n            p, minf = q.popleft()\\n            for to, flow in list(r[p[-1]].items()):\\n                if flow == 0:\\n                    continue\\n                elif to == T:\\n                    p, minf = p + [to], min(flow, minf)\\n                    found = True\\n                    break\\n                elif not to in p:\\n                    q.append((p + [to], min(flow, minf)))\\n\\n        if not found:\\n            break\\n\\n        for i in range(len(p) - 1):\\n            r[p[i]][p[i + 1]] -= minf\\n            if p[i] in r[p[i + 1]]:\\n                r[p[i + 1]][p[i]] += minf\\n            else:\\n                r[p[i + 1]][p[i]] = minf\\n        maxf += minf\\n\\n    return maxf\\n\\n\\nN = int(input())\\nA = list(map(int, input().split()))\\n\\ngain = sum([max(a, 0) for a in A])\\n\\nS, T = 0, N + 1\\nc = [{} for i in range(N + 2)]\\nfor i in range(N):\\n    ix = i + 1\\n    if A[i] <= 0:\\n        c[S][ix] = -A[i]\\n    else:\\n        c[ix][T] = A[i]\\n\\n    for j in range(2 * ix, N + 1, ix):\\n        c[ix][j] = 10 ** 15\\n\\nprint((gain - edmonds_karp(S, T, c)))\\n\", \"import networkx as nx\\n\\nN=int(input())\\n*A,=map(int,input().split())\\nINF = 10**20\\n\\nG = nx.DiGraph()\\nG.add_nodes_from(range(N+2))\\nfor i in range(N):\\n  if A[i]<0:\\n    G.add_edge(0,i+1,capacity=-A[i])\\n    G.add_edge(i+1,N+1,capacity=0)\\n  else:\\n    G.add_edge(0,i+1,capacity=0)\\n    G.add_edge(i+1,N+1,capacity=A[i])\\n  \\nfor i in range(1,N//2+1):\\n  for j in range(i,N+1,i):\\n    G.add_edge(i,j,capacity=INF)\\n    \\nflow_value,flow_dict = nx.maximum_flow(G,0,N+1)\\nprint(sum(filter(lambda x: x>0,A))-flow_value)\", \"import networkx as nx\\n\\nn = int(input())\\nA = list(map(int, input().split()))\\nG = nx.DiGraph()\\n\\nsource = \\\"source\\\"\\nsink = \\\"sink\\\"\\n\\nfor i in range(1, n + 1):\\n    if A[i - 1] <= 0:\\n        G.add_edge(source, i, capacity=-A[i - 1])\\n    else:\\n        G.add_edge(i, sink, capacity=A[i - 1])\\n\\nfor i in range(1, n // 2 + 1):\\n    for j in range(2 * i, n + 1, i):\\n        G.add_edge(i, j)\\n\\ntry:\\n    mincut = nx.minimum_cut_value(G, source, sink)\\n    res = sum(a for a in A if a > 0)\\n    print((res - mincut))\\n\\nexcept nx.NetworkXError:\\n    print((0))\\n\", \"# -*- coding: utf-8 -*-\\n\\nimport copy\\nimport queue\\n\\nN = int(input())\\na_list = list(map(int, input().split()))\\n\\ngain = sum([a for a in a_list if a > 0])\\n\\n# Flow network\\nS = 0\\nT = N + 1\\nc = [{} for i in range(N + 2)]\\nfor i, a in enumerate(a_list):\\n    index = i + 1\\n    if a <= 0:\\n        c[S][index] = -a\\n    else:\\n        c[index][T] = a\\n    for j in range(index, N + 1, index):\\n        if not j == index:\\n            c[index][j] = 10e15\\n\\n# Residual network\\nr = copy.deepcopy(c)\\n\\n# Edmonds-Karp algorithm\\nmax_flow = 0\\nwhile True:\\n    # Find path to T\\n    q, s, p = queue.Queue(), {S}, None\\n    q.put((S,))\\n    findPath = False\\n    while not q.empty() and not findPath:\\n        cand_path = q.get(False)\\n        for to, path in list(r[cand_path[-1]].items()):\\n            if path == 0:\\n                continue\\n            elif to == T:\\n                p = cand_path + (to,)\\n                findPath = True\\n            elif not to in s:\\n                q.put(cand_path + (to,))\\n                s.add(to)\\n\\n    if not findPath:\\n        break\\n\\n    # Minimum flow\\n    min_flow = min([r[p[i]][p[i+1]] for i in range(len(p)-1)])\\n    max_flow += min_flow\\n    for i in range(len(p)-1):\\n        r[p[i]][p[i+1]] -= min_flow\\n        if p[i] in r[p[i+1]]:\\n            r[p[i+1]][p[i]] += min_flow\\n        else:\\n            r[p[i+1]][p[i]] = min_flow\\n\\nprint((gain - max_flow))\\n\", \"import collections\\nclass Dinic:\\n    def __init__(self, n):\\n        self.n = n\\n        self.g = [[] for i in range(n)]\\n    def add_edge(self, fr, to, cap):\\n        self.g[fr].append([to, cap, len(self.g[to])])\\n        self.g[to].append([fr, 0, len(self.g[fr])-1])\\n    def add_multi_edge(self, v1, v2, cap1, cap2):\\n        self.g[v1].append([v2, cap1, len(self.g[v2])])\\n        self.g[v2].append([v1, cap2, len(self.g[v1])-1])\\n    def bfs(self, s):\\n        level = [-1]*self.n\\n        deq = collections.deque()\\n        level[s] = 0\\n        deq.append(s)\\n        while deq:\\n            v = deq.popleft()\\n            for e in self.g[v]:\\n                if e[1]>0 and level[e[0]]<0:\\n                    level[e[0]] = level[v] + 1\\n                    deq.append(e[0])\\n        self.level = level\\n    def dfs(self, v, t, f):\\n        if v==t: return f\\n        es = self.g[v]\\n        level = self.level\\n        for i in range(self.it[v], len(self.g[v])):\\n            e = es[i]\\n            if e[1]>0 and level[v]<level[e[0]]:\\n                d = self.dfs(e[0], t, min(f, e[1]))\\n                if d>0:\\n                    e[1] -= d\\n                    self.g[e[0]][e[2]][1] += d\\n                    self.it[v] = i\\n                    return d\\n        self.it[v] = len(self.g[v])\\n        return 0\\n    def max_flow(self, s, t):\\n        flow = 0\\n        while True:\\n            self.bfs(s)\\n            if self.level[t]<0: break\\n            self.it = [0]*self.n\\n            while True:\\n                f = self.dfs(s, t, 10**9+7)\\n                if f>0:\\n                    flow += f\\n                else:\\n                    break\\n        return flow\\n\\nN = int(input())\\n*A, = map(int, input().split())\\ndinic = Dinic(N+2)\\n\\nINF = 10**18\\n\\nsu = 0\\nfor x in range(1, N+1):\\n    a = A[x-1]\\n    if a > 0:\\n        su += a\\n        dinic.add_edge(0, x+1, a)\\n    elif a < 0:\\n        dinic.add_edge(x+1, 1, -a)\\n\\nfor x in range(1, N+1):\\n    for y in range(x+x, N+1, x):\\n        dinic.add_edge(y+1, x+1, INF)\\n\\nprint(su - dinic.max_flow(0, 1))\", \"import sys, re\\nfrom collections import deque, defaultdict, Counter\\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\\nfrom operator import itemgetter, mul\\nfrom copy import deepcopy\\nfrom string import ascii_lowercase, ascii_uppercase, digits\\nfrom bisect import bisect, bisect_left\\nfrom fractions import gcd\\nfrom heapq import heappush, heappop\\nfrom functools import reduce\\nfrom scipy.sparse import csr_matrix\\nfrom scipy.sparse.csgraph import floyd_warshall\\ndef input(): return sys.stdin.readline().strip()\\ndef INT(): return int(input())\\ndef MAP(): return list(map(int, input().split()))\\ndef LIST(): return list(map(int, input().split()))\\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\\nsys.setrecursionlimit(10 ** 9)\\nINF = 10**10\\nmod = 10 ** 9 + 7\\n\\nclass Dinic:\\n    def __init__(self, v, inf=10**10):\\n        self.v = v\\n        self.inf = inf\\n        self.G = [[] for _ in range(v)]\\n        self.level = [-1]*v  # \\u6df1\\u3055\\n        self.ite = [0]*v  # DFS\\u3067\\u306e\\u63a2\\u7d22\\u304c\\u6e08\\u3093\\u3067\\u3044\\u308b\\u304b\\n    def add_edge(self, fr, to, cap):\\n        self.G[fr].append([to, cap, len(self.G[to])])\\n        self.G[to].append([fr, 0, len(self.G[fr])-1])\\n    def bfs(self, s):  # BFS\\u3067\\u6df1\\u3055\\u6c7a\\u5b9a,s\\u304cstart\\n        self.level = [-1]*self.v  # \\u5fc5\\u8981\\n        self.level[s] = 0\\n        Q = deque()\\n        Q.append(s)\\n        while Q:\\n            v = Q.popleft()\\n            for i in range(len(self.G[v])):\\n                e = self.G[v][i]\\n                if e[1]>0 and self.level[e[0]]<0: ###capacity>0\\u304b\\u3064to\\u306e\\u6df1\\u3055\\u672a\\u5b9a\\n                    self.level[e[0]] = self.level[v]+1\\n                    Q.append(e[0])\\n    def dfs(self, v, t, f):  # DFS\\u3067\\u5897\\u52a0\\u30d1\\u30b9\\u63a2\\u7d22,v\\u958b\\u59cb\\u3001t\\u7d42\\u70b9\\u3001\\u7dcf\\u30d5\\u30ed\\u30fcf\\n        if v==t:\\n            return f\\n        for i in range(self.ite[v], len(self.G[v])):\\n            self.ite[v] = i\\n            e = self.G[v][i]\\n            if e[1]>0 and self.level[v]<self.level[e[0]]:\\n                d = self.dfs(e[0], t, min(f, e[1]))\\n                if d>0:\\n                    e[1] -= d  # cap\\u6e1b\\u5c11\\n                    self.G[e[0]][e[2]][1] += d  # \\u9006\\u8fba\\u306ecap\\u5897\\u52a0\\n                    return d\\n        return 0\\n    def max_flow(self, s, t):\\n        flow = 0\\n        while True:\\n            self.bfs(s)\\n            if self.level[t]<0:\\n                return flow\\n            self.ite = [0]*self.v  # DFS\\u3067\\u306e\\u63a2\\u7d22\\u304c\\u6e08\\u3093\\u3067\\u3044\\u308b\\u304b\\u5426\\u304b\\n            f = self.dfs(s,t,self.inf)\\n            while f>0:\\n                flow += f\\n                f = self.dfs(s,t,self.inf)\\n\\nN = INT()\\na = LIST()\\n\\nD = Dinic(N+2)\\ns = 0\\nt = N+1\\n\\nrw = 0\\n\\nfor i, x in enumerate(a):\\n    if x <= 0:  # \\u305d\\u306e\\u307e\\u307e\\u7f70\\u91d1\\n        D.add_edge(s, i+1, -x)\\n    elif x > 0:  # \\u3042\\u3089\\u304b\\u3058\\u3081x\\u3082\\u3089\\u3063\\u3066\\u304a\\u304d\\uff0c\\u3053\\u308c\\u304c\\u7834\\u58ca\\u3055\\u308c\\u308b\\u3068x\\u306e\\u7f70\\u91d1\\uff0c\\n        D.add_edge(i+1, t, x)\\n        rw += x\\n    for j in range(2*(i+1), N+1, i+1):  # \\u300ci\\u304c\\u7834\\u58ca\\u304b\\u3064j\\u304c\\u975e\\u7834\\u58ca\\u300d\\u306f\\u3060\\u3081\\n        D.add_edge(i+1, j, INF)\\n\\nprint((rw - D.max_flow(s, t)))\\n\", \"from typing import NamedTuple, Optional, List, cast\\n\\n\\nclass MFGraph:\\n    class Edge(NamedTuple):\\n        src: int\\n        dst: int\\n        cap: int\\n        flow: int\\n\\n    class _Edge:\\n        def __init__(self, dst: int, cap: int) -> None:\\n            self.dst = dst\\n            self.cap = cap\\n            self.rev: Optional[MFGraph._Edge] = None\\n\\n    def __init__(self, n: int) -> None:\\n        self._n = n\\n        self._g: List[List[MFGraph._Edge]] = [[] for _ in range(n)]\\n        self._edges: List[MFGraph._Edge] = []\\n\\n    def add_edge(self, src: int, dst: int, cap: int) -> int:\\n        assert 0 <= src < self._n\\n        assert 0 <= dst < self._n\\n        assert 0 <= cap\\n        m = len(self._edges)\\n        e = MFGraph._Edge(dst, cap)\\n        re = MFGraph._Edge(src, 0)\\n        e.rev = re\\n        re.rev = e\\n        self._g[src].append(e)\\n        self._g[dst].append(re)\\n        self._edges.append(e)\\n        return m\\n\\n    def get_edge(self, i: int) -> Edge:\\n        assert 0 <= i < len(self._edges)\\n        e = self._edges[i]\\n        re = cast(MFGraph._Edge, e.rev)\\n        return MFGraph.Edge(\\n            re.dst,\\n            e.dst,\\n            e.cap + re.cap,\\n            re.cap\\n        )\\n\\n    def edges(self) -> List[Edge]:\\n        return [self.get_edge(i) for i in range(len(self._edges))]\\n\\n    def change_edge(self, i: int, new_cap: int, new_flow: int) -> None:\\n        assert 0 <= i < len(self._edges)\\n        assert 0 <= new_flow <= new_cap\\n        e = self._edges[i]\\n        e.cap = new_cap - new_flow\\n        assert e.rev is not None\\n        e.rev.cap = new_flow\\n\\n    def flow(self, s: int, t: int, flow_limit: Optional[int] = None) -> int:\\n        assert 0 <= s < self._n\\n        assert 0 <= t < self._n\\n        assert s != t\\n        if flow_limit is None:\\n            flow_limit = cast(int, sum(e.cap for e in self._g[s]))\\n\\n        current_edge = [0] * self._n\\n        level = [0] * self._n\\n\\n        def fill(arr: List[int], value: int) -> None:\\n            for i in range(len(arr)):\\n                arr[i] = value\\n\\n        def bfs() -> bool:\\n            fill(level, self._n)\\n            queue = []\\n            q_front = 0\\n            queue.append(s)\\n            level[s] = 0\\n            while q_front < len(queue):\\n                v = queue[q_front]\\n                q_front += 1\\n                next_level = level[v] + 1\\n                for e in self._g[v]:\\n                    if e.cap == 0 or level[e.dst] <= next_level:\\n                        continue\\n                    level[e.dst] = next_level\\n                    if e.dst == t:\\n                        return True\\n                    queue.append(e.dst)\\n            return False\\n\\n        def dfs(lim: int) -> int:\\n            stack = []\\n            edge_stack: List[MFGraph._Edge] = []\\n            stack.append(t)\\n            while stack:\\n                v = stack[-1]\\n                if v == s:\\n                    flow = min(lim, min(e.cap for e in edge_stack))\\n                    for e in edge_stack:\\n                        e.cap -= flow\\n                        assert e.rev is not None\\n                        e.rev.cap += flow\\n                    return flow\\n                next_level = level[v] - 1\\n                while current_edge[v] < len(self._g[v]):\\n                    e = self._g[v][current_edge[v]]\\n                    re = cast(MFGraph._Edge, e.rev)\\n                    if level[e.dst] != next_level or re.cap == 0:\\n                        current_edge[v] += 1\\n                        continue\\n                    stack.append(e.dst)\\n                    edge_stack.append(re)\\n                    break\\n                else:\\n                    stack.pop()\\n                    if edge_stack:\\n                        edge_stack.pop()\\n                    level[v] = self._n\\n            return 0\\n\\n        flow = 0\\n        while flow < flow_limit:\\n            if not bfs():\\n                break\\n            fill(current_edge, 0)\\n            while flow < flow_limit:\\n                f = dfs(flow_limit - flow)\\n                flow += f\\n                if f == 0:\\n                    break\\n        return flow\\n\\n    def min_cut(self, s: int) -> List[bool]:\\n        visited = [False] * self._n\\n        stack = [s]\\n        visited[s] = True\\n        while stack:\\n            v = stack.pop()\\n            for e in self._g[v]:\\n                if e.cap > 0 and not visited[e.dst]:\\n                    visited[e.dst] = True\\n                    stack.append(e.dst)\\n        return visited\\n\\n\\nimport sys\\ninput = sys.stdin.readline\\nn = int(input())\\nA = tuple(map(int, input().split()))\\nG = MFGraph(n+2)\\ns = 0\\nt = n+1\\nINF = 10**18\\nans = 0\\nfor i, a in enumerate(A, 1):\\n    if a < 0:\\n        G.add_edge(s, i, -a)\\n    if a > 0:\\n        G.add_edge(i, t, a)\\n        ans += a\\n    for j in range(2*i, n+1, i):\\n        G.add_edge(i, j, INF)\\nans -= G.flow(s, t)\\nprint(ans)\", \"import sys\\nfrom collections import deque\\nread = sys.stdin.read\\nreadline = sys.stdin.readline\\nreadlines = sys.stdin.readlines\\n\\nclass EDOMONDS_KARP():\\n    def __init__(self, N, s, t):\\n        self.N = N\\n        self.s = s\\n        self.t = t\\n        self.cap = [[0]*N for _ in range(N)]\\n        self.link = [[] for _ in range(N)]\\n\\n    def add_edge(self, u, v, c):\\n        self.cap[u][v] = c\\n        self.link[u].append(v)\\n        self.link[v].append(u)\\n\\n    def max_flow(self):\\n        N = self.N\\n        s = self.s\\n        t = self.t\\n        f = 0\\n        flow = [[0]*N for _ in range(N)]\\n        while True:\\n            m, prev = self.bfs(flow)\\n            if m == 0:\\n                break\\n            f += m\\n            v = t\\n            while v != s:\\n                u = prev[v]\\n                flow[u][v] += m\\n                flow[v][u] -=m\\n                v = u\\n        return (f, flow)\\n\\n    def bfs(self, flow):\\n        N = self.N\\n        s = self.s\\n        t = self.t\\n        cap = self.cap\\n        link = self.link\\n        prev = [-1]*N; prev[s] = -2\\n        m = [0]*N; m[s] = float('inf')\\n        q = deque([s])\\n        while q:\\n            u = q.popleft()\\n            for v in link[u]:\\n                if cap[u][v] - flow[u][v] > 0 and prev[v] == -1:\\n                    prev[v] = u\\n                    m[v] = min(m[u], cap[u][v] - flow[u][v])\\n                    if v != t:\\n                        q.append(v)\\n                    else:\\n                        return (m[t], prev)\\n        return (0, prev)\\n\\ndef main():\\n    INF = float('inf')\\n\\n    N = int(readline())\\n    A = list(map(int, readline().split()))\\n\\n    S, T = 0, N + 1\\n    EK = EDOMONDS_KARP(N + 2, S, T)\\n    add = EK.add_edge\\n    for i in range(1, N + 1):\\n        a = A[i - 1]\\n        if a <= 0:\\n            add(S, i, -a)\\n        else:\\n            add(i, T, a)\\n        for j in range(2, N // i + 1):\\n            add(i, i*j, INF)\\n    f, _ = EK.max_flow()\\n    print((sum([x for x in A if x > 0]) - f))\\n\\ndef __starting_point():\\n   main()\\n\\n__starting_point()\", \"from collections import deque\\n\\nN = int(input())\\nA = list(map(int,input().split()))\\n\\nP = N+2\\nes = [[] for i in range(P)] # [[to1,cap1,rev1], ...]\\n\\ndef add_edge(fr,to,cap):\\n    es[fr].append([to,cap,len(es[to])])\\n    es[to].append([fr,0,len(es[fr])-1])\\n\\nINF = float('inf')\\nscore = 0\\nfor i,a in enumerate(A):\\n    if a > 0:\\n        add_edge(0,i+1,a)\\n        score += a\\n    elif a < 0:\\n        add_edge(i+1,N+1,-a)\\nfor n in range(1,N//2+1):\\n    for m in range(2*n,N+1,n):\\n        add_edge(m,n,INF)\\n\\nlevel = [0] * P\\niters = [0] * P\\n\\ndef dinic_max_flow(s,t):\\n    nonlocal iters\\n\\n    def _bfs(s):\\n        nonlocal level\\n        level = [-1] * P\\n        level[s] = 0\\n        q = deque([s])\\n        while q:\\n            v = q.popleft()\\n            for to,cap,rev in es[v]:\\n                if cap > 0 and level[to] < 0:\\n                    level[to] = level[v] + 1\\n                    q.append(to)\\n\\n    def _dfs(v,t,f):\\n        if v == t: return f\\n        for i in range(iters[v],len(es[v])):\\n            iters[v] += 1\\n            to,cap,rev = es[v][i]\\n            if es[v][i][1] > 0 and level[v] < level[to]:\\n                d = _dfs(to,t,min(f,es[v][i][1]))\\n                if d > 0:\\n                    es[v][i][1] -= d #cap\\n                    es[to][rev][1] += d\\n                    return d\\n        return 0\\n\\n    flow = 0\\n    while True:\\n        _bfs(s)\\n        if level[t] < 0: return flow\\n        iters = [0] * P\\n        f = 0\\n        while True:\\n            f = _dfs(s,t,INF)\\n            if f <= 0: break\\n            flow += f\\n\\nprint(score - dinic_max_flow(0,N+1))\", \"def edmonds_karp(s, t, C):\\n    '''\\n    s, t: start, target (integer)\\n    C: Array of dict ([from][to] -> length)\\n    ret: maximum_flow (integer)\\n    '''\\n    import copy\\n    import collections\\n\\n    r = copy.deepcopy(c)  # Residual network\\n    maxf = 0\\n\\n    while True:\\n        q, found = collections.deque(), False\\n        q.append(([s], 10 ** 15))\\n        while len(q) > 0 and not found:\\n            p, minf = q.popleft()\\n            for to, flow in list(r[p[-1]].items()):\\n                if flow == 0:\\n                    continue\\n                elif to == t:\\n                    p, minf = p + [to], min(flow, minf)\\n                    found = True\\n                    break\\n                elif not to in p:\\n                    q.append((p + [to], min(flow, minf)))\\n\\n        if not found:\\n            break\\n\\n        for i in range(len(p) - 1):\\n            r[p[i]][p[i + 1]] -= minf\\n            if p[i] in r[p[i + 1]]:\\n                r[p[i + 1]][p[i]] += minf\\n            else:\\n                r[p[i + 1]][p[i]] = minf\\n        maxf += minf\\n\\n    return maxf\\n\\n\\nN = int(input())\\nA = list(map(int, input().split()))\\n\\ngain = sum([max(a, 0) for a in A])\\n\\n# Flow network\\nS, T = 0, N + 1\\nc = [{} for i in range(N + 2)]\\nfor i in range(N):\\n    ix = i + 1\\n    if A[i] <= 0:\\n        c[S][ix] = -A[i]\\n    else:\\n        c[ix][T] = A[i]\\n\\n    for j in range(2 * ix, N + 1, ix):\\n        c[ix][j] = 10 ** 15\\n\\nprint((gain - edmonds_karp(S, T, c)))\\n\", \"import sys\\ninput=sys.stdin.readline\\nsys.setrecursionlimit(10**9)\\nfrom collections import deque\\n\\nclass Dinic:\\n    def __init__(self,n,edges):\\n        self.n=n\\n        self.edges=[[] for _ in range(n)]\\n        self.iter=[0]*n\\n        self.level=None\\n        self.graph(edges)\\n    def graph(self,E):\\n        edges=self.edges\\n        for fr,to,cap in E:\\n            edges[fr].append([to,cap,len(edges[to])])\\n            edges[to].append([fr,0,len(edges[fr])-1])\\n    def maxflow(self,source,sink):\\n        max_flow=0\\n        while True:\\n            self.bfs(source)\\n            if self.level[sink]<0:\\n                return max_flow\\n            self.iter=[0]*self.n\\n            flow=self.dfs(source,sink,float('inf'))\\n            while flow:\\n                max_flow+=flow\\n                flow=self.dfs(source,sink,float('inf'))\\n    def bfs(self,source):\\n        edges=self.edges\\n        level=[-1]*self.n\\n        level[source]=0\\n        q=deque([source])\\n        while q:\\n            fr=q.popleft()\\n            for to,cap,_ in edges[fr]:\\n                if cap>0>level[to]:\\n                    level[to]=level[fr]+1\\n                    q.append(to)\\n        self.level=level\\n    def dfs(self,source,sink,flow):\\n        if source==sink:\\n            return flow\\n        while self.iter[source]<len(self.edges[source]):\\n            to,cap,rev=self.edges[source][self.iter[source]]\\n            if cap>0 and self.level[source]<self.level[to]:\\n                f=self.dfs(to,sink,min(flow,cap))\\n                if f:\\n                    self.edges[source][self.iter[source]][1]-=f\\n                    self.edges[to][rev][1]+=f\\n                    return f\\n            self.iter[source]+=1\\n        return 0\\n\\nn=int(input())\\nA=list(map(int,input().split()))\\nEdges=[]\\ns=0\\nfor i in range(n):\\n    if A[i]<=0:\\n        Edges.append((0,i+1,-A[i]))\\n    else:\\n        s+=A[i]\\n        Edges.append((i+1,n+1,A[i]))\\n    for j in range(2*(i+1),n+1,i+1):\\n        Edges.append((i+1,j,float('inf')))\\ndinic=Dinic(n+2,Edges)\\nprint(s-dinic.maxflow(0,n+1))\", \"import copy\\nimport collections\\n\\nN = int(input())\\nA = list(map(int, input().split()))\\n\\ngain = sum([max(a, 0) for a in A])\\n\\n# Flow network\\nS, T = 0, N + 1\\nc = [{} for i in range(N + 2)]\\nfor i in range(N):\\n    ix = i + 1\\n    if A[i] <= 0:\\n        c[S][ix] = -A[i]\\n    else:\\n        c[ix][T] = A[i]\\n\\n    for j in range(2 * ix, N + 1, ix):\\n        c[ix][j] = 10e15\\n\\n# Residual network\\nr = copy.deepcopy(c)\\n\\n# Edmonds-Karp algorithm\\nmax_flow = 0\\nwhile True:\\n    # Find path to T\\n    q, s, p = collections.deque(), {S}, None\\n    q.append((S,))\\n    findPath = False\\n    while not len(q) == 0 and not findPath:\\n        cand_path = q.popleft()\\n        for to, path in list(r[cand_path[-1]].items()):\\n            if path == 0:\\n                continue\\n            elif to == T:\\n                p = cand_path + (to,)\\n                findPath = True\\n            elif not to in s:\\n                q.append(cand_path + (to,))\\n                s.add(to)\\n\\n    if not findPath:\\n        break\\n\\n    # Minimum flow\\n    min_flow = min([r[p[i]][p[i + 1]] for i in range(len(p) - 1)])\\n    max_flow += min_flow\\n    for i in range(len(p) - 1):\\n        r[p[i]][p[i + 1]] -= min_flow\\n        if p[i] in r[p[i + 1]]:\\n            r[p[i + 1]][p[i]] += min_flow\\n        else:\\n            r[p[i + 1]][p[i]] = min_flow\\n\\nprint((gain - max_flow))\\n\", \"# \\u30b0\\u30e9\\u30d5\\u306b\\u8fba\\u3092\\u8ffd\\u52a0\\u3059\\u308b\\ndef addEdge(adjL, vFr, vTo, cap):\\n    adjL[vFr].append([vTo, cap, len(adjL[vTo])])\\n    adjL[vTo].append([vFr, 0, len(adjL[vFr]) - 1]) # \\u9006\\u8fba\\n\\n\\n# Ford-Fulkerson\\u6cd5\\uff08\\u6700\\u5927\\u30d5\\u30ed\\u30fc\\u3092\\u6c42\\u3081\\u308b\\uff09\\ndef Ford_Fulkerson(adjL, vSt, vEn):\\n\\n    # \\u6b8b\\u4f59\\u30b0\\u30e9\\u30d5\\u306e\\u59cb\\u70b9\\u304b\\u3089\\u7d42\\u70b9\\u307e\\u3067\\u306e\\u7d4c\\u8def\\uff08\\u5897\\u52a0\\u30d1\\u30b9\\uff09\\u3092\\u3001DFS\\u3067\\u63a2\\u7d22\\u3059\\u308b\\n    def DFS(vNow, vEn, fNow):\\n        if vNow == vEn:\\n            # \\u7d42\\u70b9\\u306b\\u5230\\u9054\\u3057\\u305f\\u3089\\u3001\\u30d5\\u30ed\\u30fc\\u306e\\u5897\\u52a0\\u91cf\\u3092\\u8fd4\\u3059\\n            return fNow\\n\\n        used[vNow] = True\\n\\n        for i, (v2, cap, iRev) in enumerate(adjL[vNow]):\\n            if not used[v2] and cap > 0:\\n                # \\u672a\\u63a2\\u7d22\\u306e\\u9802\\u70b9\\u3078\\u306e\\u8fba\\u306e\\u5bb9\\u91cf\\u306b\\u7a7a\\u304d\\u304c\\u3042\\u308b\\u5834\\u5408\\u3001\\u63a2\\u7d22\\u3059\\u308b\\n                df = DFS(v2, vEn, min(fNow, cap))\\n                if df > 0:\\n                    # \\u59cb\\u70b9\\u304b\\u3089\\u7d42\\u70b9\\u307e\\u3067\\u306e\\u7d4c\\u8def\\u3092\\u9061\\u3063\\u3066\\u3001\\u8fba\\u306e\\u30d5\\u30ed\\u30fc\\u3092\\u5909\\u66f4\\u3059\\u308b\\n                    adjL[vNow][i][1] -= df\\n                    adjL[v2][iRev][1] += df\\n                    return df\\n\\n        # \\u73fe\\u5728\\u306e\\u9802\\u70b9\\u304b\\u3089\\u306e\\u63a2\\u7d22\\u5148\\u304c\\u306a\\u3044\\u5834\\u5408\\u3001\\u30bc\\u30ed\\u3092\\u8fd4\\u3059\\n        return 0\\n\\n\\n    numV = len(adjL)\\n    MaximumFlow = 0\\n    while True:\\n        # \\u6b8b\\u4f59\\u30b0\\u30e9\\u30d5\\u306e\\u59cb\\u70b9\\u304b\\u3089\\u7d42\\u70b9\\u307e\\u3067\\u306e\\u7d4c\\u8def\\uff08\\u5897\\u52a0\\u30d1\\u30b9\\uff09\\u3092\\u3001DFS\\u3067\\u63a2\\u7d22\\u3059\\u308b\\n        used = [False] * numV\\n        df = DFS(vSt, vEn, float('inf'))\\n\\n        if df == 0:\\n            # \\u7d4c\\u8def\\u304c\\u898b\\u3064\\u304b\\u3089\\u306a\\u3044\\u5834\\u5408\\u3001\\u6700\\u5927\\u30d5\\u30ed\\u30fc\\u306e\\u5024\\u3092\\u8fd4\\u3059\\n            return MaximumFlow\\n\\n        # \\u30d5\\u30ed\\u30fc\\u3092\\u52a0\\u7b97\\u3059\\u308b\\n        MaximumFlow += df\\n\\n\\nN = int(input())\\nAs = list(map(int, input().split()))\\n\\nadjList = [[] for v in range(N + 2)]\\nfor i, A in enumerate(As, 1):\\n    if A <= 0:\\n        addEdge(adjList, 0, i, -A)\\n    else:\\n        addEdge(adjList, i, N + 1, A)\\n\\nfor i in range(1, N + 1):\\n    for j in range(2 * i, N + 1, i):\\n        addEdge(adjList, i, j, float('inf'))\\n\\n# Ford-Fulkerson\\u6cd5\\uff08\\u6700\\u5927\\u30d5\\u30ed\\u30fc\\u3092\\u6c42\\u3081\\u308b\\uff09\\nmf = Ford_Fulkerson(adjList, 0, N + 1)\\nprint((sum([A for A in As if A > 0]) - mf))\\n\", \"import collections\\nclass Dinic:\\n    def __init__(self, vnum):\\n        self.edge = [[] for i in range(vnum)]\\n        self.n = vnum\\n        self.inf = float('inf')\\n    def addedge(self, st, en, c):\\n        self.edge[st].append([en, c, len(self.edge[en])])\\n        self.edge[en].append([st, 0, len(self.edge[st])-1])\\n    def bfs(self, vst):\\n        dist = [-1]*self.n\\n        dist[vst] = 0\\n        Q = collections.deque([vst])\\n        while Q:\\n            nv = Q.popleft()\\n            for vt, c, r in self.edge[nv]:\\n                if dist[vt] == -1 and c > 0:\\n                    dist[vt] = dist[nv] + 1\\n                    Q.append(vt)\\n        self.dist = dist\\n    def dfs(self, nv, en, nf):\\n        nextv = self.nextv\\n        if nv == en:\\n            return nf\\n        dist = self.dist\\n        ist = nextv[nv]\\n        for i, (vt, c, r) in enumerate(self.edge[nv][ist:], ist):\\n            if dist[nv] < dist[vt] and c > 0:\\n                df = self.dfs(vt, en, min(nf, c))\\n                if df > 0:\\n                    self.edge[nv][i][1] -= df\\n                    self.edge[vt][r][1] += df\\n                    return df\\n            nextv[nv] += 1\\n        return 0\\n    def getmf(self, st, en):\\n        mf = 0\\n        while True:\\n            self.bfs(st)\\n            if self.dist[en] == -1:\\n                break\\n            self.nextv = [0]*self.n\\n            while True:\\n                fl = self.dfs(st, en, self.inf)\\n                if fl > 0:\\n                    mf += fl\\n                else:\\n                    break\\n        return mf\\n\\ndef inpl(): return [int(i) for i in input().split()]\\nN = int(input())\\na = inpl()\\nK = Dinic(N+2)\\ninf = float('inf')\\nfor i, v in enumerate(a,1):\\n    if v > 0:\\n        K.addedge(i, N+1, v)\\n    else:\\n        K.addedge(0, i, -v)\\nfor i in range(1,N+1):\\n    for j in range(2*i, N+1, i):\\n        K.addedge(i, j, inf)\\n\\nprint(sum([i for i in a if i > 0]) - K.getmf(0, N+1))\", \"from collections import deque\\nimport sys\\nsys.setrecursionlimit(200000)\\nn = int(input())\\nhouseki = list(map(int,input().split()))\\ng = [[] for i in range(n+2)]\\nINF = float(\\\"inf\\\")\\nMAX = 0\\nfor i in range(n):\\n  if houseki[i] <= 0:\\n    g[0].append([i+1,-houseki[i],len(g[i+1])])\\n    g[i+1].append([0,0,len(g[0])-1])\\n  else:\\n    g[n+1].append([i+1,0,len(g[i+1])])\\n    g[i+1].append([n+1,houseki[i],len(g[n+1])-1])\\n    MAX += houseki[i]\\n  j = (i+1)*2\\n  while j <= n:\\n    g[i+1].append([j,INF,len(g[j])])\\n    g[j].append([i+1,0,len(g[i+1])-1])\\n    j += i+1\\ndef bfs(s,t):\\n  nonlocal level\\n  que = deque([s])\\n  level[s] = 0\\n  while que:\\n    v = que.popleft()\\n    lv = level[v] +1\\n    for y, cap, rev in g[v]:\\n      if cap and level[y] is None:\\n        level[y] = lv\\n        que.append(y)\\n  return level[t] if level[t] else 0\\ndef dfs(x,t,f):\\n  if x == t:\\n    return f\\n  for j in range(it[x],len(g[x])):\\n    it[x] = j\\n    y, cap, rev = g[x][j]\\n    if cap and level[x] < level[y]:\\n      d = dfs(y,t,min(f,cap))\\n      if d:\\n        g[x][j][1] -= d\\n        g[y][rev][1] += d\\n        return d\\n  return 0\\n \\nflow = 0\\nf = INF = float(\\\"inf\\\")\\nlevel = [None]*(n+2)\\nwhile bfs(0,n+1):\\n  it = [0]* (n+2)\\n  f = INF\\n  while f:\\n    f = dfs(0,n+1,INF)\\n    flow += f\\n  level = [None]*(n+2)\\nprint(MAX-flow)\", \"# Dinic's algorithm\\nfrom collections import deque\\nclass Dinic:\\n    def __init__(self, N):\\n        self.N = N\\n        self.G = [[] for i in range(N)]\\n\\n    def add_edge(self, fr, to, cap):\\n        forward = [to, cap, None]\\n        forward[2] = backward = [fr, 0, forward]\\n        self.G[fr].append(forward)\\n        self.G[to].append(backward)\\n\\n    def add_multi_edge(self, v1, v2, cap1, cap2):\\n        edge1 = [v2, cap1, None]\\n        edge1[2] = edge2 = [v1, cap2, edge1]\\n        self.G[v1].append(edge1)\\n        self.G[v2].append(edge2)\\n\\n    def bfs(self, s, t):\\n        self.level = level = [None]*self.N\\n        deq = deque([s])\\n        level[s] = 0\\n        G = self.G\\n        while deq:\\n            v = deq.popleft()\\n            lv = level[v] + 1\\n            for w, cap, _ in G[v]:\\n                if cap and level[w] is None:\\n                    level[w] = lv\\n                    deq.append(w)\\n        return level[t] is not None\\n\\n    def dfs(self, v, t, f):\\n        if v == t:\\n            return f\\n        level = self.level\\n        for e in self.it[v]:\\n            w, cap, rev = e\\n            if cap and level[v] < level[w]:\\n                d = self.dfs(w, t, min(f, cap))\\n                if d:\\n                    e[1] -= d\\n                    rev[1] += d\\n                    return d\\n        return 0\\n\\n    def flow(self, s, t):\\n        flow = 0\\n        INF = 10**9 + 7\\n        G = self.G\\n        while self.bfs(s, t):\\n            *self.it, = map(iter, self.G)\\n            f = INF\\n            while f:\\n                f = self.dfs(s, t, INF)\\n                flow += f\\n        return flow\\n\\n\\nimport sys\\nsys.setrecursionlimit(10 ** 7)\\ninput = sys.stdin.readline\\n\\nn = int(input())\\na = list( map(int, input().split()))\\n\\nscore = 0\\nINF = float('inf')\\ngraph = Dinic(n+2)\\n\\nfor i in range(n):\\n    if a[i]>0:\\n        graph.add_edge(i+1,n+1,a[i])\\n        score += a[i]\\n    elif a[i]<0:\\n        graph.add_edge(0,i+1,-a[i])\\n\\nfor i in range(1,n//2+1):\\n    for j in range(2*i,n+1,i):\\n        graph.add_edge(i,j,INF)\\n\\nprint(score-graph.flow(0,n+1))\", \"from collections import *\\nimport sys\\n\\nsys.setrecursionlimit(10 ** 6)\\nint1 = lambda x: int(x) - 1\\np2D = lambda x: print(*x, sep=\\\"\\\\n\\\")\\ndef MI(): return map(int, sys.stdin.readline().split())\\ndef LI(): return list(map(int, sys.stdin.readline().split()))\\n\\nclass Dinic():\\n    def __init__(self, n, s, t):\\n        self.n, self.s, self.t = n, s, t\\n        self.to = defaultdict(list)\\n        self.level = [-1]\\n        self.max_flow = -1\\n\\n    def add_edge(self, u, v, cap):\\n        u_index_in_to_v = len(self.to[v])\\n        v_index_in_to_u = len(self.to[u])\\n        self.to[u].append([v, cap, u_index_in_to_v])\\n        self.to[v].append([u, 0, v_index_in_to_u])\\n\\n    def set_level(self):\\n        s = self.s\\n        level = [-1] * self.n\\n        level[s] = 0\\n        q = deque()\\n        q.append([s, 0])\\n        while q:\\n            u, u_level = q.popleft()\\n            for v, cap, _ in self.to[u]:\\n                if cap == 0: continue\\n                if level[v] != -1: continue\\n                level[v] = u_level + 1\\n                if v == self.t:\\n                    self.level=level\\n                    return True\\n                q.append([v, u_level + 1])\\n        return False\\n\\n    def dfs(self, u=-1, flow_to_me=10 ** 16):\\n        if u == -1: u = self.s\\n        if u == self.t: return flow_to_me\\n        flow_from_me = 0\\n        u_level = self.level[u]\\n        for utov_i, (v, cap, vtou_i) in enumerate(self.to[u]):\\n            if self.level[v] != u_level + 1: continue\\n            if cap == 0: continue\\n            flow_to_v = self.dfs(v, min(cap, flow_to_me - flow_from_me))\\n            if not flow_to_v: continue\\n            flow_from_me += flow_to_v\\n            self.to[u][utov_i][1] -= flow_to_v\\n            self.to[v][vtou_i][1] += flow_to_v\\n        return flow_from_me\\n\\n    def calculation(self):\\n        res = 0\\n        while self.set_level():\\n            res += self.dfs()\\n        return res\\n\\n    # \\u3053\\u308c\\u304c\\u51fa\\u529b\\u7528\\n    def get_max_flow(self):\\n        if self.max_flow == -1:\\n            self.max_flow = self.calculation()\\n        return self.max_flow\\n\\ndef main():\\n    n = int(input())\\n    aa = LI()\\n    mf = Dinic(n + 2, 0, n + 1)\\n    max_sum = 0\\n    for i, a in enumerate(aa, 1):\\n        if a > 0:\\n            mf.add_edge(i, n + 1, a)\\n            max_sum += a\\n        else:\\n            mf.add_edge(0, i, -a)\\n    for i in range(1, n // 2 + 1):\\n        for j in range(i * 2, n + 1, i):\\n            mf.add_edge(i, j, 10 ** 12)\\n    print(max(0, max_sum - mf.get_max_flow()))\\n\\nmain()\\n\", \"from copy import deepcopy\\nN = int(input())\\na0 = list(map(int, input().split()))\\n\\nfor i in range(N, 0, -1):\\n    if a0[i - 1] < 0:\\n        tmp = 0\\n        b = []\\n        for j in range(1, 101):\\n            if i * j - 1 >= N:\\n                break\\n            tmp += a0[i * j - 1]\\n            b.append(i * j - 1)\\n        if tmp < 0:\\n            for j in b:\\n                a0[j] = 0\\n\\nfor k1 in range(N, 0, -1):\\n    for k2 in range(k1-1, 0, -1):\\n        a = deepcopy(a0)\\n        for j in range(1, 101):\\n            if k1*j-1 >= N:\\n                break\\n            a[k1*j-1] = 0\\n        for j in range(1, 101):\\n            if k2*j-1 >= N:\\n                break\\n            a[k2*j-1] = 0\\n        for i in range(N, 0, -1):\\n            if a[i - 1] < 0:\\n                tmp = 0\\n                b = []\\n                for j in range(1, 101):\\n                    if i * j - 1 >= N:\\n                        break\\n                    tmp += a[i * j - 1]\\n                    b.append(i * j - 1)\\n                if tmp < 0:\\n                    for j in b:\\n                        a[j] = 0\\n\\n        for i in range(N, 0, -1):\\n            if a0[i - 1] < 0:\\n                tmp = 0\\n                b = []\\n                for j in range(1, 101):\\n                    if i * j - 1 >= N:\\n                        break\\n                    tmp += a0[i * j - 1]\\n                    b.append(i * j - 1)\\n                if tmp < 0:\\n                    for j in b:\\n                        a0[j] = 0\\n\\n        if sum(a) > sum(a0):\\n            a0 = a\\n\\nprint((sum(a0)))\\n\", \"from typing import NamedTuple, Optional, List, cast\\n\\n\\nclass MFGraph:\\n    class Edge(NamedTuple):\\n        src: int\\n        dst: int\\n        cap: int\\n        flow: int\\n\\n    class _Edge:\\n        def __init__(self, dst: int, cap: int) -> None:\\n            self.dst = dst\\n            self.cap = cap\\n            self.rev: Optional[MFGraph._Edge] = None\\n\\n    def __init__(self, n: int) -> None:\\n        self._n = n\\n        self._g: List[List[MFGraph._Edge]] = [[] for _ in range(n)]\\n        self._edges: List[MFGraph._Edge] = []\\n\\n    def add_edge(self, src: int, dst: int, cap: int) -> int:\\n        assert 0 <= src < self._n\\n        assert 0 <= dst < self._n\\n        assert 0 <= cap\\n        m = len(self._edges)\\n        e = MFGraph._Edge(dst, cap)\\n        re = MFGraph._Edge(src, 0)\\n        e.rev = re\\n        re.rev = e\\n        self._g[src].append(e)\\n        self._g[dst].append(re)\\n        self._edges.append(e)\\n        return m\\n\\n    def get_edge(self, i: int) -> Edge:\\n        assert 0 <= i < len(self._edges)\\n        e = self._edges[i]\\n        re = cast(MFGraph._Edge, e.rev)\\n        return MFGraph.Edge(\\n            re.dst,\\n            e.dst,\\n            e.cap + re.cap,\\n            re.cap\\n        )\\n\\n    def edges(self) -> List[Edge]:\\n        return [self.get_edge(i) for i in range(len(self._edges))]\\n\\n    def change_edge(self, i: int, new_cap: int, new_flow: int) -> None:\\n        assert 0 <= i < len(self._edges)\\n        assert 0 <= new_flow <= new_cap\\n        e = self._edges[i]\\n        e.cap = new_cap - new_flow\\n        assert e.rev is not None\\n        e.rev.cap = new_flow\\n\\n    def flow(self, s: int, t: int, flow_limit: Optional[int] = None) -> int:\\n        assert 0 <= s < self._n\\n        assert 0 <= t < self._n\\n        assert s != t\\n        if flow_limit is None:\\n            flow_limit = cast(int, sum(e.cap for e in self._g[s]))\\n\\n        current_edge = [0] * self._n\\n        level = [0] * self._n\\n\\n        def fill(arr: List[int], value: int) -> None:\\n            for i in range(len(arr)):\\n                arr[i] = value\\n\\n        def bfs() -> bool:\\n            fill(level, self._n)\\n            queue = []\\n            q_front = 0\\n            queue.append(s)\\n            level[s] = 0\\n            while q_front < len(queue):\\n                v = queue[q_front]\\n                q_front += 1\\n                next_level = level[v] + 1\\n                for e in self._g[v]:\\n                    if e.cap == 0 or level[e.dst] <= next_level:\\n                        continue\\n                    level[e.dst] = next_level\\n                    if e.dst == t:\\n                        return True\\n                    queue.append(e.dst)\\n            return False\\n\\n        def dfs(lim: int) -> int:\\n            stack = []\\n            edge_stack: List[MFGraph._Edge] = []\\n            stack.append(t)\\n            while stack:\\n                v = stack[-1]\\n                if v == s:\\n                    flow = min(lim, min(e.cap for e in edge_stack))\\n                    for e in edge_stack:\\n                        e.cap -= flow\\n                        assert e.rev is not None\\n                        e.rev.cap += flow\\n                    return flow\\n                next_level = level[v] - 1\\n                while current_edge[v] < len(self._g[v]):\\n                    e = self._g[v][current_edge[v]]\\n                    re = cast(MFGraph._Edge, e.rev)\\n                    if level[e.dst] != next_level or re.cap == 0:\\n                        current_edge[v] += 1\\n                        continue\\n                    stack.append(e.dst)\\n                    edge_stack.append(re)\\n                    break\\n                else:\\n                    stack.pop()\\n                    if edge_stack:\\n                        edge_stack.pop()\\n                    level[v] = self._n\\n            return 0\\n\\n        flow = 0\\n        while flow < flow_limit:\\n            if not bfs():\\n                break\\n            fill(current_edge, 0)\\n            while flow < flow_limit:\\n                f = dfs(flow_limit - flow)\\n                flow += f\\n                if f == 0:\\n                    break\\n        return flow\\n\\n    def min_cut(self, s: int) -> List[bool]:\\n        visited = [False] * self._n\\n        stack = [s]\\n        visited[s] = True\\n        while stack:\\n            v = stack.pop()\\n            for e in self._g[v]:\\n                if e.cap > 0 and not visited[e.dst]:\\n                    visited[e.dst] = True\\n                    stack.append(e.dst)\\n        return visited\\n\\n\\nimport sys\\ninput = sys.stdin.readline\\nn = int(input())\\nA = tuple(map(int, input().split()))\\nG = MFGraph(n+2)\\ns = 0\\nt = n+1\\nINF = 10**18\\nans = 0\\nfor i, a in enumerate(A, 1):\\n    if a < 0:\\n        G.add_edge(s, i, -a)\\n    if a > 0:\\n        G.add_edge(i, t, a)\\n        ans += a\\n    for j in range(2*i, n+1, i):\\n        G.add_edge(i, j, INF)\\nans -= G.flow(s, t)\\nprint(ans)\", \"from collections import deque\\n\\n\\nclass Dinic:\\n    def __init__(self, v, inf=10**9 + 7):\\n        self.V = v\\n        self.inf = inf\\n        self.G = [list() for _ in range(v)]\\n        self.level = [-1 for _ in range(v)]\\n        self.iter = [0] * v\\n\\n    def addedge(self, fr, to, cap):\\n        \\\"\\\"\\\"\\n        G[fr] = [to, cap, rev]\\n        \\\"\\\"\\\"\\n        go = [to, cap, None]\\n        go[2] = back = [fr, 0, go]\\n        self.G[fr].append(go)\\n        self.G[to].append(back)\\n\\n    def bfs(self, st, en):\\n        q = deque([st])\\n        self.level = [-1 for _ in range(self.V)]\\n        self.level[st] = 0\\n        while q:\\n            cur = q.popleft()\\n            for x, cap, _ in self.G[cur]:\\n                if cap and self.level[x] < 0:\\n                    self.level[x] = self.level[cur] + 1\\n                    q.append(x)\\n        return self.level[en] > 0\\n\\n    def dfs(self, v, t, f):\\n        if v == t:\\n            return f\\n        for e in self.iter[v]:\\n            w, cap, rev = e\\n            if cap and self.level[v] < self.level[w]:\\n                d = self.dfs(w, t, min(f, cap))\\n                if d:\\n                    e[1] -= d\\n                    rev[1] += d\\n                    return d\\n        return 0\\n\\n    def flow(self, s, t):\\n        flow = 0\\n        while self.bfs(s, t):\\n            self.iter = list(map(iter, self.G))\\n            f = self.dfs(s, t, self.inf)\\n            while f:\\n                flow += f\\n                f = self.dfs(s, t, self.inf)\\n        return flow\\n\\ndef main():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    D = Dinic(n+2)\\n    ret = 0\\n    for i,e in enumerate(a, 1):\\n      if e > 0:\\n        ret += e\\n        D.addedge(i, n+1, e)\\n      else:\\n        D.addedge(0, i, -e)\\n    for i in range(1, n//2 + 1):\\n      for j in range(i*2, n+1, i):\\n        D.addedge(i, j, 10**12)\\n    loss = D.flow(0, n+1)\\n    return ret - loss\\n\\nprint(main())\", \"N = int(input())\\nAs = list(map(int, input().split()))\\n\\ndef func(Bs):\\n    for x in range(N):\\n        if Bs[x] >= 0: continue\\n        if max(Bs[x::x + 1]) <= 0:\\n            Bs[x] = 0\\n\\nfunc(As)\\n\\nzs = [27, 29, 31, 33] + list(range(34, 51))\\nfor x in zs:\\n    if sum(As[x - 1::x]) < 0:\\n        for i in range(x - 1, N, x):\\n            As[i] = 0\\n\\nns = [1, 2, 4, 8, 16, 32] + [3, 6, 9, 12, 18, 24, 27, 36, 48] \\\\\\n    + [5, 10, 15, 20, 25, 30, 40, 45, 50] + [7, 14, 21, 28, 35, 42, 49] \\\\\\n    + [11, 22, 33, 44] + [13, 26, 39] + [17, 34] + [19, 38] + [23, 46] \\\\\\n    + [29, 31, 37, 41, 43, 47]\\n\\nmemo = {}\\nmemo[tuple(As)] = sum(As)\\n\\ncs = [n - 1 for n in ns if n <= N and n not in zs and As[n - 1] < 0]\\nfor c in cs:\\n    for tupleA in list(memo.keys()):\\n        if tupleA[c] == 0:\\n            continue\\n\\n        listA = list(tupleA)\\n        for x in range(c, N, c + 1):\\n            listA[x] = 0\\n\\n        func(listA)\\n        memo[tuple(listA)] = sum(listA)\\n\\nprint((max(memo.values())))\\n\", \"#!/usr/bin/env python3\\n\\nfrom sys import stdin\\nfrom fractions import gcd\\t# math.gcd is introduced in python 3.5\\nfrom functools import reduce\\n\\ndef lcm(x, y):\\n    \\\"\\\"\\\"The least common multiple of x and y.\\\"\\\"\\\"\\n    return x * (y // gcd(x, y))\\n\\ndef multiples(t, N):\\n    \\\"\\\"\\\"Set of multiples (<= N) of some x in t.\\\"\\\"\\\"\\n    return set(i for x in t for i in range(x, N + 1, x))\\n\\ndef value(a, t):\\n    \\\"\\\"\\\"The value of the jewels that are labeled a multiple of some x in t.\\\"\\\"\\\"\\n    return sum(a[i - 1] for i in multiples(t, len(a)))\\n\\ndef remove(a, t):\\n    \\\"\\\"\\\"Break all jewels that are labeled a multiple of some x in t.\\\"\\\"\\\"\\n    for i in multiples(t, len(a)):\\n        a[i - 1] = 0\\n\\ndef tuples(m, N):\\n    \\\"\\\"\\\"\\n    List of tuples over {m,...,N}.\\n    Each tuple t in the list satisfies that:\\n        the lcm of t is less than or equal to N, and\\n        t does not contain a proper multiple of some j in t.\\n    \\\"\\\"\\\"\\n    if m > N: return [()]\\n    ts = tuples(m + 1, N)\\n    us = [(m,) + t for t in ts\\n          if reduce(lcm, t, m) <= N and all(j % m != 0 for j in t)]\\n    ts.extend(us)\\n    return ts\\n\\ndef solve(a):\\n    N = len(a)\\n    for t in tuples(1, N):\\n        if value(a, t) < 0: remove(a, t)\\n    return sum(a)\\n\\nN = int(stdin.readline())\\na = [int(w) for w in stdin.readline().split()]\\nif len(a) != N: raise\\nprint((solve(a)))\\n\", \"from collections import deque\\n \\n \\nclass Dinic:\\n    def __init__(self, n: int):\\n        \\\"\\\"\\\"\\u9802\\u70b9\\u6570\\u3092n\\u3068\\u3059\\u308b\\\"\\\"\\\"\\n        self.INF = float(\\\"inf\\\")\\n        self.n = n\\n        self.graph = [[] for _ in range(n)]\\n \\n    def add_edge(self, _from: int, to: int, capacity: int):\\n        \\\"\\\"\\\"\\u6b8b\\u4f59\\u30b0\\u30e9\\u30d5\\u3092\\u69cb\\u7bc9\\n        1. _from\\u304b\\u3089to\\u3078\\u5411\\u304b\\u3046\\u5bb9\\u91cfcapacity\\u306e\\u8fba\\u3092\\u30b0\\u30e9\\u30d5\\u306b\\u8ffd\\u52a0\\u3059\\u308b\\n        2. to\\u304b\\u3089_from\\u3078\\u5411\\u304b\\u3046\\u5bb9\\u91cf0\\u306e\\u8fba\\u3092\\u30b0\\u30e9\\u30d5\\u306b\\u8ffd\\u52a0\\u3059\\u308b\\n        \\\"\\\"\\\"\\n        forward = [to, capacity, None]\\n        forward[2] = backward = [_from, 0, forward]\\n        self.graph[_from].append(forward)\\n        self.graph[to].append(backward)\\n \\n    def bfs(self, s: int, t: int):\\n        \\\"\\\"\\\"capacity\\u304c\\u6b63\\u306e\\u8fba\\u306e\\u307f\\u3092\\u901a\\u3063\\u3066s\\u304b\\u3089t\\u306b\\u79fb\\u52d5\\u53ef\\u80fd\\u304b\\u3069\\u3046\\u304bBFS\\u3067\\u63a2\\u7d22\\n        level: s\\u304b\\u3089\\u306e\\u6700\\u77ed\\u8def\\u306e\\u9577\\u3055\\n        \\\"\\\"\\\"\\n        self.level = [-1] * self.n\\n        q = deque([s])\\n        self.level[s] = 0\\n        while q:\\n            _from = q.popleft()\\n            for to, capacity, _ in self.graph[_from]:\\n                if capacity > 0 and self.level[to] < 0:\\n                    self.level[to] = self.level[_from] + 1\\n                    q.append(to)\\n \\n    def dfs(self, _from: int, t: int, f: int) -> int:\\n        \\\"\\\"\\\"\\u6d41\\u91cf\\u304c\\u5897\\u52a0\\u3059\\u308b\\u30d1\\u30b9\\u3092DFS\\u3067\\u63a2\\u7d22\\n        BFS\\u306b\\u3088\\u3063\\u3066\\u4f5c\\u3089\\u308c\\u305f\\u6700\\u77ed\\u8def\\u306b\\u5f93\\u3063\\u3066f\\u3092\\u66f4\\u65b0\\u3059\\u308b\\n        \\\"\\\"\\\"\\n        if _from == t:\\n            return f\\n        for edge in self.itr[_from]:\\n            to, capacity, reverse_edge = edge\\n            if capacity > 0 and self.level[_from] < self.level[to]:\\n                d = self.dfs(to, t, min(f, capacity))\\n                if d > 0:\\n                    edge[1] -= d\\n                    reverse_edge[1] += d\\n                    return d\\n        return 0\\n \\n    def max_flow(self, s: int, t: int):\\n        \\\"\\\"\\\"s-t\\u30d1\\u30b9\\u4e0a\\u306e\\u6700\\u5927\\u6d41\\u3092\\u6c42\\u3081\\u308b\\n        \\u8a08\\u7b97\\u91cf: O(|E||V|^2)\\n        \\\"\\\"\\\"\\n        flow = 0\\n        while True:\\n            self.bfs(s, t)\\n            if self.level[t] < 0:\\n                break\\n            self.itr = list(map(iter, self.graph))\\n            f = self.dfs(s, t, self.INF)\\n            while f > 0:\\n                flow += f\\n                f = self.dfs(s, t, self.INF)\\n        return flow\\n\\nn = int(input())\\na = list(map(int, input().split()))\\n\\ndinic = Dinic(n + 2)\\ns = 0\\nt = n + 1\\n_sum = 0\\nfor i in range(0, n):\\n    if a[i] > 0:\\n        dinic.add_edge(s, i+1, 0)\\n        dinic.add_edge(i+1, t, a[i])\\n        _sum += a[i]\\n    elif a[i] < 0:\\n        dinic.add_edge(s, i+1, -a[i])\\n        dinic.add_edge(i+1, t, 0)\\n    else:\\n        dinic.add_edge(s, i+1, 0)\\n        dinic.add_edge(i+1, t, 0)\\n\\nfor i in range(n):\\n    num = i+1\\n    next_num = 2 * num\\n    while next_num <= n:\\n        dinic.add_edge(num, next_num, 10**18)\\n        next_num += num\\n\\nprint(_sum - dinic.max_flow(s, t))\", \"from sys import setrecursionlimit, stderr\\nfrom functools import reduce\\nfrom itertools import *\\nfrom collections import *\\nfrom bisect import *\\n\\ndef read():\\n  return int(input())\\n \\ndef reads():\\n  return [int(x) for x in input().split()]\\n\\nINF = 1 << 60\\n\\ndef main():\\n  N = read()\\n  A = reads()\\n  offset = sum(a for a in A if a > 0)\\n  di = dinic(N+2) # 0: source, N+1: target\\n  for i in range(1, N+1):\\n    a = A[i-1]\\n    if a <= 0:\\n      di.add_edge(0, i, -a)\\n    else:\\n      di.add_edge(i, N+1, a)\\n    for j in range(2*i, N+1, i):\\n      di.add_edge(i, j, INF)\\n  ans = offset - di.max_flow(0, N+1)\\n  print(ans)\\n\\nclass dinic:\\n  def __init__(self, N): self.size = N; self.edges = [[] for _ in range(N)]\\n  def add_edge(self, u, v, c): self.edges[u].append((v, c)); self.edges[v].append((u, 0))\\n  def bfs(self, cap, s):\\n    N = self.size; edges = self.edges\\n    level = [-1] * N; level[s] = 0\\n    que = deque([s])\\n    while len(que) > 0:\\n      u = que.popleft()\\n      for v, _ in edges[u]:\\n        if cap[u][v] > 0 and level[v] < 0: level[v] = level[u] + 1; que.append(v)\\n    return level\\n  def dfs(self, cap, itr, level, u, t, f):\\n    N = self.size; edges = self.edges\\n    if u == t: return f\\n    for i in range(itr[u], len(edges[u])):\\n      itr[u] = i\\n      v, _ = edges[u][i]\\n      if cap[u][v] > 0 and level[u] < level[v]:\\n        d = self.dfs(cap, itr, level, v, t, min(f, cap[u][v]))\\n        if d > 0: cap[u][v] -= d; cap[v][u] += d; return d\\n    return 0\\n  def max_flow(self, s, t):\\n    N = self.size; edges = self.edges; cap = [[0] * N for _ in range(N)]\\n    for u in range(N):\\n      for v, c in edges[u]: cap[u][v] += c\\n    flow = 0\\n    while True:\\n      level = self.bfs(cap, s)\\n      if level[t] < 0: return flow\\n      itr = [0] * N\\n      while True:\\n        f = self.dfs(cap, itr, level, s, t, INF)\\n        if f <= 0: break\\n        flow += f\\n\\nmain()\", \"#!/usr/bin/env python3\\n\\nfrom sys import stdin\\nfrom fractions import gcd\\t# math.gcd is introduced in python 3.5\\nfrom functools import reduce\\n\\ndef lcm(x, y):\\n    \\\"\\\"\\\"The least common multiple of x and y.\\\"\\\"\\\"\\n    return x * (y // gcd(x, y))\\n\\ndef flatten(ls):\\n    \\\"\\\"\\\"Flatten a list of lists.\\\"\\\"\\\"\\n    return [x for l in ls for x in l]\\n\\n\\ndef multiples(t, N):\\n    \\\"\\\"\\\"Set of multiples (<= N) of some x in t.\\\"\\\"\\\"\\n    return set(i for x in t for i in range(x, N + 1, x))\\n\\ndef value(a, t):\\n    \\\"\\\"\\\"The value of the jewels that are labeled a multiple of some x in t.\\\"\\\"\\\"\\n    return sum(a[i - 1] for i in multiples(t, len(a)))\\n\\ndef remove(a, t):\\n    \\\"\\\"\\\"Break all jewels that are labeled a multiple of some x in t.\\\"\\\"\\\"\\n    for i in multiples(t, len(a)):\\n        a[i - 1] = 0\\n\\n\\ndef tuples(m, N):\\n    \\\"\\\"\\\"\\n    [[m'-tuples over {1,2,3,...,N}] for 0 <= m' <= m].\\n    The lcm of the m-tuple is less than or equal to N.\\n    Each m-tuple does not contain a multiple of some j in the tuple.\\n    \\\"\\\"\\\"\\n    if m == 0: return [[()]]\\n    ts = tuples(m - 1, N)\\n    if ts[-1] == []: return ts\\n\\n    ls = []\\n    for t in ts[-1]:\\n        lc = reduce(lcm, t) if len(t) > 0 else 1\\n        mi = min(t)         if len(t) > 0 else N + 1\\n        for i in range(mi - 1, 0, -1):\\n            if lcm(lc, i) > N: continue\\n            if any(j % i == 0 for j in t): continue\\n            ls.append((i,) + t)  # smaller label first\\n    ts.append(ls)\\n    return ts\\n\\ndef solve(a):\\n    N = len(a)\\n    tl = flatten(tuples(N, N))\\n    # break jewels with larger labels first.\\n    tl.sort(key=lambda t: [-x for x in t])\\n    for t in tl:\\n        if value(a, t) < 0: remove(a, t)\\n    return sum(a)\\n\\nN = int(stdin.readline())\\na = [int(w) for w in stdin.readline().split()]\\nif len(a) != N: raise\\nprint((solve(a)))\\n\", \"from collections import deque\\nclass Dinic:\\n    def __init__(self, N):\\n        self.N = N\\n        self.G = [[] for i in range(N)]\\n\\n    def add_edge(self, fr, to, cap):\\n        forward = [to, cap, None]#(\\u884c\\u304d\\u5148\\u3001\\u5bb9\\u91cf\\u3001\\u9006\\u8fba\\u306e\\u53c2\\u7167)\\n        forward[2] = backward = [fr, 0, forward]\\n        self.G[fr].append(forward)\\n        self.G[to].append(backward)\\n\\n    def add_multi_edge(self, v1, v2, cap1, cap2):\\n        edge1 = [v2, cap1, None]\\n        edge1[2] = edge2 = [v1, cap2, edge1]\\n        self.G[v1].append(edge1)\\n        self.G[v2].append(edge2)\\n\\n    def bfs(self, s, t):\\n        self.level = level = [None]*self.N\\n        deq = deque([s])\\n        level[s] = 0\\n        G = self.G\\n        while deq:\\n            v = deq.popleft()\\n            lv = level[v] + 1\\n            for w, cap, _ in G[v]:\\n                if cap and level[w] is None:\\n                    level[w] = lv\\n                    deq.append(w)\\n        return level[t] is not None\\n\\n    def dfs(self, v, t, f):\\n        if v == t:\\n            return f\\n        level = self.level\\n        for e in self.it[v]:\\n            w, cap, rev = e\\n            if cap and level[v] < level[w]:\\n                d = self.dfs(w, t, min(f, cap))\\n                if d:\\n                    e[1] -= d\\n                    rev[1] += d\\n                    return d\\n        return 0\\n\\n    def flow(self, s, t):\\n        flow = 0\\n        INF = 10**9 + 7\\n        G = self.G\\n        while self.bfs(s, t):\\n            *self.it, = list(map(iter, self.G))\\n            f = INF\\n            while f:\\n                f = self.dfs(s, t, INF)\\n                flow += f\\n        return flow\\nN = int(input())\\na = list(map(int, input().split()))\\nD = Dinic(N+2)\\ninf = 10**18\\nprofit = 0\\ncost = 0\\nfor i in range(N):\\n    if a[i]>=0:\\n        D.add_edge(i, N+1, a[i])\\n    else:\\n        D.add_edge(N, i, -a[i])\\n        cost+=a[i]\\n    profit+=abs(a[i])\\n    \\n\\nfor i in range(1, N+1):\\n    for k in range(2, N//i+1):\\n        D.add_edge(i-1, i*k-1, inf)\\nf = D.flow(N, N+1)\\nprint((profit-f+cost))\\n\", \"def main():\\n    import sys\\n    input = sys.stdin.readline\\n\\n    # Dinic's algorithm\\n    from collections import deque\\n    class Dinic:\\n        def __init__(self, N):\\n            self.N = N\\n            self.G = [[] for i in range(N)]\\n\\n        def add_edge(self, fr, to, cap):\\n            forward = [to, cap, None]\\n            forward[2] = backward = [fr, 0, forward]\\n            self.G[fr].append(forward)\\n            self.G[to].append(backward)\\n\\n        def add_multi_edge(self, v1, v2, cap1, cap2):\\n            edge1 = [v2, cap1, None]\\n            edge1[2] = edge2 = [v1, cap2, edge1]\\n            self.G[v1].append(edge1)\\n            self.G[v2].append(edge2)\\n\\n        def bfs(self, s, t):\\n            self.level = level = [None] * self.N\\n            deq = deque([s])\\n            level[s] = 0\\n            G = self.G\\n            while deq:\\n                v = deq.popleft()\\n                lv = level[v] + 1\\n                for w, cap, _ in G[v]:\\n                    if cap and level[w] is None:\\n                        level[w] = lv\\n                        deq.append(w)\\n            return level[t] is not None\\n\\n        def dfs(self, v, t, f):\\n            if v == t:\\n                return f\\n            level = self.level\\n            for e in self.it[v]:\\n                w, cap, rev = e\\n                if cap and level[v] < level[w]:\\n                    d = self.dfs(w, t, min(f, cap))\\n                    if d:\\n                        e[1] -= d\\n                        rev[1] += d\\n                        return d\\n            return 0\\n\\n        def flow(self, s, t):\\n            flow = 0\\n            INF = 10 ** 9 + 7\\n            G = self.G\\n            while self.bfs(s, t):\\n                *self.it, = map(iter, self.G)\\n                f = INF\\n                while f:\\n                    f = self.dfs(s, t, INF)\\n                    flow += f\\n            return flow\\n\\n    inf = 1<<40\\n    N = int(input())\\n    A = list(map(int, input().split()))\\n    dinic = Dinic(N+2)\\n    ans = 0\\n    for i, a in enumerate(A):\\n        if a > 0:\\n            ans += a\\n            #dinic.add_edge(0, i+1, 0)\\n            dinic.add_edge(i+1, N+1, a)\\n        else:\\n            dinic.add_edge(0, i+1, -a)\\n            #dinic.add_edge(i+1, N+1, 0)\\n    for i in range(1, N+1):\\n        for k in range(1, N+1):\\n            if i*k > N:\\n                break\\n            dinic.add_edge(i, i*k, inf)\\n\\n    print(ans - dinic.flow(0, N+1))\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import networkx as nx\\n\\nn = int(input())\\nA = list(map(int, input().split()))\\nG = nx.DiGraph()\\n\\nsource = \\\"source\\\"\\nsink = \\\"sink\\\"\\n\\nfor i in range(1, n + 1):\\n    x, y = A[i - 1], 0\\n    if A[i - 1] < 0:\\n        x, y = y, -x\\n    G.add_edge(source, i, capacity=x)\\n    G.add_edge(i, sink, capacity=y)\\n\\nfor i in range(1, n // 2 + 1):\\n    for j in range(2 * i, n + 1, i):\\n        # print(i, j)\\n        G.add_edge(j, i)\\n\\ntry:\\n    mincut, cut_dic = nx.minimum_cut(G, source, sink)\\n    res = sum(a for a in A if a > 0)\\n    print((res - mincut))\\n\\n\\nexcept nx.NetworkXError:\\n    print((0))\\n\", \"from collections import deque\\nn = int(input())\\na = list(map(int, input().split()))\\n\\n\\nclass Dinic:\\n    def __init__(self, N):\\n        self.N = N\\n        self.G = [[] for i in range(N)]\\n\\n    def add_edge(self, fr, to, cap):\\n        forward = [to, cap, None]\\n        forward[2] = backward = [fr, 0, forward]\\n        self.G[fr].append(forward)\\n        self.G[to].append(backward)\\n\\n    def add_multi_edge(self, v1, v2, cap1, cap2):\\n        edge1 = [v2, cap1, None]\\n        edge1[2] = edge2 = [v1, cap2, edge1]\\n        self.G[v1].append(edge1)\\n        self.G[v2].append(edge2)\\n\\n    def bfs(self, s, t):\\n        self.level = level = [None]*self.N\\n        deq = deque([s])\\n        level[s] = 0\\n        G = self.G\\n        while deq:\\n            v = deq.popleft()\\n            lv = level[v] + 1\\n            for w, cap, _ in G[v]:\\n                if cap and level[w] is None:\\n                    level[w] = lv\\n                    deq.append(w)\\n        return level[t] is not None\\n\\n    def dfs(self, v, t, f):\\n        if v == t:\\n            return f\\n        level = self.level\\n        for e in self.it[v]:\\n            w, cap, rev = e\\n            if cap and level[v] < level[w]:\\n                d = self.dfs(w, t, min(f, cap))\\n                if d:\\n                    e[1] -= d\\n                    rev[1] += d\\n                    return d\\n        return 0\\n\\n    def flow(self, s, t):\\n        flow = 0\\n        INF = 10**9 + 7\\n        G = self.G\\n        while self.bfs(s, t):\\n            *self.it, = list(map(iter, self.G))\\n            f = INF\\n            while f:\\n                f = self.dfs(s, t, INF)\\n                flow += f\\n        return flow\\n\\n\\ngraph = Dinic(n + 2)\\nfor i in range(n):\\n    if a[i] >= 0:\\n        graph.add_edge(i, n, a[i])\\n        continue\\n    graph.add_edge(n + 1, i, -a[i])\\nfor i in range(1, n + 1):\\n    for j in range(2 * i, n + 1, i):\\n        graph.add_edge(i-1, j-1, 10**11)\\nprint((sum([max(0, i) for i in a])-graph.flow(n+1, n)))\\n\", \"from collections import deque\\nclass Dinic:\\n    def __init__(self,number):\\n        self.table = [[0]*(number) for i in range(number)]\\n        self.n=number\\n    \\n    def add(self,x,y,f):\\n        self.table[x][y]=f\\n    \\n    def bfs(self,x):\\n        self.visit[x]=0\\n        h=deque()\\n        h.append(x)\\n        while h:\\n            y=h.popleft()\\n            for i in range(self.n):\\n                if self.visit[i]==-1 and self.table[y][i]>0:\\n                    self.visit[i]=self.visit[y]+1\\n                    h.append(i)\\n        return 0\\n    \\n    def dinic(self,s,t,f):\\n        if s==t:\\n            return f\\n        for i in range(self.n):\\n            if self.visit[i]>self.visit[s] and self.table[s][i]>0:\\n                df = self.dinic(i,t,min(f,self.table[s][i]))\\n                if df>0:\\n                    self.table[s][i]-=df\\n                    self.table[i][s]+=df\\n                    return df\\n        return 0\\n    \\n    def flow(self,s,t):\\n        ans=0\\n        inf=10**20\\n        while True:\\n            self.visit=[-1]*(self.n)\\n            self.bfs(s)\\n            if self.visit[t]==-1:\\n                break\\n            while True:\\n                df=self.dinic(s,t,inf)\\n                if df==0:\\n                    break\\n                ans+=df\\n        return ans\\nN=int(input())\\nP=[int(i) for i in input().split()]\\ninf=10**20\\nmaxflow=Dinic(N+2)\\nfor i in range(1,N+1):\\n    if P[i-1]>0:\\n        maxflow.add(i,N+1,P[i-1])\\n    else:\\n        maxflow.add(0,i,-P[i-1])\\n    for j in range(2*i,N+1,i):\\n        maxflow.add(i,j,inf)\\nans=maxflow.flow(0,N+1)\\nnum=sum([p for p in P if p>0])\\nprint(num-ans)\", \"import sys\\nINF = 1 << 60\\nMOD = 10**9 + 7 # 998244353\\nsys.setrecursionlimit(2147483647)\\ninput = lambda:sys.stdin.readline().rstrip()\\n\\nclass MaxFlow(object):\\n    def __init__(self, n):\\n        self.n = n\\n        self.E = [[] for _ in range(n)]\\n\\n    def add_edge(self, u, v, cap):\\n        e = [v, cap, 0]\\n        rev = [u, 0, e]\\n        e[-1] = rev\\n        self.E[u].append(e)\\n        self.E[v].append(rev)\\n\\n    def _bfs(self, s, t):\\n        self._level = level = [-1] * self.n\\n        level[s] = 0\\n        queue = [s]\\n        for v in queue:\\n            for nv, cap, _ in self.E[v]:\\n                if cap and level[nv] == -1:\\n                    level[nv] = level[v] + 1\\n                    if nv == t:\\n                        return True\\n                    queue.append(nv)\\n        return level[t] != -1\\n\\n    def _dfs(self, s, t):\\n        E, level, it = self.E, self._level, self._iter\\n        stack = [(s, INF)]\\n        while stack:\\n            v, f = stack[-1]\\n            if v == t:\\n                for v, _ in stack[:-1]:\\n                    E[v][it[v]][1] -= f\\n                    E[v][it[v]][-1][1] += f\\n                return f\\n            while it[v] < len(E[v]):\\n                nv, cap, _ = E[v][it[v]]\\n                if cap and level[v] < level[nv]:\\n                    stack.append((nv, min(f, cap)))\\n                    break\\n                it[v] += 1\\n            else:\\n                stack.pop()\\n                level[v] = 0\\n        return 0\\n\\n    def solve(self, s, t):\\n        res = 0\\n        while self._bfs(s, t):\\n            self._iter = [0] * self.n\\n            f = 1\\n            while f:\\n                f = self._dfs(s, t)\\n                res += f\\n        return res\\n\\ndef resolve():\\n    n = int(input())\\n    A = list(map(int, input().split()))\\n\\n    s, t = 0, n + 1\\n    flow = MaxFlow(n + 2)\\n    ans = sum(a for a in A if a > 0)\\n\\n    for u in range(1, n + 1):\\n        for v in range(2 * u, n + 1, u):\\n            flow.add_edge(u, v, INF)\\n\\n    for v, a in enumerate(A, 1):\\n        flow.add_edge(s, v, max(-a, 0))\\n        flow.add_edge(v, t, max(a, 0))\\n\\n    ans -= flow.solve(s, t)\\n    print(ans)\\nresolve()\", \"import sys\\nINF = 1 << 60\\nMOD = 10**9 + 7 # 998244353\\nsys.setrecursionlimit(2147483647)\\ninput = lambda:sys.stdin.readline().rstrip()\\nimport networkx as nx\\ndef resolve():\\n    n = int(input())\\n    A = list(map(int, input().split()))\\n    total = sum(a for a in A if a > 0)\\n\\n    # minimum cut\\n    G = nx.DiGraph()\\n    G.add_nodes_from(range(1, n + 1))\\n    G.add_nodes_from([\\\"source\\\", \\\"termination\\\"])\\n    for i, a in enumerate(A, 1):\\n        if a >= 0:\\n            G.add_edge(\\\"source\\\", i, capacity = 0)\\n            G.add_edge(i, \\\"termination\\\", capacity = a)\\n        else:\\n            G.add_edge(\\\"source\\\", i, capacity = -a)\\n            G.add_edge(i, \\\"termination\\\", capacity = 0)\\n\\n    for i in range(1, n + 1):\\n        for j in range(2 * i, n + 1, i):\\n            G.add_edge(i, j, capacity = INF)\\n\\n    flow = nx.algorithms.flow.maximum_flow_value(G, \\\"source\\\", \\\"termination\\\")\\n    print(total - flow)\\nresolve()\", \"import networkx as nx\\nfrom  networkx.algorithms.flow import dinitz\\n\\nn = int(input())\\nA = list(map(int, input().split()))\\nG = nx.DiGraph()\\n\\nsource = \\\"source\\\"\\nsink = \\\"sink\\\"\\n\\nfor i in range(1, n + 1):\\n    if A[i - 1] <= 0:\\n        G.add_edge(source, i, capacity=-A[i - 1])\\n    else:\\n        G.add_edge(i, sink, capacity=A[i - 1])\\n\\nfor i in range(1, n // 2 + 1):\\n    for j in range(2 * i, n + 1, i):\\n        G.add_edge(i, j)\\n\\ntry:\\n    # mincut = nx.minimum_cut_value(G, source, sink)\\n    R = dinitz(G, source, sink)\\n    # print(R, R.graph)\\n    res = sum(a for a in A if a > 0)\\n    # print(res - mincut)\\n    print((res - R.graph[\\\"flow_value\\\"]))\\n\\nexcept nx.NetworkXError:\\n    print((0))\\n\", \"\\nfrom collections import deque\\n\\n\\nclass Dinic:\\n    def __init__(self, N, inf):\\n        self.N = N\\n        self.inf = inf\\n        self.G = [[] for _ in range(N)]\\n        self.level = [0]*N\\n\\n    def add_edge(self, fr, to, cap):\\n        forward = [to, cap, None]\\n        forward[2] = backward = [fr, 0, forward]\\n        self.G[fr].append(forward)\\n        self.G[to].append(backward)\\n\\n    def add_multi_edge(self, v1, v2, cap1, cap2):\\n        edge1 = [v2, cap1, None]\\n        edge1[2] = edge2 = [v1, cap2, edge1]\\n        self.G[v1].append(edge1)\\n        self.G[v2].append(edge2)\\n\\n    def bfs(self, s):\\n        self.level = [-1]*self.N\\n        deq = deque([s])\\n        self.level[s] = 0\\n        while deq:\\n            v = deq.pop()\\n            lv = self.level[v] + 1\\n            for w, cap, _ in self.G[v]:\\n                if cap > 0 and self.level[w] == -1:\\n                    self.level[w] = lv\\n                    deq.appendleft(w)\\n\\n    def dfs(self, v, t, f):\\n        if v == t:\\n            return f\\n        for e in self.iter[v]:\\n            w, cap, rev = e\\n            if cap > 0 and self.level[v] < self.level[w]:\\n                d = self.dfs(w, t, min(f, cap))\\n                if d > 0:\\n                    e[1] -= d\\n                    rev[1] += d\\n                    return d\\n        return 0\\n\\n    def flow(self, s, t):\\n        flow = 0\\n        while True:\\n            self.bfs(s)\\n            if self.level[t] == -1:\\n                return flow\\n            *self.iter, = list(map(iter, self.G))\\n            f = self.inf\\n            while f > 0:\\n                f = self.dfs(s, t, self.inf)\\n                flow += f\\n\\n\\nimport sys\\nsys.setrecursionlimit(10**7)\\ndef I(): return int(sys.stdin.readline().rstrip())\\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #\\u7a7a\\u767d\\u3042\\u308a\\n\\n\\nN = I()\\nA = [0] + LI()\\nans = sum(A[i] for i in range(1,N+1) if A[i] > 0)\\n\\ninf = 10**18\\nDi = Dinic(N+2,inf)\\ns,t = 0,N+1\\n\\nfor i in range(1,N+1):\\n    Di.add_edge(s,i,max(0,-A[i]))\\n    Di.add_edge(i,t,max(0,A[i]))\\n\\nfor i in range(1,N//2+1):\\n    for j in range(2*i,N+1,i):\\n        Di.add_edge(i,j,inf)\\n\\nprint((ans-Di.flow(s,t)))\\n\", \"#!/usr/bin/env python3\\n\\nfrom sys import stdin\\nfrom fractions import gcd\\t# math.gcd is introduced by python 3.5\\nfrom functools import reduce\\n\\ndef lcm(x, y):\\n  \\\"\\\"\\\"The least common multiple of x and y.\\\"\\\"\\\"\\n  return x * (y // gcd(x, y))\\n\\ndef tuples(m, N):\\n  \\\"\\\"\\\"\\n  List of list of m'-tuples over {1,2,3,...,N} for 0 <= m' <= m.\\n  Every m-tuple does not contain a multiple of some j in the tuple.\\n  The lcm of the m-tuple is less than or equal to N.\\n  \\\"\\\"\\\"\\n  if m == 0: return [[()]]\\n  ts = tuples(m - 1, N)\\n  if len(ts[-1]) == 0: return ts\\n\\n  ls = []\\n  for t in ts[-1]:\\n    lc = reduce(lcm, t) if len(t) > 0 else 1\\n    mi = min(t)         if len(t) > 0 else N + 1\\n    for i in range(mi - 1, 0, -1):\\n      if any(j % i == 0 for j in t): continue\\n      if lcm(lc, i) > N: continue\\n      ls.append((i,) + t)\\n  ts.append(ls)\\n  return ts\\n\\ndef value(a, t):\\n  \\\"\\\"\\\"\\n  Total value of the jewels that are labeled a multiple of x\\n  for some x in t.\\n  \\\"\\\"\\\"\\n  used = [False for i in a]\\n  v = 0\\n  for x in t:\\n    for i in range(x - 1, len(a), x):\\n      if not used[i]:\\n        v = v + a[i]\\n        used[i] = True\\n  return v\\n\\ndef remove(a, t):\\n  \\\"\\\"\\\"\\n  Break all jewels that are labeled a multiple of x for some x in t.\\n  \\\"\\\"\\\"\\n  for x in t:\\n    for i in range(x - 1, len(a), x):\\n      a[i] = 0\\n\\ndef flatten(ls):\\n  \\\"\\\"\\\"Flatten a list of lists.\\\"\\\"\\\"\\n  return [x for l in ls for x in l]\\n\\ndef solve(a):\\n  n = len(a)\\n  tl = flatten(tuples(n, n))\\n  tl.sort(key=lambda t: [-x for x in t])\\n  for t in tl:\\n    if value(a, t) < 0: remove(a, t)\\n  return sum(a)\\n\\nN = int(stdin.readline())\\na = [int(w) for w in stdin.readline().split()]\\nif len(a) != N: raise\\nprint((solve(a)))\\n\", \"from  collections import deque\\nN=int(input())\\nP=[int(i) for i in input().split()]\\ninf = 10**20\\ntable=[[0]*(N+2) for i in range(N+2)]\\nfor i in range(1,N+1):\\n    if P[i-1]>0:\\n        table[i][N+1]=P[i-1]\\n    else:\\n        table[0][i]=-P[i-1]\\n    for j in range(2*i,N+1,i):\\n        table[i][j]=inf\\n        \\ndef bfs(x):\\n    visit[x]=0\\n    h=deque()\\n    h.append(x)\\n    while h:\\n        y=h.popleft()\\n        for i in range(N+2):\\n            if visit[i]==-1 and table[y][i]>0:\\n                visit[i]=visit[y]+1\\n                h.append(i)\\n    return 0\\n\\ndef dinic(s,t,f):\\n    if s==t:\\n        return f\\n    for i in range(N+2):\\n        if visit[i]>visit[s] and table[s][i]>0:\\n            df = dinic(i,t,min(f,table[s][i]))\\n            if df>0:\\n                table[s][i]-=df\\n                table[i][s]+=df\\n                return df\\n    return 0\\n\\nans=0\\nwhile True:\\n    visit=[-1]*(N+2)\\n    bfs(0)\\n    #print(table,visit)\\n    if visit[N+1]==-1:\\n        break\\n    while True:\\n        df=dinic(0,N+1,inf)\\n        if df==0:\\n            break\\n        ans+=df\\n        #print(ans)\\nnum=sum([p for p in P if p>0])\\nprint(num-ans)\", \"# -*- coding: utf-8 -*-\\n\\nimport sys\\n\\ndef input(): return sys.stdin.readline().strip()\\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\\ndef ceil(x, y=1): return int(-(-x // y))\\ndef INT(): return int(input())\\ndef MAP(): return list(map(int, input().split()))\\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\\ndef Yes(): print('Yes')\\ndef No(): print('No')\\ndef YES(): print('YES')\\ndef NO(): print('NO')\\nsys.setrecursionlimit(10 ** 9)\\nINF = 10 ** 18\\nMOD = 10 ** 9 + 7\\n\\nclass Dinic:\\n    \\\"\\\"\\\" \\u6700\\u5927\\u6d41(Dinic) \\\"\\\"\\\"\\n\\n    INF = 10 ** 18\\n\\n    def __init__(self, n):\\n        self.n = n\\n        self.links = [[] for _ in range(n)]\\n        self.depth = None\\n        self.progress = None\\n \\n    def add_link(self, _from, to, cap):\\n        self.links[_from].append([cap, to, len(self.links[to])])\\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\\n \\n    def bfs(self, s):\\n        from collections import deque\\n\\n        depth = [-1] * self.n\\n        depth[s] = 0\\n        q = deque([s])\\n        while q:\\n            v = q.popleft()\\n            for cap, to, _ in self.links[v]:\\n                if cap > 0 and depth[to] < 0:\\n                    depth[to] = depth[v] + 1\\n                    q.append(to)\\n        self.depth = depth\\n \\n    def dfs(self, v, t, flow):\\n        if v == t:\\n            return flow\\n        links_v = self.links[v]\\n        for i in range(self.progress[v], len(links_v)):\\n            self.progress[v] = i\\n            cap, to, rev = link = links_v[i]\\n            if cap == 0 or self.depth[v] >= self.depth[to]:\\n                continue\\n            d = self.dfs(to, t, min(flow, cap))\\n            if d == 0:\\n                continue\\n            link[0] -= d\\n            self.links[to][rev][0] += d\\n            return d\\n        return 0\\n \\n    def max_flow(self, s, t):\\n        INF = Dinic.INF\\n        flow = 0\\n        while True:\\n            self.bfs(s)\\n            if self.depth[t] < 0:\\n                return flow\\n            self.progress = [0] * self.n\\n            current_flow = self.dfs(s, t, INF)\\n            while current_flow > 0:\\n                flow += current_flow\\n                current_flow = self.dfs(s, t, INF)\\n\\nN = INT()\\nA = LIST()\\n\\n# \\u6700\\u5927\\u6d41\\u3092\\u6700\\u5c0f\\u30ab\\u30c3\\u30c8\\u306b\\u4f7f\\u7528\\u3001\\u6d41\\u91cf\\u304c\\u30b3\\u30b9\\u30c8\\u3068\\u307f\\u306a\\u305b\\u308b\\ndinic = Dinic(N+2)\\ns = N\\nt = N + 1\\ntotal = 0\\nfor i, a in enumerate(A):\\n    if a < 0:\\n        # \\u5143\\u3005\\u640d\\u5931\\u306e\\u90e8\\u5206\\u306f\\u305d\\u306e\\u307e\\u307e\\u30b3\\u30b9\\u30c8\\u3068\\u3057\\u3066\\u6271\\u3046\\n        dinic.add_link(s, i, -a)\\n    elif a > 0:\\n        # \\u5229\\u76ca\\u306b\\u3064\\u3044\\u3066\\u306f\\u3001\\u4e88\\u3081\\u5229\\u76ca\\u3092\\u5f97\\u3089\\u308c\\u308b\\u3068\\u3057\\u3066\\u3001\\u5f97\\u3089\\u308c\\u306a\\u304f\\u306a\\u308b\\u65b9\\u306e\\u9078\\u629e\\u80a2\\u306b\\u30b3\\u30b9\\u30c8\\u3068\\u3057\\u3066\\u8db3\\u3059\\n        dinic.add_link(i, t, a)\\n        total += a\\n\\nfor i in range(1, N+1):\\n    j = i\\n    while j <= N:\\n        # \\u5236\\u7d04\\u3067\\u7570\\u306a\\u308b\\u9078\\u629e\\u80a2\\u3092\\u9078\\u3079\\u306a\\u3044\\u7d44\\u306b\\u30b3\\u30b9\\u30c8INF\\u306e\\u8fba\\u3092\\u5f35\\u308b\\n        dinic.add_link(i-1, j-1, INF)\\n        j += i\\n\\nres = dinic.max_flow(s, t)\\n# \\u6700\\u5927\\u5229\\u76ca = \\u8abf\\u6574\\u5206 - \\u6700\\u5c0f\\u30ab\\u30c3\\u30c8\\nprint((total - res))\\n\", \"# Dinic's algorithm\\nfrom collections import deque\\nclass Dinic:\\n    def __init__(self, N):\\n        self.N = N\\n        self.G = [[] for i in range(N)]\\n\\n    def add_edge(self, fr, to, cap):\\n        forward = [to, cap, None]\\n        forward[2] = backward = [fr, 0, forward]\\n        self.G[fr].append(forward)\\n        self.G[to].append(backward)\\n\\n    def add_multi_edge(self, v1, v2, cap1, cap2):\\n        edge1 = [v2, cap1, None]\\n        edge1[2] = edge2 = [v1, cap2, edge1]\\n        self.G[v1].append(edge1)\\n        self.G[v2].append(edge2)\\n\\n    def bfs(self, s, t):\\n        self.level = level = [None]*self.N\\n        deq = deque([s])\\n        level[s] = 0\\n        G = self.G\\n        while deq:\\n            v = deq.popleft()\\n            lv = level[v] + 1\\n            for w, cap, _ in G[v]:\\n                if cap and level[w] is None:\\n                    level[w] = lv\\n                    deq.append(w)\\n        return level[t] is not None\\n\\n    def dfs(self, v, t, f):\\n        if v == t:\\n            return f\\n        level = self.level\\n        for e in self.it[v]:\\n            w, cap, rev = e\\n            if cap and level[v] < level[w]:\\n                d = self.dfs(w, t, min(f, cap))\\n                if d:\\n                    e[1] -= d\\n                    rev[1] += d\\n                    return d\\n        return 0\\n\\n    def flow(self, s, t):\\n        flow = 0\\n        INF = 10**9 + 7\\n        G = self.G\\n        while self.bfs(s, t):\\n            *self.it, = map(iter, self.G)\\n            f = INF\\n            while f:\\n                f = self.dfs(s, t, INF)\\n                flow += f\\n        return flow\\n\\nN=int(input())\\na=list(map(int,input().split()))\\n\\njew=Dinic(N+2)\\nans=0\\nfor i in range(N):\\n    if a[i]>=0:\\n        ans+=a[i]\\n        jew.add_edge(0,i+1,a[i])\\n    else:\\n        jew.add_edge(i+1,N+1,-a[i])\\n\\ninf=10**15\\nfor i in range(1,N+1):\\n    for j in range(1,N//i+1):\\n        jew.add_edge(i*j,i,inf)\\n\\nf=jew.flow(0,N+1)\\nprint(ans-f)\", \"from scipy.sparse.csgraph import dijkstra\\nimport numpy as np\\nn=int(input())\\na=[0]+[int(j)for j in input().split()]\\ngraph=np.zeros((n+2,n+2),dtype=np.int64)\\nstart,goal=0,n+1\\nfor i,j in enumerate(a[1:],1):\\n    if j>=0:\\n        graph[start,i]=j\\n    else:\\n        graph[i,goal]=-j\\nfor i in range(1,n+1):\\n    for j in range(2*i,n+1,i):\\n        graph[j,i]=10**18\\ndef max_flow(graph):\\n    flow=0\\n    while True:\\n        dist,pred=dijkstra(graph,indices=start,return_predecessors=True,unweighted=True)\\n        if dist[goal]==np.inf:\\n            return flow\\n        path=[]\\n        v=goal\\n        while True:\\n            path.append((pred[v],v))\\n            v=pred[v]\\n            if v==start:\\n                break\\n        add_flow=min(graph[x][y] for x,y in path)\\n        for x,y in path:\\n            graph[x][y]-=add_flow\\n            graph[y][x]+=add_flow\\n        flow+=add_flow\\nprint(sum(i for i in a if i>0)-max_flow(graph))\", \"#!usr/bin/env python3\\nfrom collections import defaultdict,deque\\nfrom heapq import heappush, heappop\\nimport sys\\nimport math\\nimport bisect\\nimport random\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\ndef I(): return int(sys.stdin.readline())\\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\\ndef S():\\n    res = list(sys.stdin.readline())\\n    if res[-1] == \\\"\\\\n\\\":\\n        return res[:-1]\\n    return res\\ndef IR(n):\\n    return [I() for i in range(n)]\\ndef LIR(n):\\n    return [LI() for i in range(n)]\\ndef SR(n):\\n    return [S() for i in range(n)]\\ndef LSR(n):\\n    return [LS() for i in range(n)]\\n\\nsys.setrecursionlimit(1000000)\\nmod = 1000000007\\n\\n#A\\ndef A():\\n\\n    return\\n\\n#B\\ndef B():\\n\\n    return\\n\\n#C\\ndef C():\\n    def bfs(s,g,n):\\n        bfs_map = [-1 for i in range(n)]\\n        bfs_map[s] = 0\\n        q = deque()\\n        q.append(s)\\n        fin = False\\n        while q:\\n            x = q.popleft()\\n            for y in range(n):\\n                if c[x][y] > 0 and bfs_map[y] < 0:\\n                    bfs_map[y] = bfs_map[x]+1\\n                    if y == g:\\n                        fin = True\\n                        break\\n                    q.append(y)\\n            if fin:\\n                break\\n\\n        if bfs_map[g] == -1:\\n            return None,0\\n        path = [None]*(bfs_map[g]+1)\\n        m = float(\\\"inf\\\")\\n        path[bfs_map[g]] = g\\n        y = g\\n        for i in range(bfs_map[g])[::-1]:\\n            for x in range(n):\\n                if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\\n                    path[i] = x\\n                    if c[x][y] < m:\\n                        m = c[x][y]\\n                    y = x\\n                    break\\n        return path,m\\n\\n    def ford_fulkerson(s,g,c,n):\\n        f = 0\\n        while 1:\\n            p,m = bfs(s,g,n)\\n            if not m:break\\n            f += m\\n            for i in range(len(p)-1):\\n                c[p[i]][p[i+1]] -= m\\n                c[p[i+1]][p[i]] += m\\n        return f\\n\\n    n = I()\\n    a = LI()\\n    e = n+2\\n    ma = 10**9\\n    c = [[0]*e for i in range(e)]\\n    for i in range(n):\\n        d = i+1\\n        j = 2*d\\n        c[0][d] = ma\\n        c[d][n+1] = ma-a[i]\\n        while j <= n:\\n            c[j][d] = float(\\\"inf\\\")\\n            j += d\\n    print((ma*n-ford_fulkerson(0,n+1,c,e)))\\n    return\\n\\n#D\\ndef D():\\n\\n    return\\n\\n#E\\ndef E():\\n\\n    return\\n\\n#F\\ndef F():\\n\\n    return\\n\\n#Solve\\ndef __starting_point():\\n    C()\\n\\n__starting_point()\", \"import networkx as nx\\n\\nn = int(input())\\nA = list(map(int, input().split()))\\nG = nx.DiGraph()\\n\\nsource = \\\"source\\\"\\nsink = \\\"sink\\\"\\n\\nfor i in range(1, n + 1):\\n    x, y = A[i - 1], 0\\n    if A[i - 1] < 0:\\n        x, y = y, -x\\n    G.add_edge(source, i, capacity=x)\\n    G.add_edge(i, sink, capacity=y)\\n\\nfor i in range(1, n // 2 + 1):\\n    for j in range(2 * i, n + 1, i):\\n        # print(i, j)\\n        G.add_edge(j, i)\\n\\ntry:\\n    mincut, cut_dic = nx.minimum_cut(G, source, sink)\\n    ans = 0\\n    for c in cut_dic[0]:\\n        if c == source:\\n            continue\\n        ans += A[c - 1]\\n    print(ans)\\n\\n\\nexcept nx.NetworkXError:\\n    print((0))\\n\", \"n = int(input())\\na = [0] + list(map(int, input().split()))\\nalive = [1 for i in range(n + 1)]\\nsol = sum(a)\\nwhile True:\\n    pot = []\\n    change = False\\n    for i in range(n, 0, -1):\\n        if a[i] >= 0 or alive[i] == 0:\\n            continue\\n        saldo = 0\\n        j = i\\n        while j <= n:\\n            saldo += alive[j] * a[j]\\n            j += i\\n        if saldo > 0:\\n            pot.append(i)\\n            continue\\n        change = True\\n        sol -= saldo\\n        j = i\\n        while j <= n:\\n            alive[j] = 0\\n            j += i\\n    if change:\\n        continue\\n    k = len(pot)\\n    for i in range(k):\\n        if change: break\\n        for j in range(i):\\n            saldo = 0\\n            for v in range(1, n + 1):\\n                if v % pot[i] == 0 or v % pot[j] == 0:\\n                    saldo += alive[v] * a[v]\\n            if saldo <= 0:\\n                change = True\\n                sol -= saldo\\n                for v in range(1, n + 1):\\n                    if v % pot[i] == 0 or v % pot[j] == 0:\\n                        alive[v] = 0\\n                break\\n    if not change:\\n        break\\nprint(sol)\\n\", \"from sys import stdin\\nimport sys\\nimport math\\nfrom functools import reduce\\nimport functools\\nimport itertools\\nfrom collections import deque,Counter,defaultdict\\nfrom operator import mul\\nimport copy\\n# ! /usr/bin/env python\\n# -*- coding: utf-8 -*-\\nimport heapq\\nsys.setrecursionlimit(10**6)\\n# INF =  float(\\\"inf\\\")\\nINF = 10**18\\nimport bisect\\nimport statistics\\nmod = 10**9+7\\n# mod = 998244353\\n\\n# Dinic's algorithm\\nfrom collections import deque\\nclass Dinic:\\n    def __init__(self, N):\\n        self.N = N\\n        self.G = [[] for i in range(N)]\\n\\n    def add_edge(self, fr, to, cap):\\n        # \\u59cb\\u70b9\\u30ce\\u30fc\\u30c9idx\\uff0c\\u7d42\\u70b9\\u30ce\\u30fc\\u30c9idx\\uff0c\\u5bb9\\u91cf\\u3092input\\n        forward = [to, cap, None]\\n        forward[2] = backward = [fr, 0, forward]\\n        self.G[fr].append(forward)\\n        self.G[to].append(backward)\\n\\n    def add_multi_edge(self, v1, v2, cap1, cap2):\\n        edge1 = [v2, cap1, None]\\n        edge1[2] = edge2 = [v1, cap2, edge1]\\n        self.G[v1].append(edge1)\\n        self.G[v2].append(edge2)\\n\\n    def bfs(self, s, t):\\n        self.level = level = [None]*self.N\\n        deq = deque([s])\\n        level[s] = 0\\n        G = self.G\\n        while deq:\\n            v = deq.popleft()\\n            lv = level[v] + 1\\n            for w, cap, _ in G[v]:\\n                if cap and level[w] is None:\\n                    level[w] = lv\\n                    deq.append(w)\\n        return level[t] is not None\\n\\n    def dfs(self, v, t, f):\\n        if v == t:\\n            return f\\n        level = self.level\\n        for e in self.it[v]:\\n            w, cap, rev = e\\n            if cap and level[v] < level[w]:\\n                d = self.dfs(w, t, min(f, cap))\\n                if d:\\n                    e[1] -= d\\n                    rev[1] += d\\n                    return d\\n        return 0\\n\\n    def flow(self, s, t):\\n        # source/target\\u30ce\\u30fc\\u30c9\\u306eidx\\u3092\\u5165\\u529b\\u3059\\u308b\\u3068\\u6700\\u5927\\u30d5\\u30ed\\u30fc\\uff08\\uff1d\\u6700\\u5c0f\\u30ab\\u30c3\\u30c8\\uff09\\u304c\\u51fa\\u529b\\n        flow = 0\\n        INF = 10**9 + 7\\n        G = self.G\\n        while self.bfs(s, t):\\n            *self.it, = map(iter, self.G)\\n            f = INF\\n            while f:\\n                f = self.dfs(s, t, INF)\\n                flow += f\\n        return flow\\n\\nN = int(input())\\na = [0] + list(map(int, input().split()))\\n\\ndinic = Dinic(N+2)\\n\\nfor i in range(1,N+1):\\n    x = a[i]\\n    if x >= 0:\\n        dinic.add_edge(0, i, 0)\\n        dinic.add_edge(i, N+1, x)\\n    else:\\n        dinic.add_edge(0, i, abs(x))\\n        dinic.add_edge(i, N+1, 0)\\n\\nfor i in range(1,N+1):\\n    for j in range(2,N//i + 1):\\n        dinic.add_edge(i, j*i, INF)\\n\\nprint(sum([max(aa,0) for aa in a]) - dinic.flow(0, N+1))\", \"N=int(input())\\nP=[int(i) for i in input().split()]\\ninf = 10**20\\ntable=[[0]*(N+2) for i in range(N+2)]\\nfor i in range(1,N+1):\\n    if P[i-1]>0:\\n        table[i][N+1]=P[i-1]\\n    else:\\n        table[0][i]=-P[i-1]\\n    for j in range(2*i,N+1,i):\\n        table[i][j]=inf\\n#print(table)\\ndef fk(x,t,f):\\n    #print(x)\\n    visit[x]=True\\n    if x==t:\\n        return f\\n    for i in range(N+2):\\n        if (not visit[i]) and table[x][i]>0:\\n            df=fk(i,t,min(f,table[x][i]))\\n            if df>0:\\n                table[x][i]-=df\\n                table[i][x]+=df\\n                return df\\n    return 0\\n\\nans=0\\nwhile True:\\n    visit=[False]*(N+2)\\n    df=fk(0,N+1,inf)\\n    if df>0:\\n        ans+=df\\n    else:\\n        break\\nnum=sum([p for p in P if p>0])\\nprint(num-ans)\", \"from collections import deque\\n\\n# \\u30b0\\u30e9\\u30d5\\u306b\\u8fba\\u3092\\u8ffd\\u52a0\\u3059\\u308b\\ndef addEdge(adjL, vFr, vTo, cap):\\n    adjL[vFr].append([vTo, cap, len(adjL[vTo])])\\n    adjL[vTo].append([vFr, 0, len(adjL[vFr]) - 1]) # \\u9006\\u8fba\\n\\n\\n# Dinic\\u6cd5\\uff08\\u6700\\u5927\\u30d5\\u30ed\\u30fc\\u3092\\u6c42\\u3081\\u308b\\uff09\\ndef Dinic(adjL, vSt, vEn):\\n\\n    # \\u59cb\\u70b9\\u304b\\u3089\\u306e\\u6700\\u77ed\\u8ddd\\u96e2\\u3092\\u3001BFS\\u3067\\u6c42\\u3081\\u308b\\n    def BFS(vSt):\\n        dist[vSt] = 0\\n        Q = deque([vSt])\\n        while Q:\\n            vNow = Q.popleft()\\n\\n            for i, (v2, cap, iRev) in enumerate(adjL[vNow]):\\n                if dist[v2] == -1 and cap > 0:\\n                    # \\u672a\\u63a2\\u7d22\\u306e\\u9802\\u70b9\\u3078\\u306e\\u8fba\\u306e\\u5bb9\\u91cf\\u306b\\u7a7a\\u304d\\u304c\\u3042\\u308b\\u5834\\u5408\\u3001\\u63a2\\u7d22\\u3059\\u308b\\n                    dist[v2] = dist[vNow] + 1\\n                    Q.append(v2)\\n\\n\\n    # \\u6b8b\\u4f59\\u30b0\\u30e9\\u30d5\\u306e\\u59cb\\u70b9\\u304b\\u3089\\u7d42\\u70b9\\u307e\\u3067\\u306e\\u7d4c\\u8def\\uff08\\u5897\\u52a0\\u30d1\\u30b9\\uff09\\u3092\\u3001DFS\\u3067\\u63a2\\u7d22\\u3059\\u308b\\n    def DFS(vNow, vEn, fNow):\\n        if vNow == vEn:\\n            # \\u7d42\\u70b9\\u306b\\u5230\\u9054\\u3057\\u305f\\u3089\\u3001\\u30d5\\u30ed\\u30fc\\u306e\\u5897\\u52a0\\u91cf\\u3092\\u8fd4\\u3059\\n            return fNow\\n\\n        # \\u524d\\u56de\\u306e\\u7d9a\\u304d\\u304b\\u3089\\u3001\\u63a2\\u7d22\\u3092\\u518d\\u958b\\u3059\\u308b\\n        iSt = iNext[vNow]\\n        for i, (v2, cap, iRev) in enumerate(adjL[vNow][iSt:], iSt):\\n            if dist[vNow] < dist[v2] and cap > 0:\\n                # \\u59cb\\u70b9\\u304b\\u3089\\u306e\\u6700\\u77ed\\u8ddd\\u96e2\\u304c\\u5897\\u52a0\\u3059\\u308b\\u9802\\u70b9\\u3078\\u306e\\u8fba\\u306e\\u5bb9\\u91cf\\u306b\\u7a7a\\u304d\\u304c\\u3042\\u308b\\u5834\\u5408\\u3001\\u63a2\\u7d22\\u3059\\u308b\\n                df = DFS(v2, vEn, min(fNow, cap))\\n                if df > 0:\\n                    # \\u59cb\\u70b9\\u304b\\u3089\\u7d42\\u70b9\\u307e\\u3067\\u306e\\u7d4c\\u8def\\u3092\\u9061\\u3063\\u3066\\u3001\\u8fba\\u306e\\u30d5\\u30ed\\u30fc\\u3092\\u5909\\u66f4\\u3059\\u308b\\n                    adjL[vNow][i][1] -= df\\n                    adjL[v2][iRev][1] += df\\n                    return df\\n\\n            iNext[vNow] += 1\\n\\n        # \\u73fe\\u5728\\u306e\\u9802\\u70b9\\u304b\\u3089\\u306e\\u63a2\\u7d22\\u5148\\u304c\\u306a\\u3044\\u5834\\u5408\\u3001\\u30bc\\u30ed\\u3092\\u8fd4\\u3059\\n        return 0\\n\\n\\n    numV = len(adjL)\\n    MaximumFlow = 0\\n    while True:\\n        # \\u59cb\\u70b9\\u304b\\u3089\\u306e\\u6700\\u77ed\\u8ddd\\u96e2\\u3092\\u3001BFS\\u3067\\u6c42\\u3081\\u308b\\n        dist = [-1] * numV\\n        BFS(vSt)\\n        if dist[vEn] == -1:\\n            # \\u7d42\\u70b9\\u307e\\u3067\\u306e\\u7d4c\\u8def\\u304c\\u898b\\u3064\\u304b\\u3089\\u306a\\u3044\\u5834\\u5408\\u3001\\u6700\\u5927\\u30d5\\u30ed\\u30fc\\u306e\\u5024\\u3092\\u8fd4\\u3059\\n            return MaximumFlow\\n\\n        iNext = [0] * numV\\n        while True:\\n            # \\u6b8b\\u4f59\\u30b0\\u30e9\\u30d5\\u306e\\u59cb\\u70b9\\u304b\\u3089\\u7d42\\u70b9\\u307e\\u3067\\u306e\\u7d4c\\u8def\\uff08\\u5897\\u52a0\\u30d1\\u30b9\\uff09\\u3092\\u3001DFS\\u3067\\u63a2\\u7d22\\u3059\\u308b\\n            df = DFS(vSt, vEn, float('inf'))\\n\\n            if df == 0:\\n                # \\u7d4c\\u8def\\u304c\\u898b\\u3064\\u304b\\u3089\\u306a\\u3044\\u5834\\u5408\\u3001\\u30eb\\u30fc\\u30d7\\u3092\\u629c\\u3051\\u308b\\n                break\\n\\n            # \\u30d5\\u30ed\\u30fc\\u3092\\u52a0\\u7b97\\u3059\\u308b\\n            MaximumFlow += df\\n\\n\\nN = int(input())\\nAs = list(map(int, input().split()))\\n\\nadjList = [[] for v in range(N + 2)]\\nfor i, A in enumerate(As, 1):\\n    if A <= 0:\\n        addEdge(adjList, 0, i, -A)\\n    else:\\n        addEdge(adjList, i, N + 1, A)\\n\\nfor i in range(1, N + 1):\\n    for j in range(2 * i, N + 1, i):\\n        addEdge(adjList, i, j, float('inf'))\\n\\n# Dinic\\u6cd5\\uff08\\u6700\\u5927\\u30d5\\u30ed\\u30fc\\u3092\\u6c42\\u3081\\u308b\\uff09\\nmf = Dinic(adjList, 0, N + 1)\\nprint((sum([A for A in As if A > 0]) - mf))\\n\", \"class Dinic:\\n\\n\\tdef __init__(self, v, inf=float(\\\"inf\\\")):\\n\\t\\tself.V = v\\n\\t\\tself.inf = inf\\n\\t\\tself.G = [[] for _ in range(v)]\\n\\t\\tself.level = [0 for _ in range(v)]\\n\\t\\tself.iter = [0 for _ in range(v)]\\n\\n\\tdef addEdge(self, fm, to, cap):\\n\\t\\t'''\\n\\t\\tto:\\u884c\\u304d\\u5148\\n\\t\\tcap:\\u5bb9\\u91cf\\n\\t\\trev:\\u53cd\\u5bfe\\u5074\\u306e\\u8fba\\n\\t\\t'''\\n\\t\\tself.G[fm].append({'to':to, 'cap':cap, 'rev':len(self.G[to])})\\n\\t\\tself.G[to].append({'to':fm, 'cap':0, 'rev':len(self.G[fm])-1})\\n\\n\\n\\t# s\\u304b\\u3089\\u306e\\u6700\\u77ed\\u8ddd\\u96e2\\u3092bfs\\u3067\\u8a08\\u7b97\\n\\tdef bfs(self, s):\\n\\t\\timport queue\\n\\t\\tself.level = [-1 for _ in range(self.V)]\\n\\t\\tself.level[s] = 0\\n\\t\\tque = queue.Queue()\\n\\t\\tque.put(s)\\n\\n\\t\\twhile not que.empty():\\n\\t\\t\\tv = que.get()\\n\\t\\t\\tfor i in range(len(self.G[v])):\\n\\t\\t\\t\\te = self.G[v][i]\\n\\t\\t\\t\\tif e['cap'] > 0 and self.level[e['to']] < 0:\\n\\t\\t\\t\\t\\tself.level[e['to']] = self.level[v] + 1\\n\\t\\t\\t\\t\\tque.put(e['to'])\\n\\n\\n\\tdef dfs(self, v, t, f):\\n\\t\\tif v == t: return f\\n\\t\\tfor i in range(self.iter[v], len(self.G[v])):\\n\\t\\t\\tself.iter[v] = i\\n\\t\\t\\te = self.G[v][i]\\n\\t\\t\\tif e['cap'] > 0 and self.level[v] < self.level[e['to']]:\\n\\t\\t\\t\\td = self.dfs(e['to'], t ,min(f,e['cap']))\\n\\t\\t\\t\\tif d > 0:\\n\\t\\t\\t\\t\\te['cap'] -= d\\n\\t\\t\\t\\t\\tself.G[e['to']][e['rev']]['cap'] += d\\n\\t\\t\\t\\t\\treturn d\\n\\t\\treturn 0\\n\\n\\n\\tdef max_flow(self,s,t):\\n\\t\\tflow = 0\\n\\t\\twhile True:\\n\\t\\t\\tself.bfs(s)\\n\\t\\t\\tif self.level[t] < 0: return flow\\n\\t\\t\\tself.iter = [0 for _ in range(self.V)]\\n\\t\\t\\tf = self.dfs(s,t,self.inf)\\n\\t\\t\\twhile f > 0:\\n\\t\\t\\t\\tflow += f\\n\\t\\t\\t\\tf = self.dfs(s,t,self.inf)\\n\\n\\n\\nfrom sys import stdin, setrecursionlimit\\ndef IL():return list(map(int, stdin.readline().split()))\\n \\nsetrecursionlimit(1000000)\\n\\ndef main():\\n\\tN = int(input())\\n\\ta = IL()\\n\\td = Dinic(N+2)\\n\\tres = 0\\n\\tfor i in range(N):\\n\\t    d.addEdge(N,i, max(0, -a[i]))\\n\\t    d.addEdge(i,N+1, max(0,a[i]))\\n\\t    res+=max(0,a[i])\\n\\t    t = 2*i+2\\n\\t    while t<=N:\\n\\t        d.addEdge(i,t-1,float('inf'))\\n\\t        t+=i+1\\n\\tprint(res-d.max_flow(N,N+1))\\n\\t\\n\\t\\ndef __starting_point(): main()\\n__starting_point()\"]",
    "test": "{\"inputs\": [\"6\\n1 2 -6 4 5 3\\n\", \"6\\n100 -100 -100 -100 100 -100\\n\", \"5\\n-1 -2 -3 -4 -5\\n\", \"2\\n-1000 100000\\n\", \"98\\n-732082503 484310639 410514008 709792355 513377678 -643565830 -558057755 673249507 -879378244 595054694 886176495 197608768 127996665 169589649 -210521660 98709367 -47020110 536605652 -136787827 -182892932 -888829303 -901014895 677846910 -190813377 -671953311 731321705 -974264455 -866044167 396491508 539073495 -754869657 575975333 453688989 681855145 -399761109 -386950225 -816040302 -202359086 915081824 241112350 983080677 19109453 124297220 792149360 -675138311 369322621 -741920995 -730315755 -61806783 -929304962 -11041147 -306944960 -831325318 577854177 -166790083 -612869698 -912842168 -77723620 -154118760 171010456 81157346 -944847943 221125914 -93996263 733731784 -3770343 -717580505 -160645288 -897600312 -815089273 106416539 265982095 321873832 333934673 438264906 -770570932 560539451 682769573 -910555069 -300928360 623197765 597899472 -716112873 -189037966 41058203 -730570899 852023432 668889800 -240064056 308504995 -856589035 -958731159 -683108502 254779243 311356691 206150940 -121876641 209576340\\n\", \"59\\n160830807 -416156479 199560179 -853012066 710795756 59706390 -126534735 -533380565 -436461607 -606769791 964941203 973944412 209040160 -440141890 272284977 -24455080 541065674 -608858491 -552221031 -325674848 -869049719 112273618 -44909036 709917809 -889888478 828350586 -756306236 897950232 747965143 980236164 -256537312 675719397 -316188281 81239673 984686385 706814364 436878374 501259205 996793252 753853376 -578171523 109290638 -947689607 474161031 846030019 -839480662 -747435765 920826722 620400742 445643214 240284696 -689463601 -213600174 -904115584 819049613 -525205881 657681989 663819315 629999402\\n\", \"96\\n-125532817 37532357 -789927612 -704294197 689073833 665051963 186409982 -102118908 461285711 -635446845 481299943 325948583 -986950485 83194911 -767331704 590762631 -109617820 267545937 -352813770 -828962357 -670002432 -496185743 519391446 171046017 -441814387 -231094607 716209134 -36839600 -543185999 -979699262 -380837479 432099171 737069321 -716778206 568696245 -58628109 -557821450 780061711 -763498678 819814668 -288794348 -110689860 -861558297 560065595 994313123 -183937522 -288316924 -942909186 -898740553 859197551 402924494 -32549764 -665747627 -153846077 336421648 925274904 805917527 970139960 -792501734 681406413 -401588536 100676385 553663720 418240936 734639473 453750827 190820351 -312555869 -813548198 -256293424 970718342 839480836 -935150371 -86116783 324764491 769835264 -959112682 180615239 -20887804 -42594936 618787192 195125831 170718143 254236202 618071475 -156358502 197646448 426430008 -6644319 470387581 402827160 -992311672 803059296 -27036132 964867342 -935387335\\n\", \"50\\n246805875 -890461718 666044295 -626442309 97497884 -184675091 -762138672 -321558599 -416699058 258579029 993785257 -514270374 -812670604 480060224 -120578051 -511401973 -455830277 -432567866 716410610 500422920 169329321 669262133 -16476259 -744517869 943553514 -366003077 -214874285 -589153263 -865453392 853498992 3925995 -463210266 437007593 874150636 777084847 909645665 -191720668 767437115 976555827 -264656754 -258627265 -174566812 -875127007 363522806 510578276 280369871 855704690 836408139 -205939340 -102690517\\n\", \"95\\n379870403 -961763837 42910244 -909222793 995367621 436418760 143131163 928259357 -516551023 338055173 18694983 -89037336 -508381437 377697496 -628121940 247187583 776580124 829270523 -521450211 -251568842 335203333 -452203116 -500576159 -850783378 617658109 -731136251 105321372 494506438 -79814582 913172054 167662120 -884079322 -119042204 584277758 -397960114 353729691 598719245 -185076926 68918562 143126602 579169992 -546941916 -441627910 -850274852 -428742924 844012003 987233526 -614902014 -72666468 729587094 -468345645 -85152489 -417330667 -134665352 34208577 -867280179 349484064 166843194 -819998290 -780904952 858428594 594072779 617645809 266543726 -819088234 -760280439 74314214 943134516 396209456 -357285086 -898239037 631493714 525234956 -122531321 -103139961 -216303704 84084762 -108176666 234462195 397627658 279697902 935544356 679667639 -563112231 714356409 673229492 -528848239 -464681496 290989491 974266738 -927741544 -250179681 471853662 483749708 -151262858\\n\", \"51\\n480315750 858482337 -45774653 281944274 -280152130 585669201 -738732698 -628982278 -169864664 -424218811 -849581207 -230045639 463944177 -914595406 -562533330 -564382761 972264712 928265005 710343531 -699777060 -851828755 -642490917 -550664793 824964298 -550053516 -415911087 -493702405 -795825378 -134020607 -699376318 -813724709 176664518 499291516 -840732220 -847053965 621835242 953787985 471108829 -880905678 88215262 85299776 -732996284 33758567 -786868529 -142779984 -220330641 603564484 288966874 730585874 883607376 272152033\\n\", \"98\\n864509457 -865667143 -886261580 -906439231 143111756 -980626347 -81738602 495262733 156079208 911382813 991721980 542411093 745404340 -664655680 231941221 -535898320 -701946950 -611619580 -909197605 322691804 442898355 -594969532 847937328 -939012937 471152061 719359747 107915672 -110277207 389557198 445191925 460291207 -323036967 188829560 -927970321 -267222513 388292640 219563260 -963082961 537875404 324224103 578442556 780434286 457811747 -953034782 -178651092 -124679751 -297000479 507110571 -757765504 645754959 96957387 -413706382 442942396 130563952 -784664626 -810041815 -801195006 771191684 804585431 -306639848 -183578191 170712754 -115480571 -76236283 396879494 -151558419 -660771977 482601947 -296095580 -132574152 -121356251 -81032394 684271014 317027007 81614768 87563162 923853985 908570672 727747112 -502559509 637622887 -244780440 -117166396 -435453385 -811705957 278947396 912911676 -661834437 -658133387 868106518 -647476607 452660654 -296808139 -117996035 724222205 153874063 -247148691 728646746\\n\", \"27\\n732695891 680410489 698012296 933753931 506278944 767298893 -652488891 -319537137 61539280 209341308 587606483 229720512 756910003 854459007 329423170 773026083 -544891835 342790984 490901272 -392496837 395867895 597349389 -795807628 381476384 210218680 931785597 -680297525\\n\", \"97\\n266955458 943345734 -368895265 -821575631 493340861 -557381300 223852518 -158715469 961913291 -26966071 708161916 -863565426 -747488907 -141220751 679205890 902087900 -11765114 -802811813 -711992611 998353560 95296747 -522435914 373377231 776340798 60625172 -62083616 -839282751 -602280926 303089612 597572349 -77235043 -330704988 -948342353 508941399 -995404544 -892882712 -538077944 659926472 -709078649 213908090 -941483600 496512788 -406664762 781269048 755295157 309036406 235118129 187927850 -959113887 -358179928 -617713509 -966993697 255507727 -321681141 -409032350 606149311 -211004080 -380492498 916795820 333506838 -781226804 -793321806 624794727 688933040 631293506 -485878318 457284766 -434715206 -12676036 719149950 311453281 -979486022 -964079468 484360290 896836168 643795678 -915360894 -18990215 -828086409 -436947094 -602060681 330664120 -405984409 -755245378 -356215565 -157911862 -36794425 -607213323 109188258 639295476 158371123 826277775 884277238 769826349 355878849 183968214 -143822300\\n\", \"46\\n-190457044 -386076312 867933504 11131516 816681300 135008719 426518229 -255668756 285920005 891606236 86320956 -927572449 -91481267 -118274749 -461555544 166514979 84825257 66228766 -239444966 -502824988 563288795 -22552317 -478178013 570542783 -329204 -265925299 948224776 -222560036 226559414 -56725357 -869534313 137213291 -907574962 -566846367 -299072227 -246968011 995964774 -261264584 896149746 315922116 760769464 515688497 665640044 314805338 -160330611 -624625837\\n\", \"98\\n314509832 -617908018 518835922 -520341982 -120849880 -259878728 720752128 -467728565 -259256252 209652650 -294022391 70379346 -723962834 688810355 -540028557 195945993 837076825 86528478 -802607782 -57437535 361796229 -816765080 -272104241 636363854 409709595 29600120 -222509941 336847911 -516635879 -904668431 215611421 -427252306 169728767 15122637 415678958 592224164 -5393790 -653502389 -595445642 748611707 -708154741 -539289114 -193320465 -475901158 -158967647 -112013766 -970489833 688374530 -718372532 646361685 -323678949 928235159 520526676 142749649 463832478 -138012514 871484950 -146850485 277472093 -541398022 -20788647 465370961 -563861849 597848135 912060991 406131724 584171422 -124460085 -485384609 -115374373 -89406174 58099841 -927845868 947646258 -359005015 -292953157 -967679666 50860410 421071629 138615473 588547875 297547628 -902978447 636804238 -771564936 436027697 -183338093 -749648274 -561756683 644354135 -753132740 150974314 -592927662 180099702 686001679 -881338966 192545352 956323425\\n\", \"86\\n488580610 -497425866 -192024423 284936045 -412383268 974832727 -330601927 -851553834 945353583 711274105 642731184 427360265 88501157 896554836 689880151 -393602901 -104957875 413216385 352921664 239388619 288611383 -344918331 -684332637 961891736 -143989754 -251267048 448841745 -581347834 697167422 -38073517 -394957923 81150620 584817005 521904748 771887345 48145977 440264578 -715956153 53230283 648887132 -258402118 643232439 -438786208 200475543 564903925 -569094538 205672813 357235966 -4680697 497995752 -857565002 -721617382 -908934613 -852829247 677631477 626089627 -800971196 -157755467 892809094 438618129 453983861 740294594 708180678 -971538727 -13635113 -344037022 -187874095 647862153 463378802 892856683 13726928 -788808233 -400509240 410236506 827613930 343281124 254857162 -636944818 -848565032 74832540 -244324247 507273135 50293586 -247010455 -978150445 -784624751\\n\", \"99\\n122741031 -204980087 525357399 -35985856 -416421742 611495756 -929791499 -703341024 312660354 -8716403 -885125673 332761853 -601694152 -453492700 658205998 -888173729 58182557 620328675 -664005151 -864927032 645923185 675352889 -954440570 -792010737 -826546996 -44381354 332330747 -64136214 -790678352 -296084579 -244480980 -772375042 -425964702 -391276054 650734738 -377554590 -587415545 269978067 -292899235 105542408 514213110 -457527895 173475988 957868052 -560581924 -765594268 225395776 -996553584 458639494 640334468 592400411 913819872 -298917769 -485204315 637563767 399937856 -575532654 907299440 602288683 737463293 -101036208 -60716929 756434898 601256927 -342869091 834072903 -758076503 759751058 395812687 -943465113 -674028993 601518484 738953364 -569932247 -306363003 -37074221 -425095741 980607802 247313935 -86656058 -375846061 -736270307 -227767888 77835169 -39882120 991458743 -776275267 -456420406 924101784 820760583 -557509270 463841633 198578913 147673940 462655750 -955146078 324821275 -760593951 -107711424\\n\", \"67\\n342498977 -366090854 -277280076 804780980 -224444831 607221718 -99921030 -860283192 625877891 -674276160 695529897 -682285164 -142344727 71263543 163727641 581966829 -867749381 -120898288 -816632129 -478523751 771040439 -534643322 116833879 -40878830 603539005 830905221 558365923 651269803 -468147105 -10068232 346050673 -358816512 -931285173 -387109823 -275325947 293773379 -703566929 514862278 -28167837 588061879 115830657 -732391476 173783075 985171772 -311268655 -581757322 -758271648 -93012186 5595808 -14254920 -218133808 -862837048 -927938908 -880566692 849867654 -604371527 -345548440 498179960 543874212 185639625 22570680 160105014 59778731 180612946 58114182 -955482341 994510417\\n\", \"95\\n71414002 -147723385 50948068 -775502757 -137568826 555431680 42570426 -945052553 -499631715 -117214185 -80847 578863316 25466340 -758835099 -928408888 -2408023 -278478316 -839716014 -689402028 770073616 -241873504 633128169 -950746719 -226411928 961008705 356819394 818343184 915205110 28328359 -471148542 605843550 -69752047 408584316 166260340 156203986 -93975437 -26822166 -360797731 27651569 -315993536 137546346 -275947646 -650246639 154807545 184311682 243444775 60489058 912929095 431016448 681033061 -297295914 937659071 547497381 590511438 795957351 982184983 693894401 -153542659 498698969 -630587927 193503539 -563175681 -26015952 -643587006 100466489 -475146275 534832090 -327768108 902729468 -480734188 503227304 607141030 743448864 159599758 -709691291 -580611767 645361290 -890941025 487193768 -273778437 929703840 -15863917 -37669984 954211907 464882182 -66088848 100261391 -787316859 114672606 -100229553 998629742 472353547 161912569 -441782994 490951729\\n\", \"89\\n-59446479 957713271 -995213793 116546072 875731920 -178376990 783740488 212943574 896072331 690578728 149596012 -318744368 476525701 4634463 886285477 90211618 583158725 330646781 -717606550 -779967199 405552694 -623816607 702132046 -374184914 -674270511 120192677 -932457305 -137471102 -36015306 984260773 -756942290 -250194852 -438610568 -759551508 76473981 945512434 -284762122 -721875557 -844507530 -190803213 491118173 -774911995 -742669592 -645404115 807078076 -544288854 696946845 -400136383 966778799 146693851 -372054874 347279000 -380442932 603011793 778437201 -425685605 242678782 -9475641 816735290 -607304258 -889487951 619420873 697216606 338304377 408267586 -338158725 -771484962 724119879 -602597299 503717758 778686029 797111079 -725151817 -600566818 835154910 708360416 -291846733 -68043935 280813604 524458205 -231843425 -208680981 289846757 -949237985 -459196069 540574357 793191350 707579029 -824034429\\n\", \"96\\n536252133 560095389 51624819 638692416 384898188 723906213 11286724 938589049 741727514 -533325694 -230954564 101287676 676839501 -116465067 70747948 163789916 -129815932 -252532751 698541747 -741227795 579294077 -824709620 414429198 984134249 629361582 17745148 -462543541 -930314545 322636347 -145626292 -21429923 269031919 -945250139 -409039822 -486472515 -746953780 844995942 423183949 -54902024 692434524 442612736 231676102 778939737 -528390730 -378658398 -705397493 225625547 -420773822 577363142 -783802841 180530008 314898111 440520844 224339077 990261065 -376925931 305116694 -253435791 8476558 310985383 -43149598 -451919515 625543863 -789553934 734175179 -568973480 -273158476 -338978917 -468357246 235567336 -486053677 -117931027 -969218546 513712843 -263321495 648700382 -146893717 -554254229 684058474 -456352294 45474064 -877949272 -42058811 377974785 937504548 -321876954 507665853 298295446 562573742 -97817208 -74208617 -13648477 804869685 -241695485 230943175 95136740\\n\", \"50\\n-516476141 -643850367 968065390 937396345 -761786007 -387965609 -63294517 36897326 800500310 436072643 -171177011 -782838023 566692579 945690941 -212555829 -8799649 538580080 541281969 959647002 837370408 -106641964 70462741 477099032 -256211652 -88503411 -704498174 -762923496 351832998 -576712900 356326024 -540153009 763681142 377032866 -566356926 448718879 -199618835 -98882617 926047279 60033962 70403916 -283413439 -799930664 908610895 463244748 -564113295 -619460047 394626605 -926149894 -704969227 -962657222\\n\", \"97\\n-866011270 -917234705 46225231 -509043433 645849764 -486233863 912206705 -798200099 -56481209 846739685 -738676628 904344898 220968101 319281878 576497705 985914210 920490132 897254367 -84796627 265627267 771417380 344709850 -81893660 -251247492 -867094276 200057674 -763845920 391841934 340028921 116971140 -239563698 -585621812 -295664368 84410676 127036329 -95255036 -264216587 -65050888 435450429 536350801 -78768936 -578908259 -767718621 -152984455 982795745 305576562 989161194 562260928 -276662582 483572077 -686776387 -271241742 -327282462 -436742223 998073577 -302723261 296724179 170705359 327889244 972172520 65533928 -733827403 -875343303 -364709609 809275054 226701025 -531609947 93576678 -700007301 298286047 -108861602 -948765169 -389273918 210462246 70607869 933350662 -668826433 -953598937 541368131 -978149857 762506644 470145083 891184811 667297181 973079049 -984421672 -432888504 -114852393 231697107 136943246 -154946596 -951595080 -617303660 -767064285 -680052597 -300422138 910500145\\n\", \"47\\n158097562 547471580 681607780 -327720661 -738774270 817966740 779335774 68831534 -905123318 806340490 -73947501 -14634055 712267052 306842586 -83754249 984298031 -886051694 135552236 296727010 649265885 -359773630 -973151416 507691833 -845521344 308354994 593809122 -52197128 215168449 806088124 25693960 230065116 220276992 -743023182 479686091 812631728 -745495925 801138392 546602342 -763204866 -938301859 929683736 89325865 614619840 -53392535 527532890 447471756 633444055\\n\", \"99\\n865119910 -324217861 -564353406 -240821790 743729091 384978515 -76078266 105515720 724933537 -394973711 -846571917 551537423 -351513921 715380710 -853026592 584788726 30389517 -591459991 -237802902 792139217 434680109 -796964420 791195253 314024121 -344535785 807595929 187653875 153735851 697991369 -813923436 643467065 -999824834 554786062 -542866446 989401862 -659389432 -895678011 231147416 -661393731 -515925525 244636714 -847767157 781478170 -770147787 30558785 532742020 921576435 -807456170 -44919908 109344550 -754924546 447817774 431370509 -755721586 -288861275 -450857919 945148758 -58705720 467065198 -94137279 120473589 470612250 -285624562 376317980 -9535739 375300940 741152946 232628527 -249584239 476090052 -861950442 561594333 -506620495 -641323423 788922818 -706966814 -24538368 -534013102 820089685 985511598 863497022 -155552867 -750526919 -333267348 -364634064 -782587001 -619632341 -731165252 801304095 -612813108 -843846426 -564355135 -186458758 -573119122 542219434 -961083745 849034211 -61075718 127616533\\n\", \"68\\n-309479261 995339153 -226813347 408673914 838142330 -330941543 317391136 -697147594 -249011843 968107425 -667935512 637010093 765112298 21884978 -825927041 797210141 406582289 257938061 -252320861 442525047 789844807 958489452 402757081 535687660 297518559 926279430 -903270992 -80273249 763626809 -973550322 63961684 688457875 -920395230 -281968444 -863356821 -633036468 -945754797 -789385187 891252133 -160395254 429210076 360193976 599904506 298989740 -158977135 714532224 -187527425 -672551453 49069450 -800009078 -164904662 -321488749 -885464865 416276396 473614964 175331102 877017128 814604738 -621495679 309138149 412794879 -402890629 -817894395 571713161 -948555885 -994486980 446528193 -164474529\\n\", \"95\\n-714830391 -825047044 -497148400 328413216 -617390950 -986442978 582374526 94671079 -132181074 299069659 871760792 -702713231 -681440505 -279774084 419375729 202437939 -371634810 -240090589 -791285086 -544252610 170838616 74453471 -12616909 -369840166 885525941 -968064216 836394557 -415902424 -775900354 28286246 529372306 -711641965 -170289246 443477252 476686336 -527242955 242638951 -478848484 -476056062 -738858634 -824215231 536874096 -220375981 -707304262 -729578108 821899538 -350696783 -721115696 -833229552 123842721 -23779369 -620179548 309669637 892452518 -676479754 174960267 -395830115 -598734077 -704769468 -637706150 -157976138 180987468 20075397 -282465113 58378946 361115550 265192159 705941993 -486812112 741555341 -989167034 264541377 -563747497 -724534200 -801580434 -910524657 -477386352 -880255229 132978184 563720804 402091811 760810582 509568037 -660280321 -467280980 806096807 -765284536 100430948 126615091 -35953765 232623192 471450501 -799969172 124635557 81954034\\n\", \"13\\n167026974 -713372421 -38711200 -100748080 990095865 753431495 -930192068 -549715076 -785173362 -32753092 -674165237 846535244 316253769\\n\", \"96\\n279008580 -358771569 -742855193 157850934 142381452 707711684 308482266 -788654300 -552910696 -762502997 230962744 -178257578 -436303133 428376124 -299904638 -931796825 754823473 305663342 37854254 579019121 -139960315 786846261 712275105 -38775079 -668100490 978169161 -903121454 148847185 786740844 620411974 164556009 869134653 -649022312 451865415 632893878 396298512 -853231472 565724741 -92091711 -457729456 -164681397 -911513093 657441466 375537221 47416452 618869026 -152220492 -448541146 -759931368 -161019202 -535794674 -25367144 235664827 355877737 -824747096 -101528372 -500183101 -890654309 -256870606 -292913391 665138696 130737604 941955611 686656769 -903578873 -687848480 579815906 -943090152 577746691 -847888667 68973440 811491284 879493760 -360016189 116168764 125530578 -590200542 -383770388 629927300 -684035735 868986560 -46072775 707822664 501514150 -989977314 -51717398 -542847767 638763430 670844695 -91501131 607634378 365338493 649652748 336115084 -824588763 380525642\\n\", \"19\\n836861538 -808708402 569971035 530901468 -115012943 475676441 27906595 -497926083 -384680040 -252730766 934953741 -948619455 295023836 955461310 336326134 529727565 -319082669 448002461 -683413096\\n\", \"95\\n97627462 386412569 196022047 817825447 669040195 523031728 -721314037 658156979 -353466396 805511894 762545364 321702901 -641558771 -648799394 976117297 -282144938 -409529268 334227938 284055034 429704265 70833556 -898778875 943292249 -850496814 -162390324 -716059006 -778291217 -727103400 -355763721 -744799245 -629338854 -896774972 -830097774 277501506 538752621 -520106154 265598836 -82236083 903402773 269810039 -315359252 -302657504 712614474 -702819876 -295575415 -789294507 802990607 437170507 523239171 -179720049 -616524873 741681780 166413807 -235744554 1023054 50919720 -167889224 -81567396 -134246462 424922698 938389359 -981049594 -44576210 -828963942 657008145 899879497 -956647420 -376708700 430658821 585346933 192128726 482600754 -207344987 -206026396 -494283984 789309402 306001620 136355952 -424830823 432312049 -387591832 -781307581 27628448 224162462 464373724 -632304776 -332516119 647109939 -918029144 -555373002 647878763 59190328 -406004066 832612667 -996397206\\n\", \"77\\n291753456 -994570007 -572569779 244471678 -57580190 907972829 494168554 -976746949 -247368984 294048630 -354389359 236808233 -316846749 -897844876 92022519 -730242799 -965018420 897143569 -321970735 -997851566 -299029309 -81945237 375485997 -978460286 309489855 -633671236 -835079645 521064336 685246904 317017463 -157599749 323639350 -710769514 807051724 783137684 715136961 947385192 226674985 541128957 -504680883 -803181272 722661650 760991429 292732087 -707392724 -704854869 -741829896 825898849 -567824487 -312470782 -249417617 816139790 -939343082 437872570 -509317603 164335659 211069464 -862913047 105928455 861455427 -4898253 -902730222 -73331810 -545402426 381980762 -121880045 -271980858 -10027647 -411471394 -229332946 478749956 -65417832 318086841 -695219256 585177461 416001395 -631105124\\n\", \"97\\n-897607156 369628427 771869237 819794496 -188121780 -382629533 -864267708 604712328 803368399 708273608 -255121141 -227214458 601887 -477618029 772091340 -9986371 123573527 -974321989 -882483461 504051647 -651378139 260902071 -346905288 -943367407 956661274 -757474226 -490069498 474434861 304159275 262635939 -780372158 921417501 360421475 424606571 -144722728 441291532 20488073 99655445 -41490983 -967391931 -550548089 131779217 362392954 -257368343 -888406912 748176867 85094801 -112126392 796564921 614602024 91277661 -426164512 699490311 -944149592 674417657 -193453464 -189270998 -924371692 -131216943 -112920041 895901038 -394533182 367354530 -676878918 -490244069 952274595 -218821980 383399158 -3746842 251530314 551673149 853721543 106004267 515253901 470079220 -637134341 695119240 969300258 -193978235 -55468609 905180057 -838957180 -804412222 922886232 -428391440 -988002899 521226705 -810178640 -427041516 401355779 -999038544 260905567 -936809556 -433982880 -879317561 81377536 -81564110\\n\", \"82\\n-136434137 -145469743 222251077 876978046 -235963877 -388467154 215976240 113868559 521714613 540417087 -137104665 659197304 -219759937 90126622 107207558 -324925392 -702196589 -247560945 -296947840 -314200671 -774333463 946142799 987543477 -325369077 974531563 339352413 -760267692 745931156 -94906307 -901607913 651241748 439201600 -230401525 -722157046 -434695627 524416884 646227449 -666125596 -991139690 -342646876 -986015503 280825652 982478872 -811214337 49262642 463971710 -408982602 -285744795 -892604651 -396130709 490572801 908211896 -480838410 180929140 -16202982 837907020 475731260 77643298 114773617 957193259 542936116 -154862069 920119916 -699823593 811306137 289719678 -376860877 -261517240 -863459981 133311333 51067580 -653262763 316974119 -467411684 -127810098 -634554006 46756928 401445991 -797059481 -440851805 -791653520 223850076\\n\", \"99\\n-528071516 -978967406 45065878 412971208 -350681104 -473894467 -254166248 355095608 -919858153 -969701644 319954974 592270508 795676098 -776471938 809537248 -548687680 387149937 725735363 444992475 -15446377 240196840 657472179 84357710 -663409142 -611521719 -115403418 561858390 -173065622 558930790 -663590247 -384818980 -163538295 -274021853 -708936106 -933603608 -350424366 606791273 -350088610 -554220626 892398230 -719009724 -482038414 -85408984 906557799 -551361928 287278598 -322455789 273541211 979508161 720384073 -38568286 873631576 579141001 -551619272 165853837 -907201571 404469987 847510112 721710653 373000565 -113049858 331696934 -623704850 142031681 145654914 909331088 -496430818 758866333 585021875 -955400904 -596550155 -269869312 822851417 -372859326 470543278 -700208643 678844593 23269534 -989021411 -352979654 879408248 188314045 401497220 -202938501 -865537154 86678453 -230739769 -882502452 -192566050 272507943 126547055 951189045 -443866326 -30247171 828319167 -30715530 855970281 -70458330 -550654520\\n\", \"45\\n-635611852 547592379 879617587 123652803 772412608 -916267373 -942530034 628908907 872009703 644071305 -355030387 -908834983 676212979 -1819260 -672323595 -796581498 -807318282 -489823201 -828797259 -406816978 -448980282 -147312430 -116964603 -373436815 312329431 -320080265 402620419 373279515 244673259 130427069 572049218 -893288868 590793907 -336659883 -869777164 -920199698 -477198863 312247749 689031998 -74397974 -690508692 327222331 702603221 941968134 -470625407\\n\", \"98\\n-940790552 -614364986 706389461 295835559 -845364071 -319021500 -887626211 -384595367 457657107 -404660575 833660695 352000330 510824036 883485105 -292518194 -462095669 -900519416 273539692 -562415692 753484932 -184957762 -808999634 699445058 -215142690 -597259918 -264321899 326427750 -540648555 628427078 -161163209 -734267236 83039652 940821967 504203920 2785405 748215584 583945055 621252548 -129018756 -419336108 -996371828 500422261 71672338 663629913 790655814 463232613 784414356 -597760623 969606618 665203780 -340413119 -560992316 -737271013 -707546221 990863913 -610510206 -150288379 332176931 93176722 -884237819 -782939778 595289845 684237325 -516111744 276834083 -825325324 -745536979 831070150 205233903 343178668 239901983 867734289 822877719 -938056042 332290702 -790640426 562301773 -560537679 -401961837 -574057942 -964040951 14361255 -468554010 972993198 -232933746 864850458 -587136802 624358539 194068427 598788607 641585938 938162115 -138905306 407666245 -366194634 138483579 -598300039 -220600237\\n\", \"38\\n567219872 -347586279 -429119206 -588357996 -307725540 -457995644 539940454 -562485763 105176279 100338313 333348456 426618740 -886319592 450868959 -807685670 -530589868 956357210 876266338 -383681974 -502091373 -383046277 866585799 -630892316 835293331 -43670927 -690136112 -545743525 577866858 257372156 -52286666 -534797233 -381484556 87182143 674340493 -8489339 775842896 311935246 905066899\\n\", \"96\\n-822939138 -465156739 178106029 -25901482 -345677929 266520861 450491650 -967884539 -401968623 -817246119 721839283 -397708152 -295290124 -583824759 490984573 874715637 -667460371 963392275 314484282 -705848216 -508391936 946612005 -276129123 -290792841 435454680 62232145 746521206 -972248200 -363786589 -342372573 190091525 414902533 728542368 -972327985 145000100 808105108 148731831 -809068790 -519586361 -963688607 -201276015 -460835092 -636015156 -641265059 -870868694 211432171 -546180261 -564784052 -803339677 568378692 126352879 369659919 -156889797 -195356504 668851498 73508132 327053554 28591568 -895381505 722917882 666298634 63348775 793302412 318931540 -434837253 -793964149 -23293822 -855208529 276314417 -725647242 -843224572 -493729461 -817509836 143425554 -260112762 -566225975 -340037169 783911529 -468377537 -947508881 429316547 -897059142 -821931439 -947903900 8466434 -788056454 -546023452 240875059 -847026513 579936715 408206365 10208319 -95685612 -742583485 296407999 -313413218\\n\", \"95\\n-603184408 -814051902 -725434836 -485304141 -162609593 -421064280 -255988469 -466175119 -505528267 -326246870 21294055 -509308893 -400592979 577999661 138238840 285892181 -718525145 299918515 232353786 302939977 239011578 -310534785 154718939 -893426221 325128818 -638948488 -428682600 539305637 31213897 -797119025 608844818 -824074414 948157662 288327895 969015405 994760453 -587450290 592673880 955238562 -597994668 705936840 558696163 -901351166 963555629 298083260 683188270 857297426 -708039974 147092354 -279522651 -829367650 -174856416 -130702384 -754997934 309632545 -161336653 63412893 921973238 345211249 -802781361 44108071 -281055463 -956824999 334737920 -964066091 -744961861 321356143 -493033743 137022605 -473767680 803515454 251025171 -312311073 60925815 843880548 -166668936 262199630 110208503 -156862186 910859263 860287651 594991432 26912682 -956954830 -739064628 -662215784 340946703 970201343 181903501 -843277124 53589806 -107868361 -311338221 -197547420 -133791038\\n\", \"99\\n43068902 -882418084 23005187 891329447 -37712055 339138431 661427419 433984986 351154863 778017842 42271743 47071290 -923296757 -267053973 -960675818 -605654666 82989131 -327578968 -261266710 855508711 341005915 934107933 88766979 632006677 -627098010 9129244 -975567699 -653890067 715233058 -668044124 -912052963 932548324 -921883003 180023416 90592008 511601263 -551598411 571908704 65787204 -740713588 -215412823 706007854 -146010503 943603934 -341164614 184964488 -332284841 -502852316 -659612381 155224887 -219151389 -532400678 -866855673 299531340 -615734534 921001302 459297757 544134037 -670155932 -258322468 -411704180 -618610861 -111349807 -8186658 -802389156 -479495537 301822896 574518831 -708202018 349206410 909502620 261506565 522297746 797070492 506754458 -853268610 991460022 937576721 -716639894 765334585 -651856151 912808782 -677743770 -818328139 887845292 997458875 840302383 -161658840 -293010482 -154080733 275584429 -463978712 289779653 -938979342 455308026 -75264553 70314273 -525450505 445108024\\n\", \"20\\n723951456 796468016 -469098467 716999795 -740153748 -906420374 -450699586 317978227 -860950538 446414035 -263530592 442034754 93509326 -506068976 -163298154 109814461 -78141213 513005402 986206979 -270001429\\n\", \"99\\n-259382196 206664082 -995154083 -392577272 -789089252 -824384866 615568053 738554559 11880776 991387881 485619436 919181196 -927368071 -154747564 379232162 -849722660 -657472080 158625662 860162636 454516130 657268790 -442795399 541579738 -761904790 -871099375 -534411640 -783028862 263866328 30032660 565140279 891860619 -887448010 658009200 -593291577 -2209461 570428950 811888038 -399616527 -586025461 484943943 -290736728 259493952 -761447245 -215080566 -130620184 773320275 397208517 509276849 -430408524 -129480161 -220067236 72166148 -852880282 -961405587 869321047 688318275 839836246 625000679 644481810 -676268034 -293980122 -400253853 924402621 -230233817 41666826 -238362960 308512581 264487960 549072246 446295790 -429527107 108275233 554451204 -490060045 528843048 -927621543 444303101 -919275361 176874768 -25291193 35272088 -961840375 -842467550 -114173777 748068446 -234223554 46684390 -791729714 396673362 163179771 153685725 889716750 520358755 -512164199 43941456 39673530 632500454 -76872266 -307400508\\n\", \"85\\n-778127821 931497358 -753245590 -302601647 421269518 842046515 -23166929 513142793 154467751 43263750 -416635614 -41187581 -602082359 214165478 928554317 810103738 917395979 -832522350 -484616807 -73428685 17439497 -282324315 328839777 114205291 970700356 -661449379 -548426195 867277602 -96272858 -615625250 -706641298 -521308061 -955120883 -161127084 582735332 -972022583 835332174 584894295 -346428807 54724592 -352459125 -729333531 -797272367 -952935363 -238096608 995346829 728257924 197925565 924461222 317546542 -409216324 -121273797 800751259 228184184 641794524 301119151 -38950188 41802734 676238648 575048591 189265204 82420899 -320389436 106001780 143486624 -405830033 471239115 -851206834 -525207273 -225443477 990830338 933426852 191798328 -769282776 772651588 -94899418 249521442 -128877989 -592957807 180061827 258641728 425553656 -556486166 645923339 230527883\\n\", \"4\\n-813806239 -459872768 612202076 255667257\\n\", \"17\\n-452737366 -829527571 -857260668 -530265249 -343108746 -411298166 860277827 690492544 726340842 -637401096 -655872475 -620492812 50528785 -59141704 606744558 531236874 161396618\\n\", \"1\\n-782078156\\n\", \"13\\n-746025256 420212868 340673137 -817845371 -232338449 -906636385 799544687 -790158345 799275968 -404012528 396599267 -562327220 111623173\\n\", \"18\\n276784479 -523137037 59382194 -784956945 -90841079 389617071 -454766602 607359279 277531163 260715643 -815680804 -496923045 -743356373 -749014901 125836389 -96908016 838009004 977939044\\n\"], \"outputs\": [\"12\\n\", \"200\\n\", \"0\\n\", \"99000\\n\", \"14212229586\\n\", \"14454694082\\n\", \"16230896865\\n\", \"8155615671\\n\", \"18589417528\\n\", \"8073032967\\n\", \"17619918807\\n\", \"10498840463\\n\", \"16243369628\\n\", \"8798483161\\n\", \"13503826973\\n\", \"18989211043\\n\", \"13283659437\\n\", \"9543415807\\n\", \"17397506017\\n\", \"18175439844\\n\", \"21030194446\\n\", \"10470410950\\n\", \"18004724438\\n\", \"13409603572\\n\", \"19485538294\\n\", \"16583373282\\n\", \"8826361009\\n\", \"2220511646\\n\", \"17993295863\\n\", \"4134484656\\n\", \"16146723228\\n\", \"9335493140\\n\", \"16700969542\\n\", \"13557000660\\n\", \"17191144478\\n\", \"8462593189\\n\", \"18195542331\\n\", \"6778055267\\n\", \"9626763178\\n\", \"13409859553\\n\", \"18618000392\\n\", \"3744928260\\n\", \"19032790656\\n\", \"16191477359\\n\", \"0\\n\", \"752181850\\n\", \"0\\n\", \"2121903844\\n\", \"2591836871\\n\"]}",
    "tags": [
        "reasoning/coding"
    ]
}