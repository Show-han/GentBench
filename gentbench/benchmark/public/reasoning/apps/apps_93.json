{
    "problem": "You are an expert Python programmer, and here is your task: You are given two integers $a$ and $b$. Moreover, you are given a sequence $s_0, s_1, \\dots, s_{n}$. All values in $s$ are integers $1$ or $-1$. It's known that sequence is $k$-periodic and $k$ divides $n+1$. In other words, for each $k \\leq i \\leq n$ it's satisfied that $s_{i} = s_{i - k}$.\n\nFind out the non-negative remainder of division of $\\sum \\limits_{i=0}^{n} s_{i} a^{n - i} b^{i}$ by $10^{9} + 9$.\n\nNote that the modulo is unusual!\n\n\n-----Input-----\n\nThe first line contains four integers $n, a, b$ and $k$ $(1 \\leq n \\leq 10^{9}, 1 \\leq a, b \\leq 10^{9}, 1 \\leq k \\leq 10^{5})$.\n\nThe second line contains a sequence of length $k$ consisting of characters '+' and '-'. \n\nIf the $i$-th character (0-indexed) is '+', then $s_{i} = 1$, otherwise $s_{i} = -1$.\n\nNote that only the first $k$ members of the sequence are given, the rest can be obtained using the periodicity property.\n\n\n-----Output-----\n\nOutput a single integer\u00a0\u2014 value of given expression modulo $10^{9} + 9$.\n\n\n-----Examples-----\nInput\n2 2 3 3\n+-+\n\nOutput\n7\n\nInput\n4 1 5 1\n-\n\nOutput\n999999228\n\n\n\n-----Note-----\n\nIn the first example:\n\n$(\\sum \\limits_{i=0}^{n} s_{i} a^{n - i} b^{i})$ = $2^{2} 3^{0} - 2^{1} 3^{1} + 2^{0} 3^{2}$ = 7\n\nIn the second example:\n\n$(\\sum \\limits_{i=0}^{n} s_{i} a^{n - i} b^{i}) = -1^{4} 5^{0} - 1^{3} 5^{1} - 1^{2} 5^{2} - 1^{1} 5^{3} - 1^{0} 5^{4} = -781 \\equiv 999999228 \\pmod{10^{9} + 9}$.",
    "solution": "[\"def __starting_point():\\n\\ta=[int(x) for x in input().split()]\\n\\tN=a[0]\\n\\tA=a[1]\\n\\tB=a[2]\\n\\tK=a[3]\\n\\ts=input()\\n\\tmod = 1000000009\\n\\tQ = pow(B*pow(A,mod-2,mod)%mod,K,mod)\\n\\tif Q!=1:\\n\\t\\tD = (pow(Q,(N+1)//K,mod)-1)*pow(Q-1,mod-2,mod)%mod\\n\\telse:\\n\\t\\tD = (N+1)//K\\n\\tans=0\\n\\tC = pow(A,N,mod)\\n\\tA=pow(A,mod-2,mod)\\n\\tfor i in range(K):\\n\\t\\tif s[i]=='+':\\n\\t\\t\\tans=(ans+C*D)%mod\\n\\t\\telse:\\n\\t\\t\\tans=(ans-C*D)%mod\\n\\t\\tC=C*B*A%mod\\n\\tprint((ans%mod+mod)%mod)\\n__starting_point()\", \"MOD = 1000000009\\n\\ndef Pow(base, n):\\n    res = 1\\n    while n:\\n        if n&1:\\n            res = (res*base)%MOD\\n        base = (base*base)%MOD\\n        n >>= 1\\n    return res\\n\\nn, a, b, k = list(map(int, input().split()))\\nans = 0\\nnum = (n+1)//k\\n_a = Pow(a, MOD-2)\\nq = Pow(b, k)*Pow(Pow(a, k), MOD-2)%MOD\\nif q == 1:\\n    res = Pow(a, n)*num%MOD\\n    for i in input():\\n        if i == '+':\\n            ans = (ans+res)%MOD\\n        else:\\n            ans = (ans-res)%MOD\\n        res = res*b%MOD*_a%MOD\\nelse:\\n    # rat = (1-Pow(q, num))%MOD*Pow((1-q)%MOD, MOD-2)%MOD\\n    rat = (Pow(q, num)-1)%MOD*Pow((q-1)%MOD, MOD-2)%MOD\\n    cur = Pow(a, n)*rat%MOD\\n    for i in input():\\n        if i == '+':\\n            ans = (ans+cur)%MOD\\n        else:\\n            ans = (ans-cur)%MOD\\n        cur = cur*b%MOD*_a%MOD\\nprint(ans)\\n\", \"M = 0x3b9aca09\\ninv = lambda x: pow(x, M - 2, M)\\nn, a, b, k = list(map(int, input().split()))\\ns = input()\\nc = inv(a) * b % M\\nq = pow(c, k, M)\\nm = (n + 1) // k\\np = (pow(q, m, M) - 1) * inv(q - 1) % M if q - 1 else m\\nx = pow(a, n, M)\\nr = 0\\nfor i in range(k):\\n    r = (r + [-1, 1][s[i] == '+'] * x * p) % M\\n    x = (x * c) % M\\nprint(r)\\n\", \"n, a, b, k = list(map(int, input().split()))\\ns = input()\\n\\nm = int(1e9 + 9)\\na_1 = pow(a, m - 2, m)\\nx = (a_1 * b) % m\\nxk = pow(x, k, m)\\n# print(\\\"xk\\\", xk)\\n\\nC = 0\\nfor i in range(0, k):\\n\\tz = 1 if s[i] == \\\"+\\\" else -1\\n\\tC = (C + z * pow(x, i, m)) % m\\n# print(\\\"C\\\", C)\\n\\t\\nkk = (n + 1) // k\\nif xk > 1:\\n\\tv1 = (pow(xk, kk, m) - 1) % m\\n\\tv2 = pow( (xk - 1) % m, m - 2, m)\\n\\tD = (v1 * v2) % m\\nelse:\\n\\tD = kk\\n# print(\\\"D\\\", D)\\n\\t\\nans = pow(a, n, m) * C * D\\nans %= m\\nprint(ans)\\n\", \"n, a, b, k = map(int, input().split())\\ns = input()\\nmod = int(1e9 + 9)\\ninv = lambda x: pow(x, mod-2, mod)\\nq = pow(b, k, mod) * inv(pow(a, k)) % mod\\nper = 0\\nd = pow(a, n, mod)\\nqq = b * inv(a) % mod\\nfor i in range(k):\\n    if s[i] == '+':\\n        per += d\\n    else:\\n        per -= d\\n    per %= mod\\n    d = d * qq % mod\\nt = (n + 1) // k\\nif q == 1:\\n    print(t * per % mod)\\n    return\\nz = (pow(q, t, mod) - 1) * inv(q-1) % mod\\nprint(z * per % mod)\", \"n, a, b, k = map(int, input().split())\\ns = input()\\nmod = int(1e9 + 9)\\ninv = lambda x: pow(x, mod-2, mod)\\nq = pow(b, k, mod) * inv(pow(a, k, mod)) % mod\\nper = 0\\nd = pow(a, n, mod)\\nqq = b * inv(a) % mod\\nfor i in range(k):\\n    if s[i] == '+':\\n        per += d\\n    else:\\n        per -= d\\n    per %= mod\\n    d = d * qq % mod\\nt = (n + 1) // k\\nif q == 1:\\n    print(t * per % mod)\\n    return\\nz = (pow(q, t, mod) - 1) * inv(q-1) % mod\\nprint(z * per % mod)\", \"def pow_mod(x, y, p):\\n    number = 1\\n    while y:\\n        if y & 1:\\n            number = number * x % p\\n        y >>= 1\\n        x = x * x % p\\n    return number % p\\n\\ndef inv(x, p):\\n    if 1 < x:\\n        return p - inv(p % x, x) * p // x\\n    return 1\\n        \\ndef v(p, a, b, k):\\n    i = 1\\n    while (pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i)) == 0:\\n        i += 1\\n    return i-1\\n\\ndef main():\\n    p = 10 ** 9 + 9\\n    n, a, b, k = list(map(int, input().split()))\\n    S = list(input())\\n    for i in range(k):\\n        if S[i] == '+':\\n            S[i] = 1\\n        else:\\n            S[i] = -1\\n    s=0\\n    if a != b:\\n        vp = p ** v(p, a, b, k)\\n        sum_mod = ((pow_mod(a, (n + 1), p * vp) - pow_mod(b, (n + 1), p * vp)) // vp) * inv(((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp) % p, p)\\n        pa = pow_mod(a, k - 1, p)\\n        pb = 1\\n        inv_a = inv(a, p)\\n        for i in range(k):\\n            s += (S[i] * pa * pb * sum_mod) % p\\n            pa = (pa * inv_a) % p\\n            pb = (pb * b) % p\\n    else:\\n        for i in range(k):\\n            s += S[i] * (n + 1) // k\\n        s *= pow_mod(a, n, p)\\n    s %= p\\n    print(s)\\n\\nmain()\\n\\n\\n#def giant_steps(start, target, n=2):\\n    #L = [target]\\n    #while L[-1] > start*n:\\n        #L = L + [L[-1]//n + 2]\\n    #return L[::-1]\\n\\n#def rshift(x, n):\\n    #if n >= 0: return x >> n\\n    #else:      return x << (-n)\\n\\n#def lshift(x, n):\\n    #if n >= 0: return x << n\\n    #else:      return x >> (-n)\\n    \\n#def size(x):\\n    #return str(x).count('2')\\n\\n#def newdiv(p, q):\\n    #szp = size(p)\\n    #szq = size(q)\\n    #szr = szp - szq\\n    #if min(szp, szq, szr) < 2*START_PREC:\\n        #return p//q\\n    #r = (1 << (2*START_PREC)) // (q >> (szq - START_PREC))\\n    #last_prec = START_PREC\\n    #for prec in giant_steps(START_PREC, szr):\\n        #a = lshift(r, prec-last_prec+1)\\n        #b = rshift(r**2 * rshift(q, szq-prec), 2*last_prec)\\n        #r = a - b\\n        #last_prec = prec\\n    #return ((p >> szq) * r) >> szr\\n\", \"def __starting_point():\\n\\n\\ta=[int(x) for x in input().split()]\\n\\n\\tN=a[0]\\n\\n\\tA=a[1]\\n\\n\\tB=a[2]\\n\\n\\tK=a[3]\\n\\n\\ts=input()\\n\\n\\tmod = 1000000009\\n\\n\\tQ = pow(B*pow(A,mod-2,mod)%mod,K,mod)\\n\\n\\tif Q!=1:\\n\\n\\t\\tD = (pow(Q,(N+1)//K,mod)-1)*pow(Q-1,mod-2,mod)%mod\\n\\n\\telse:\\n\\n\\t\\tD = (N+1)//K\\n\\n\\tans=0\\n\\n\\tC = pow(A,N,mod)\\n\\n\\tA=pow(A,mod-2,mod)\\n\\n\\tfor i in range(K):\\n\\n\\t\\tif s[i]=='+':\\n\\n\\t\\t\\tans=(ans+C*D)%mod\\n\\n\\t\\telse:\\n\\n\\t\\t\\tans=(ans-C*D)%mod\\n\\n\\t\\tC=C*B*A%mod\\n\\n\\tprint((ans%mod+mod)%mod)\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\\n__starting_point()\", \"MOD = 10**9+9;\\n\\nn,a,b,k = list(map(int,input().split()))\\ns = input();\\n\\ndef pow(a,n,m=MOD):\\n    ret = 1;\\n    a %= MOD;\\n    while n:\\n        if n&1:\\n            ret = ret*a%m;\\n        a = a*a%m;\\n        n >>= 1;\\n    return ret;\\n#def inv(a,p=MOD):\\n#    return pow(a,p-2,p);\\ndef inv(a,m=MOD):\\n    if a > 1:\\n        return (m-m//a*inv(m%a,m))%m;\\n    return 1\\n\\nia,d = inv(a), (n+1)//k\\nans, ci0, q = 0, pow(a,n), pow(ia*b,k)\\nQ = d\\nif q != 1:\\n    Q = (pow(q,d)-1)*inv(q-1)%MOD\\n\\nfor i in range(k):\\n    sign = 1\\n    if s[i] == '-':\\n        sign = -1;\\n    ans += sign*ci0*Q%MOD\\n    ans %= MOD\\n    ci0 = ci0*ia*b%MOD\\nprint(ans);\\n\", \"M = 1000000009\\ninv = lambda x: pow(x, M - 2, M)\\nn, a, b, k = list(map(int, input().split()))\\ns = input()\\nc = inv(a) * b % M\\nq = pow(c, k, M)\\nm = (n + 1) // k\\np = (pow(q, m, M) - 1) * inv(q - 1) % M if q - 1 else m\\nx = pow(a, n, M)\\nr = 0\\nfor i in range(k):\\n    r = (r + [-1, 1][s[i] == '+'] * x * p) % M\\n    x = (x * c) % M\\nprint(r)\\n\", \"def alternatingSum(n,a,b,k,s):\\n    \\n    mod = 1000000009\\n    inv = lambda x: pow(x, mod-2, mod)\\n    q = pow(b, k, mod) * inv(pow(a, k, mod)) % mod\\n    per = 0\\n    d = pow(a, n, mod)\\n    qq = b * inv(a) % mod\\n\\n    for i in range(k):\\n        if s[i] == '+':\\n            per += d\\n        else:\\n            per -= d\\n        \\n        per %= mod\\n        d = d * qq % mod\\n    \\n    t = (n + 1) // k\\n\\n    if q == 1:\\n        print(t * per % mod)\\n        return\\n    \\n    z = (pow(q, t, mod) - 1) * inv(q-1) % mod\\n    print(z * per % mod)\\n    \\n    \\nparamsRaw = input()\\nparamsStr = paramsRaw.split()\\nparamsInt = list(map(int, paramsStr))\\n\\nsequenceRaw = input()\\n\\nalternatingSum(paramsInt[0],paramsInt[1],paramsInt[2],paramsInt[3],sequenceRaw)\", \"raw = input().split()\\nvals = [x for x in input()]\\nn,a,b,k = [int(x) for x in raw]\\nsumm = 0\\nmod = 1000000009\\n\\ndef inv(x):\\n    return fast_power(x, mod-2)\\n\\ndef fast_power(a,n):\\n    ret = 1\\n    a = a % mod\\n    while n:\\n        if n&1:\\n            ret = ret*a%mod\\n        a = a*a%mod\\n        n >>= 1\\n    return ret\\n\\nc = inv(a) * b % mod\\ncf = fast_power(c, k)\\nm = (n + 1) // k\\nif cf -1:\\n    p = (fast_power(cf, m) - 1) * inv(cf - 1) % mod\\nelse:\\n    p = m\\nx = fast_power(a, n)\\nfor i in range(k):\\n    summ = (summ + [-1, 1][vals[i] == '+'] * x * p) % mod\\n    x = (x * c) % mod\\n\\nprint(summ)\\n\", \"\\n\\n\\nraw = input().split()\\nvals = [x for x in input()]\\nn,a,b,k = [int(x) for x in raw]\\nsumm = 0\\nmod = 1000000009\\n\\ndef inv(x):\\n\\treturn fast_power(x, mod-2)\\n\\ndef fast_power(a,n):\\n\\tret = 1\\n\\ta = a % mod\\n\\twhile n:\\n\\t\\tif n&1:\\n\\t\\t\\tret = ret*a%mod\\n\\t\\ta = a*a%mod\\n\\t\\tn >>= 1\\n\\treturn ret\\n\\nc = inv(a) * b % mod\\ncf = fast_power(c, k)\\nm = (n + 1) // k\\nif cf -1:\\n\\tp = (fast_power(cf, m) - 1) * inv(cf - 1) % mod\\nelse:\\n\\tp = m\\nx = fast_power(a, n)\\nfor i in range(k):\\n\\tsumm = (summ + [-1, 1][vals[i] == '+'] * x * p) % mod\\n\\tx = (x * c) % mod\\n\\nprint(summ)\\n\", \"MOD = 1000000009\\ndef AlternateSum(n,a,b,k,s):\\n    res = 0\\n    inv = lambda x: pow(x, MOD-2, MOD)\\n    q = pow(b, k, MOD) * inv(pow(a, k, MOD)) % MOD\\n    max_pow = pow(a, n, MOD)\\n    c = b * inv(a) % MOD\\n    for i in range(k):\\n        if s[i] == '+':\\n            res += max_pow\\n        else:\\n            res -= max_pow\\n        res %= MOD\\n        max_pow = max_pow * c % MOD\\n    t = (n + 1) // k\\n    if q == 1:\\n        return t * res % MOD\\n    z = (pow(q, t, MOD) - 1) * inv(q-1) % MOD\\n    return z * res % MOD\\nn, a, b, k = [int(x) for x in input().split()]\\ns = input()\\nprint(AlternateSum(n, a, b, k, s))\", \"import sys\\n\\n\\nMOD = 10**9 + 9\\n\\ndef inv(x):\\n    return pow(x, MOD-2, MOD)\\n\\ndef alternateSum(n,a,b,k,s):\\n    res = 0\\n    q = (pow(b, k, MOD) * inv(pow(a, k, MOD))) % MOD\\n    max_pow = pow(a, n, MOD)\\n    c = b * inv(a) % MOD\\n    for i in range(k):\\n        if s[i] == '+':\\n            res += max_pow\\n        elif s[i] == '-':\\n            res -= max_pow\\n        res %= MOD\\n        max_pow = (max_pow * c) % MOD\\n    t = (n+1) // k\\n    if q == 1:\\n        return (t*res) % MOD\\n    z = ((pow(q, t, MOD) - 1) * inv(q-1)) % MOD\\n    return z * res % MOD\\n\\nn, a, b, k, s = sys.stdin.read().split()\\nresult = alternateSum(int(n), int(a), int(b), int(k), s)\\n\\nprint(result)\", \"\\ndef alternatingSum(n,a,b,k,s):\\n    mod = 1000000009\\n    inv = lambda x: pow(x, mod-2, mod)\\n    q = pow(b, k, mod) * inv(pow(a, k, mod)) % mod\\n    per = 0\\n    d = pow(a, n, mod)\\n    qq = b * inv(a) % mod\\n    for i in range(k):\\n        if s[i] == '+':\\n            per += d\\n        else:\\n            per -= d        \\n        per %= mod\\n        d = d * qq % mod    \\n    t = (n + 1) // k\\n    if q == 1:\\n        print(t * per % mod)\\n        return    \\n    z = (pow(q, t, mod) - 1) * inv(q-1) % mod\\n    print(z * per % mod)\\n        \\nparamsRaw = input()\\nparamsStr = paramsRaw.split()\\nparamsInt = list(map(int, paramsStr))\\nsequenceRaw = input()\\n\\nalternatingSum(paramsInt[0],paramsInt[1],paramsInt[2],paramsInt[3],sequenceRaw)\\n\", \"def alternatingSum(n,a,b,k,s):\\n    \\n    mod = 1000000009\\n    inv = lambda x: pow(x, mod-2, mod)\\n    q = pow(b, k, mod) * inv(pow(a, k, mod)) % mod\\n    per = 0\\n    d = pow(a, n, mod)\\n    qq = b * inv(a) % mod\\n\\n    for i in range(k):\\n        if s[i] == '+':\\n            per += d\\n        else:\\n            per -= d\\n        \\n        per %= mod\\n        d = d * qq % mod\\n    \\n    t = (n + 1) // k\\n\\n    if q == 1:\\n        print(t * per % mod)\\n        return\\n    \\n    z = (pow(q, t, mod) - 1) * inv(q-1) % mod\\n    print(z * per % mod)\\n    \\n    \\nparamsRaw = input()\\nparamsStr = paramsRaw.split()\\nparamsInt = list(map(int, paramsStr))\\n\\nsequenceRaw = input()\\n\\nalternatingSum(paramsInt[0],paramsInt[1],paramsInt[2],paramsInt[3],sequenceRaw)\\n  \\n\", \"import sys\\ntry:\\n\\tfin = open('in')\\nexcept:\\n\\tfin = sys.stdin\\ninput = fin.readline\\n\\nmod=10**9+9\\ndef f(x,y):\\n\\tans=1\\n\\twhile y:\\n\\t\\tif y&1:ans=ans*x%mod\\n\\t\\tx=x*x%mod\\n\\t\\ty>>=1\\n\\treturn ans\\nn,a,b,k=map(int,input().split())\\ns=[1 if c=='+' else -1 for c in input()]\\n#period k-1\\npr=sum(s[i]*f(a,n-i)*f(b,i) for i in range(k))%mod\\n#ratio (b/a)^k\\nrt=f(b,k)*f(f(a,k),mod-2)%mod\\nterms=(n+1)//k\\nif rt==1:\\n\\tprint(terms*pr%mod)\\nelse:\\n\\tprint(pr*(f(rt,terms)-1)*f(rt-1,mod-2)%mod)\", \"n , a , b , k = list(map(int,input().split()))\\ns = str(input())\\nMOD = 10**9 + 9\\n\\ndef fun(a , b , i):\\n    return (pow(a , n - i , MOD) * pow(b , i , MOD)) % MOD\\n\\ndef div(x , y):\\n    #calculate x // y mod p\\n    return (x * pow(y , MOD - 2 , MOD)) % MOD\\n\\nr = pow(div(b , a) , k , MOD)\\nSUM = 0\\n\\nfor i in range(k):\\n    if s[i] == '-':\\n        SUM += -1 * fun(a , b , i)\\n    else:\\n        SUM += +1 * fun(a , b , i)\\n    \\nn += 1\\nt = n // k\\n\\nans = pow(r , t , MOD) - 1\\nx = r - 1   \\nif x : \\n    ans = (div(ans , x) * SUM) % MOD\\nelse:\\n    ans = (t * SUM) % MOD\\nans += MOD\\nans %= MOD\\nprint(ans)\\n\\n    \\n    \\n\\n    \\n\\n\", \"import math\\ndef binpow(a,b,m):\\n    a %= m\\n    res = int(1)\\n    while b > 0 :\\n        if b & 1:\\n            res = (res * a) % m\\n        a = (a * a) % m\\n        b >>= 1\\n    return res\\n\\ndef inv(a,m:int=1000000009):\\n    return binpow(a,m-2,m)\\n\\nm=int(1000000009)\\n\\nn,a,b,k=input().split()\\nn=int(n);a=int(a);b=int(b);k=int(k)\\nst=input()\\nres=int(1)\\np=int((b*inv(a,m))%m)\\nitr=(n+1)//k\\nmul1=0\\nfor i in range (len(st)):\\n    if st[i]=='+':\\n        mul1=(mul1+binpow(p,i,m))%m\\n    else:\\n        mul1=(mul1-binpow(p,i,m))%m\\nif binpow(p,k,m)==1:\\n    mul2=itr%m\\nelse:\\n    mul2=((binpow(p,k*itr,m)-1)*inv((binpow(p,k,m)-1)%m))%m\\nres=(mul1*mul2)%m\\nleft=n-k*itr+1\\nmul1=binpow(p,k*itr,m)\\nmul2=0\\nfor i in range (left):\\n    if st[i]=='+':\\n        mul2=(mul2+binpow(p,i,m))%m\\n    else:\\n        mul2=(mul2-binpow(p,i,m))%m\\nres=(res+mul1*mul2)%m\\nres=(res*binpow(a,n,m))%m\\nprint(res)\\n\\n\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"2 2 3 3\\n+-+\\n\",\n    \"4 1 5 1\\n-\\n\",\n    \"1 1 4 2\\n-+\\n\",\n    \"3 1 4 4\\n+--+\\n\",\n    \"5 1 1 6\\n++---+\\n\",\n    \"5 2 2 6\\n+--++-\\n\",\n    \"686653196 115381398 884618610 3\\n+-+\\n\",\n    \"608663287 430477711 172252358 8\\n-+--+-+-\\n\",\n    \"904132655 827386249 118827660 334\\n+++-+++++--+++----+-+-+-+-+--+-+---++--++--++--+-+-+++-+++--+-+-+----+-+-++++-----+--++++------+++-+-+-++-++++++++-+-++-+++--+--++------+--+-+++--++--+---++-++-+-+-++---++-++--+-+-++-+------+-+----+++-+++--+-+-+--+--+--+------+--+---+--+-++--+++---+-+-++--------+-++--++-+-+-+-+-+-+--+-++++-+++--+--++----+--+-++-++--+--+-+-++-+-++++-\\n\",\n    \"234179195 430477711 115381398 12\\n++++-+-+-+++\\n\",\n    \"75952547 967294208 907708706 252\\n++--++--+++-+-+--++--++++++---+++-++-+-----++++--++-+-++------+-+-+-++-+-+-++++------++---+-++++---+-+-++++--++++++--+-+++-++--+--+---++++---+-+++-+++--+-+--+++++---+--++-++++--++++-+-++-+++-++-----+-+++++----++--+++-+-+++++-+--++-++-+--+-++++--+-+-+-+\\n\",\n    \"74709071 801809249 753674746 18\\n++++++-+-+---+-+--\\n\",\n    \"743329 973758 92942 82\\n++----+-++++----+--+++---+--++++-+-+---+++++--+--+++++++--++-+++----+--+++++-+--+-\\n\",\n    \"18111 291387 518587 2\\n++\\n\",\n    \"996144 218286 837447 1\\n-\\n\",\n    \"179358 828426 548710 67\\n++++---+--++----+-+-++++----+--+---+------++-+-++++--+----+---+-+--\\n\",\n    \"397521 174985 279760 1\\n+\\n\",\n    \"613632 812232 482342 1\\n-\\n\",\n    \"936810 183454 647048 1\\n+\\n\",\n    \"231531 250371 921383 28\\n++-+------+--+--++++--+-+++-\\n\",\n    \"947301 87242 360762 97\\n--+++--+++-++--++-++--++--+++---+++--++++--+++++--+-++-++-----+-++-+--++-----+-++-+--++-++-+-----\\n\",\n    \"425583346 814209084 570987274 1\\n+\\n\",\n    \"354062556 688076879 786825319 1\\n+\\n\",\n    \"206671954 13571766 192250278 1\\n+\\n\",\n    \"23047921 621656196 160244047 1\\n-\\n\",\n    \"806038018 740585177 987616107 293\\n-+++++--++++---++-+--+-+---+-++++--+--+++--++---++++++++--+++++-+-++-+--+----+--+++-+-++-+++-+-+-+----------++-+-+++++++-+-+-+-++---+++-+-+-------+-+-++--++-++-++-++-+---+--++-++--+++--+++-+-+----++--+-+-++-+---+---+-+-+++------+-+++-+---++-+--+++----+++++---++-++--+----+++-+--+++-+------+-++\\n\",\n    \"262060935 184120408 148332034 148\\n+--+-------+-+-+--++-+++--++-+-++++++--++-+++-+++--+-------+-+--+++-+-+-+---++-++-+-++---+--+-+-+--+------+++--+--+-+-+---+---+-+-++++---+++--+++---\\n\",\n    \"919350941 654611542 217223605 186\\n++-++-+++++-+++--+---+++++++-++-+----+-++--+-++--++--+++-+++---+--+--++-+-+++-+-+++-++---+--+++-+-+++--+-+-------+-++------++---+-+---++-++-++---+-+--+-+--+++++---+--+--++++-++-++--+--++\\n\",\n    \"289455627 906207104 512692624 154\\n-------++--+++---++-++------++----------+--+++-+-+++---+---+++--++++++--+-+-+--+---+-+-++-++--+-++--++++---+-+---+-----+--+-+---------+++-++---++-+-+-----\\n\",\n    \"258833760 515657142 791267045 1\\n-\\n\",\n    \"691617927 66917103 843055237 8\\n--+++---\\n\",\n    \"379582849 362892355 986900829 50\\n++-++---+-+++++--++++--+--++--++-----+------++--+-\\n\",\n    \"176799169 363368399 841293419 1\\n+\\n\",\n    \"144808247 203038656 166324035 4\\n-+-+\\n\",\n    \"477607531 177367565 20080950 2\\n++\\n\",\n    \"682074525 289438443 917164266 1\\n+\\n\",\n    \"938449224 59852396 219719125 1\\n-\\n\",\n    \"395171426 872478622 193568600 147\\n+---++---+-+--+++++--+---+-++++-+-++---++++--+--+-+-++-+-++--------++---+++-+---++---+---+-+--+-++++-+++-+-+-++-+--+++-++-+-+-+-++++++-+---+---++--\\n\",\n    \"403493428 317461491 556701240 1\\n-\\n\",\n    \"917751169 330191895 532837377 70\\n-+-+++++++--++---++-+++++-+++-----+-+++---+--+-+-++-++-+-+-++-++-+----\\n\",\n    \"252089413 552678586 938424519 1\\n-\\n\",\n    \"649316142 320010793 200197645 1\\n-\\n\",\n    \"116399299 784781190 299072480 5\\n++++-\\n\"\n  ],\n  \"outputs\": [\n    \"7\\n\",\n    \"999999228\\n\",\n    \"3\\n\",\n    \"45\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"542231211\\n\",\n    \"594681696\\n\",\n    \"188208979\\n\",\n    \"549793323\\n\",\n    \"605712499\\n\",\n    \"13414893\\n\",\n    \"299311566\\n\",\n    \"724471355\\n\",\n    \"549104837\\n\",\n    \"759716474\\n\",\n    \"25679493\\n\",\n    \"891965141\\n\",\n    \"523548992\\n\",\n    \"134450934\\n\",\n    \"405016159\\n\",\n    \"63271171\\n\",\n    \"545304776\\n\",\n    \"717117421\\n\",\n    \"101533009\\n\",\n    \"441468166\\n\",\n    \"700325386\\n\",\n    \"116291420\\n\",\n    \"48198216\\n\",\n    \"935800888\\n\",\n    \"147768186\\n\",\n    \"927469713\\n\",\n    \"746494802\\n\",\n    \"909066471\\n\",\n    \"928662830\\n\",\n    \"28048785\\n\",\n    \"648647459\\n\",\n    \"460881399\\n\",\n    \"936516261\\n\",\n    \"908035409\\n\",\n    \"627032736\\n\",\n    \"323650777\\n\",\n    \"754650814\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}