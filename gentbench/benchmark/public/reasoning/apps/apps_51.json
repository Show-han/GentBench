{
    "problem": "You are an expert Python programmer, and here is your task: In order to put away old things and welcome a fresh new year, a thorough cleaning of the house is a must.\n\nLittle Tommy finds an old polynomial and cleaned it up by taking it modulo another. But now he regrets doing this...\n\nGiven two integers p and k, find a polynomial f(x) with non-negative integer coefficients strictly less than k, whose remainder is p when divided by (x + k). That is, f(x) = q(x)\u00b7(x + k) + p, where q(x) is a polynomial (not necessarily with integer coefficients).\n\n\n-----Input-----\n\nThe only line of input contains two space-separated integers p and k (1 \u2264 p \u2264 10^18, 2 \u2264 k \u2264 2 000).\n\n\n-----Output-----\n\nIf the polynomial does not exist, print a single integer -1, or output two lines otherwise.\n\nIn the first line print a non-negative integer d \u2014 the number of coefficients in the polynomial.\n\nIn the second line print d space-separated integers a_0, a_1, ..., a_{d} - 1, describing a polynomial $f(x) = \\sum_{i = 0}^{d - 1} a_{i} \\cdot x^{i}$ fulfilling the given requirements. Your output should satisfy 0 \u2264 a_{i} < k for all 0 \u2264 i \u2264 d - 1, and a_{d} - 1 \u2260 0.\n\nIf there are many possible solutions, print any of them.\n\n\n-----Examples-----\nInput\n46 2\n\nOutput\n7\n0 1 0 0 1 1 1\n\nInput\n2018 214\n\nOutput\n3\n92 205 1\n\n\n\n-----Note-----\n\nIn the first example, f(x) = x^6 + x^5 + x^4 + x = (x^5 - x^4 + 3x^3 - 6x^2 + 12x - 23)\u00b7(x + 2) + 46.\n\nIn the second example, f(x) = x^2 + 205x + 92 = (x - 9)\u00b7(x + 214) + 2018.",
    "solution": "[\"p, k = map(int, input().split())\\nk = -k\\n\\na = []\\nwhile p != 0:\\n  r = p % k\\n  p //= k\\n  if r < 0:\\n    r += -k\\n    p += 1\\n  a.append(r)\\n\\nprint(len(a))\\nprint(\\\" \\\".join(map(str, a)))\", \"[p,k]=[int(x) for x in input().split()]\\nd=1\\nres=[]\\nwhile p:\\n\\tif d%2==1:\\n\\t\\tkek=k\\n\\t\\tres.append(str(p%kek))\\n\\t\\tp//=kek\\n\\telse:\\n\\t\\tkek=k\\n\\t\\tlol=kek-(p%kek)\\n\\t\\twhile lol>=kek:\\n\\t\\t\\tlol-=kek\\n\\t\\tres.append(str(lol))\\n\\t\\tp=(p+lol)//kek\\n\\td+=1\\nprint(len(res))\\ns=' '\\nprint(s.join(res))\\n\\t\\t\\n\", \"\\n\\nx, k = map((int), input().split())\\n\\nanswer = []\\n\\n\\ndef findBit(l, r, x, pwk):\\n    for i in range(0, k):\\n        if (l + pwk * i <= x and x <= pwk * i + r):\\n            return i\\n    return 0\\n\\ndef rec(l, r, pwk):\\n    nonlocal x\\n    nonlocal k\\n    nonlocal answer\\n    nk = pwk * (k - 1)\\n    stepL = min(0, nk)\\n    stepR = max(0, nk)\\n    nl = l + stepL\\n    nr = r + stepR\\n    if (nl <= x and x <= nr):\\n        answer.append(findBit(l, r, x, pwk))\\n        x -= answer[-1] * pwk\\n    else:\\n        rec(nl, nr, pwk * (-k))\\n        answer.append(findBit(l, r, x, pwk))\\n        x -= answer[-1] * pwk\\n    \\n\\nrec(0, 0, 1)\\n\\n\\nprint(len(answer))\\nfor x in reversed(answer):\\n    print(x, end = ' ')\\n    \\nprint()\\n\\n\\n\", \"# python3\\n# utf-8\\n\\np, k = (int(x) for x in input().split())\\n\\nrev_p_digits = []\\np2 = p\\ncurr_pow = 1\\ncurr_k_pow = 1\\ni = 0\\nwhile p2 > 0:\\n    # print(p2)\\n    curr_pow += 1\\n    curr_k_pow *= k\\n    if curr_pow % 2 == 1:\\n        rev_p_digits.append((k - (p2 % k)) % k)\\n        p2 += rev_p_digits[-1]\\n    else:\\n        rev_p_digits.append(p2 % k)\\n    p2 //= k\\n\\nprint(len(rev_p_digits))\\nprint(*rev_p_digits)\\n\", \"p, k = list(map(int, input().split()))\\n\\ndef convert(num, base):\\n    res = []\\n    if num == 0:\\n        res = [0]\\n    else:\\n        res = []\\n        while num != 0:\\n            num, rem = divmod(num, -base)\\n            if rem < 0:\\n                num, rem = num + 1, rem + base\\n            res.append(rem)\\n    return res\\n\\nres = convert(p, k)\\nprint(len(res))\\nprint(' '.join([str(x) for x in res]))\\n\", \"p, k = map(int, input().split())\\nl = []\\nd = 0\\nsign = +1\\nwhile (True):\\n\\tt = []\\n\\tst = sign * (k ** d)\\n\\tfor j in range(k):\\n\\t\\tt.append(j * st)\\n\\n\\tl.append(t)\\n\\td += 1\\n\\tsign = -sign\\n\\tif (t[-1] >= p):\\n\\t\\tbreak\\n\\n\\t# print(i, t[-1])\\n\\n# print(d, l)\\na = 0\\nb = 0\\nneg = []\\npos = []\\nfor i in range(d):\\n\\ta += min(l[i][0], l[i][-1])\\n\\tb += max(l[i][0], l[i][-1])\\n\\tneg.append(a)\\n\\tpos.append(b)\\n\\nans = []\\ndone = True\\nfor i in range(d - 1, -1, -1):\\n\\t# print(i)\\n\\tif (i == 0):\\n\\t\\tif p in l[i]:\\n\\t\\t\\tans.append(p)\\n\\t\\telse:\\n\\t\\t\\tdone = False\\n\\t\\tbreak\\n\\n\\tfor j in range(k):\\n\\t\\t# print(j, neg[i - 1], pos[i - 1])\\n\\t\\tif (l[i][j] + neg[i - 1] <= p and l[i][j] + pos[i - 1] >= p):\\n\\t\\t\\tans.append(j)\\n\\t\\t\\tp -= l[i][j]\\n\\t\\t\\t# print(p, j)\\n\\t\\t\\tbreak\\n\\n# print(done, ans)\\n\\nif (done and len(ans) == d):\\n\\twhile (ans[0] == 0):\\n\\t\\tans = ans[1:]\\n\\t\\td -= 1\\n\\n\\tprint(d)\\n\\tfor i in range(d - 1, -1, -1):\\n\\t\\tprint(ans[i], end = ' ')\\nelse:\\n\\tprint(-1)\", \"def negaternary(i, k):\\n    if i == 0:\\n        digits = [0]\\n    else:\\n        digits = []\\n        while i != 0:\\n            i, remainder = divmod(i, -k)\\n            if remainder < 0:\\n                i, remainder = i + 1, remainder + k\\n            digits.append(remainder)\\n    return digits\\n\\n\\np, k = map(int, input().split())\\nans = negaternary(p, k)\\n# while (p):\\n# \\tans.append(p % (-k))\\n# \\tp //= (-k)\\nwhile(ans[-1] == 0):\\n\\tans = ans[::-1]\\nprint(len(ans))\\nprint(*ans)\", \"p, k = list(map(int, input().split()))\\n\\nans = None\\nfor x in range(0, k):\\n    res = []\\n    a = p\\n    used = set()\\n    ok = 1\\n    while 1:\\n        b = (-a+k-1) // k\\n        if b == 0:\\n            res.append(a)\\n            break\\n        res.append(a+k*b)\\n        a = b\\n        if a in used:\\n            ok = 0\\n            break\\n        used.add(a)\\n    if ok:\\n        ans = res\\n        break\\nif ans is None:\\n    print(-1)\\nelse:\\n    print(len(ans))\\n    print(*ans)\\n\", \"p, k = list(map(int, input().split()))\\n\\nn = 0\\ncur = 1\\nans = [0 for i in range(100)]\\n\\nwhile True:\\n  tmp = p\\n  for i in range(n+1):\\n    # print(\\\"i, p: \\\", i, p)\\n    x = (p%k+k)%k\\n    ans[i] = x\\n    p = -(p-x)//k\\n\\n  if p == 0 and ans[n] != 0:    \\n    print(n+1)\\n    for i in range(n+1):\\n      print(ans[i])\\n    break\\n\\n  cur *= k*k\\n  n += 2\\n  p = tmp\\n\", \"p,k  = list(map(int, input().split()))\\ncoeff = [1]\\nmaxi  =k-1\\nkk = k*k\\n\\nwhile maxi < p:\\n    for i in range(2):\\n        coeff.append(0)\\n    maxi += kk*(k-1)\\n    kk*=k*2\\nn = len(coeff)\\npowk = [0 for i in range(n)]\\npos = [0 for i in range(n)]\\nneg = [0 for i in range(n)]\\n\\npowk[0] = 1\\nfor i in range(1,n):\\n    powk[i] = powk[i-1]*k\\npos[0]=k-1;\\nneg[0]=0;\\n\\nfor i in range(1,n):\\n    if i%2 ==0:\\n        pos[i] = pos[i-1]+powk[i]*(k-1);\\n        neg[i] = neg[i-1];\\n    else:\\n        pos[i] = pos[i-1];\\n        neg[i] = neg[i-1] + powk[i]*(k-1);\\n\\nfor i in range(n-1,-1,-1):\\n    if i%2 ==0:\\n        coeff[i] = (p+neg[i])//powk[i];\\n        p-=coeff[i]*powk[i];\\n    else:\\n        coeff[i] = (-p+pos[i])//powk[i];\\n        p+=coeff[i]*powk[i];\\nng = False\\nfor i in range(n):\\n    if coeff[i]>=k:\\n        ng = True\\n\\nif ng:\\n    print(-1)\\nelse:\\n    d=n\\n    for i in range(n-1,-1,-1):\\n        if coeff[i]==0:\\n            d = d-1\\n        else:\\n            break\\n    print(d)\\n    print(' '.join(map(str, coeff[0:d])))\\n\\n\\n\\n\\n\", \"import sys\\n\\ninp = input().split()\\np = int(inp[0])\\nk = int(inp[1])\\nr = 0\\npow = 1\\nwhile 1:\\n\\tif r % 2 == 0 and pow >= p:\\n\\t\\tbreak\\n\\tr = r + 1\\n\\tpow = pow * k\\ni = r\\nans = \\\"\\\"\\nwhile i >= 0:\\n\\tj = 0\\n\\ts = 0\\n\\tx = pow // k\\n\\twhile x > 0:\\n\\t\\ts = s + (k - 1) * x\\n\\t\\tx = (x // k) // k\\n\\tif i == 0:\\n\\t\\tj = p\\n\\telif i % 2 == 0:\\n\\t\\twhile p - pow * j > 0 and p - pow * (j + 1) >= -s:\\n\\t\\t\\tj = j + 1\\n\\t\\tp = p - pow * j\\n\\telse:\\n\\t\\twhile p + pow * j < 0 and  p + pow * (j + 1) <= s:\\n\\t\\t\\tj = j + 1\\n\\t\\tp = p + pow * j\\n\\t\\n\\tif j != 0 or ans != \\\"\\\":\\n\\t\\tans = str(j) + \\\" \\\" + ans\\n\\telse:\\n\\t\\tr = r - 1\\n#\\tprint(p)\\n\\ti = i - 1\\n\\tpow = pow // k\\nprint(r + 1)\\nprint(ans)\", \"p,k=map(int, input().split())\\nl=[]\\nwhile p:\\n\\tl.append((p%k+k)%k)\\n\\tp=(p%k-p)//k\\nprint(len(l))\\nfor i in l:\\n\\tprint(i,end=' ')\", \"p, k = map(int, input().split())\\nr = [p % k]\\np = p // k\\nwhile 1:\\n    if p <= 0 and -p < k:\\n        break\\n    p, q = divmod(-p, k)\\n    r.append(q)\\nif p:\\n    r.append(-p)\\nprint(len(r))\\nprint(*r, sep=' ')\\n\", \"p, k = map(int, input().split())\\nr = []\\nwhile p:\\n    r.append(p % k)\\n    p = -(p // k)\\nprint(len(r))\\nprint(*r, sep=' ')\\n\", \"p,k=list(map(int,input().split()))\\na=[]\\nfor i in range(99):\\n  v=p%k\\n  if v==0 or i%2 == 0:a.append(v)\\n  else:\\n    a.append(k-v)\\n    p+=k\\n  p//=k\\n  if p==0: break\\nprint(len(a))\\nprint(' '.join(list(map(str,a))))\\n\", \"p,k=input().strip().split(' ')\\nflag=1\\np=int(p)\\nk=int(k)\\nA=[]\\nB=[]\\t\\nk=-k\\nwhile p!=0:\\n\\tA.append(p%k)\\n\\tp//=k\\n\\tif A[-1]<0:\\n\\t\\tp+=1\\nfor i in A:\\n\\tif i<0:\\n\\t\\tB.append(i-k);\\n\\telse:\\n\\t\\tB.append(i);\\nprint(len(B))\\nfor i in B:\\n\\tprint(i,end=\\\" \\\")\\n\", \"#This is the solution from Charlieyan. No matter it is AC or not.\\n#Coded in Microsoft Visual Studio by Charlieyan\\np,k=list(map(int,input().split(' ')))\\na=[]\\nwhile p:\\n    a.append(p%k)\\n    p=-(p//k)\\nprint(len(a))\\nprint(\\\" \\\".join(str(a[i]) for i in range(len(a))))\\n#\\u7b2c\\u4e00\\u6b21\\u72ec\\u81ea\\u7528python\\u7f16\\u7a0b\\uff0c\\u5c45\\u7136\\u8f93\\u51fa\\u4e86\\u6b63\\u786e\\u7ed3\\u679c\\n\", \"#This is the solution from Charlieyan. No matter it is AC or not.\\n#Coded in Microsoft Visual Studio by Charlieyan\\np,k=list(map(int,input().split(' ')))\\na=[]\\nwhile p:\\n    a.append(p%k)\\n    p=-(p//k)\\nprint(len(a))\\nprint(\\\" \\\".join(str(a[i]) for i in range(len(a))))\\n#\\u7b2c\\u4e00\\u6b21\\u72ec\\u81ea\\u7528python\\u7f16\\u7a0b\\uff0c\\u5c45\\u7136\\u8f93\\u51fa\\u4e86\\u6b63\\u786e\\u7ed3\\u679c\\n\", \"p,k  = map(int,input().split())\\nnum = [0] * 64\\nsum = 0\\nc = 0\\npower = k-1\\nwhile(sum < p):\\n    sum += power\\n    power *= k*k\\n    c += 2\\n#print(power / k / k << endl << sum << endl;\\nprint(c-1)\\ni = 0\\np = sum - p\\nwhile(p > 0):\\n    num[i] = p % k\\n    p //= k\\n    i += 1\\n#cout << sum << endl;\\nfor i in range(c-1):\\n    #cout << num[i] << \\\" \\\";\\n    if(i % 2 == 0) :print(k - 1 - num[i],end = ' ')\\n    else :print(num[i],end = ' ')\\n\", \"a,b=map(int,input().split())\\nc=-(a//b)\\nout=[a%b]\\nwhile True:\\n    #print(c)\\n    out.append(c%b)\\n    c=-(c//b)\\n    if out[-1]==c==0:\\n        break\\nprint(len(out)-1)\\nfor i in out[:-1]:\\n    print(i,end=\\\" \\\")\\nprint()\\n\\n\\n\\n\\n\\n\\n\\n\", \"n,a = list(map(int,input().split()))\\n\\nar = []\\nj = 1\\n\\nwhile n!=0:\\n q = n%a\\n n //= a\\n n = -1*n\\n #j += 1\\n ar.append(q)\\n\\nprint(len(ar))\\nfor i in range(len(ar)):\\n print(ar[i])\\n\\n\\n\", \"n,k = map(int,input().split())\\na = []\\nwhile n != 0:\\n    t = n % k\\n    a.append(t)\\n    n = -((n-t)//k)\\nprint(len(a))\\na = list(map(str,a))\\nprint(' '.join(a))\", \"p, k = list(map(int, input().split()))\\na = ''\\ncnt = 0\\nwhile p != 0:\\n    cnt += 1\\n    a += str(p % k) + ' '\\n    p -= p % k\\n    p //= -k\\nprint(cnt)\\nprint(a)\\n\\n\", \"p,k = map(int,input().split())\\na = []\\nwhile p != 0:\\n    t = p % k\\n    a.append(t)\\n    p = -((p-t)//k)\\nprint(len(a))\\na = list(map(str,a))\\nprint(' '.join(a))\", \"p, k = list(map(int, input().split()))\\narr = []\\nwhile p:\\n    a, b = divmod(p, -k)\\n    if b < 0:\\n        a += 1\\n        b += k\\n    p = a\\n    arr.append(str(b))\\nprint(len(arr))\\nprint(' '.join(arr))\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"46 2\\n\",\n    \"2018 214\\n\",\n    \"4 2\\n\",\n    \"5 2\\n\",\n    \"10 3\\n\",\n    \"250 1958\\n\",\n    \"1000000000000000000 2000\\n\",\n    \"1 2\\n\",\n    \"2 2\\n\",\n    \"3 2\\n\",\n    \"6 2\\n\",\n    \"7 2\\n\",\n    \"8 2\\n\",\n    \"9 2\\n\",\n    \"10 2\\n\",\n    \"1 3\\n\",\n    \"2 3\\n\",\n    \"3 3\\n\",\n    \"4 3\\n\",\n    \"5 3\\n\",\n    \"6 3\\n\",\n    \"7 3\\n\",\n    \"8 3\\n\",\n    \"9 3\\n\",\n    \"462 2\\n\",\n    \"462 3\\n\",\n    \"2018 4\\n\",\n    \"20180214 5\\n\",\n    \"1317 221\\n\",\n    \"1314 520\\n\",\n    \"1562 862\\n\",\n    \"6666666666666666 3\\n\",\n    \"252525252525252525 252\\n\",\n    \"271828182845904523 536\\n\",\n    \"314159265358979323 846\\n\",\n    \"393939393939393939 393\\n\",\n    \"233333333333333333 2000\\n\",\n    \"998244353998244353 2000\\n\",\n    \"1000000000000000000 2\\n\",\n    \"1000000000000000000 3\\n\"\n  ],\n  \"outputs\": [\n    \"7\\n0 1 0 0 1 1 1\\n\",\n    \"3\\n92 205 1\\n\",\n    \"3\\n0 0 1\\n\",\n    \"3\\n1 0 1\\n\",\n    \"3\\n1 0 1\\n\",\n    \"1\\n250\\n\",\n    \"7\\n0 0 0 0 500 1969 1\\n\",\n    \"1\\n1\\n\",\n    \"3\\n0 1 1\\n\",\n    \"3\\n1 1 1\\n\",\n    \"5\\n0 1 0 1 1\\n\",\n    \"5\\n1 1 0 1 1\\n\",\n    \"5\\n0 0 0 1 1\\n\",\n    \"5\\n1 0 0 1 1\\n\",\n    \"5\\n0 1 1 1 1\\n\",\n    \"1\\n1\\n\",\n    \"1\\n2\\n\",\n    \"3\\n0 2 1\\n\",\n    \"3\\n1 2 1\\n\",\n    \"3\\n2 2 1\\n\",\n    \"3\\n0 1 1\\n\",\n    \"3\\n1 1 1\\n\",\n    \"3\\n2 1 1\\n\",\n    \"3\\n0 0 1\\n\",\n    \"11\\n0 1 0 0 1 0 1 1 0 1 1\\n\",\n    \"7\\n0 2 1 1 0 1 1\\n\",\n    \"7\\n2 0 2 1 0 2 1\\n\",\n    \"11\\n4 3 4 4 4 3 2 2 2 0 2\\n\",\n    \"3\\n212 216 1\\n\",\n    \"3\\n274 518 1\\n\",\n    \"3\\n700 861 1\\n\",\n    \"35\\n0 1 2 0 0 2 2 1 2 2 1 1 2 2 2 2 0 0 0 2 1 2 1 1 1 1 1 2 1 2 0 1 1 2 1\\n\",\n    \"9\\n189 176 211 80 27 238 231 249 1\\n\",\n    \"7\\n3 157 21 240 147 288 12\\n\",\n    \"7\\n553 47 111 353 790 122 1\\n\",\n    \"7\\n237 191 82 181 11 30 107\\n\",\n    \"7\\n1333 1334 1334 1334 584 1993 1\\n\",\n    \"7\\n353 878 500 1456 391 1969 1\\n\",\n    \"61\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 1 1 1 1 1 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 1 0 0 0 0 1 0 0 0 1 0 0 1\\n\",\n    \"39\\n1 0 0 0 2 0 2 2 0 2 0 0 1 1 1 2 1 1 1 0 1 2 2 0 1 1 1 2 0 0 0 1 0 0 0 1 1 1 1\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}