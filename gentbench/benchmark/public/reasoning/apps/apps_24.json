{
    "problem": "You are an expert Python programmer, and here is your task: Alice and Bob decided to eat some fruit. In the kitchen they found a large bag of oranges and apples. Alice immediately took an orange for herself, Bob took an apple. To make the process of sharing the remaining fruit more fun, the friends decided to play a game. They put multiple cards and on each one they wrote a letter, either 'A', or the letter 'B'. Then they began to remove the cards one by one from left to right, every time they removed a card with the letter 'A', Alice gave Bob all the fruits she had at that moment and took out of the bag as many apples and as many oranges as she had before. Thus the number of oranges and apples Alice had, did not change. If the card had written letter 'B', then Bob did the same, that is, he gave Alice all the fruit that he had, and took from the bag the same set of fruit. After the last card way removed, all the fruit in the bag were over.\n\nYou know how many oranges and apples was in the bag at first. Your task is to find any sequence of cards that Alice and Bob could have played with.\n\n\n-----Input-----\n\nThe first line of the input contains two integers, x, y (1 \u2264 x, y \u2264 10^18, xy > 1) \u2014 the number of oranges and apples that were initially in the bag.\n\n\n-----Output-----\n\nPrint any sequence of cards that would meet the problem conditions as a compressed string of characters 'A' and 'B. That means that you need to replace the segments of identical consecutive characters by the number of repetitions of the characters and the actual character. For example, string AAABAABBB should be replaced by string 3A1B2A3B, but cannot be replaced by 2A1A1B2A3B or by 3AB2A3B. See the samples for clarifications of the output format. The string that you print should consist of at most 10^6 characters. It is guaranteed that if the answer exists, its compressed representation exists, consisting of at most 10^6 characters. If there are several possible answers, you are allowed to print any of them.\n\nIf the sequence of cards that meet the problem statement does not not exist, print a single word Impossible.\n\n\n-----Examples-----\nInput\n1 4\n\nOutput\n3B\n\nInput\n2 2\n\nOutput\nImpossible\n\nInput\n3 2\n\nOutput\n1A1B\n\n\n\n-----Note-----\n\nIn the first sample, if the row contained three cards with letter 'B', then Bob should give one apple to Alice three times. So, in the end of the game Alice has one orange and three apples, and Bob has one apple, in total it is one orange and four apples.\n\nIn second sample, there is no answer since one card is not enough for game to finish, and two cards will produce at least three apples or three oranges.\n\nIn the third sample, cards contain letters 'AB', so after removing the first card Bob has one orange and one apple, and after removal of second card Alice has two oranges and one apple. So, in total it is three oranges and two apples.",
    "solution": "[\"import sys\\nread = lambda: list(map(int, sys.stdin.readline().split()))\\nx, y = read()\\n\\nres = []\\nc = 'A'\\nwhile x * y > 1:\\n   k = min(x // y, x - 1)\\n   if k > 0:\\n      res.append('{}{}'.format(k, c))\\n   x, y = y, x - k*y\\n   c = 'A' if c == 'B' else 'B'\\n\\nif x == 0 or y == 0:\\n   print('Impossible')\\nelse:\\n   print(''.join(res))\\n\\n\", \"x, y = map(int,input().split(\\\" \\\"))\\n\\nres = []\\nc = 'A'\\nwhile x * y > 1:\\n   k = min(x // y, x - 1)\\n   if k > 0:\\n      res.append('{}{}'.format(k, c))\\n   x, y = y, x - k*y\\n   c = 'A' if c == 'B' else 'B'\\n\\nif x == 0 or y == 0:\\n   print('Impossible')\\nelse:\\n   print(''.join(res))\", \"def solve(a, b):\\n  r = []\\n  while a and b and a+b > 2:\\n    q = min((a//b + b//a), max(a, b)-1)\\n    r.append(str(q))\\n    if a > b:\\n      r.append('A')\\n      a -= b*q\\n    else:\\n      r.append('B')\\n      b -= a*q\\n  if a != 1 or b != 1:\\n    return 'Impossible'\\n  return ''.join(r)\\n\\ndef main():\\n  a, b = map(int, input().split())\\n  print(solve(a, b))\\n\\nmain()\", \"def gcd(m, n):\\n    if m < n:\\n        m, n = n, m\\n    r = m % n\\n    while r:\\n        m, n = n, r\\n        r = m % n\\n    return n\\n\\n\\ndef search(x, y):\\n    while True:\\n        if x == 1:\\n            ans.extend( [] if y == 1 else (str(y - 1) + 'B') )\\n            return\\n        if y == 1:\\n            ans.extend( [] if x == 1 else (str(x - 1) + 'A') )\\n            return\\n        if x < y:\\n            ans.append(str(y // x) + 'B')\\n            x, y = x, y % x\\n        else:\\n            ans.append(str(x // y) + 'A')\\n            x, y = x % y, y\\n\\na, b = [ int(i) for i in input().split() ]\\n\\nif gcd(a, b) != 1:\\n    print(\\\"Impossible\\\")\\nelse:\\n    ans = []\\n    search(a, b)\\n    \\n    i, length = 0, len(ans)\\n    print(''.join(ans))\", \"def gcd(m, n):\\n    if m < n:\\n        m, n = n, m\\n    r = m % n\\n    while r:\\n        m, n = n, r\\n        r = m % n\\n    return n\\n\\ndef search(x, y):\\n    nonlocal ans\\n    while True:\\n        if x == 1:\\n            ans = ans + (\\\"\\\" if y == 1 else str(y - 1) + 'B')\\n            return\\n        if y == 1:\\n            ans = ans + (\\\"\\\" if x == 1 else str(x - 1) + 'A')\\n            return\\n        if x < y:\\n            ans = ans + str(y // x) + 'B'\\n            x, y = x, y % x\\n        else:\\n            ans = ans + str(x // y) + 'A'\\n            x, y = x % y, y\\n\\na, b = [ int(i) for i in input().split() ]\\n\\nif gcd(a, b) != 1:\\n    print(\\\"Impossible\\\")\\nelse:\\n    ans = \\\"\\\"\\n    search(a, b)\\n    print(ans)\", \"import fractions\\ndef solve(x, y):\\n    if fractions.gcd(x, y) > 1: return 'Impossible'\\n    turn = x > y\\n    if not turn: x, y = y, x\\n    ans = []\\n    while x != 0 and y != 0:\\n        ans.append((x//y, 'A' if turn else 'B'))\\n        x, y = y, x%y\\n        turn = not turn\\n    ans[-1] = (ans[-1][0]-1, ans[-1][1])\\n    return ''.join(str(n) + l for n, l in ans)\\n\\nx, y = [int(x) for x in input().split()]\\nprint(solve(x, y))\\n\", \"a = input().split()\\ntarget = (int(a[0]), int(a[1]))\\nx=(1, 0)\\ny=(0, 1)\\ntoadd=\\\"A\\\"\\nans = \\\"\\\"\\ndef less(a, b):\\n  return a[0]*b[1]<b[0]*a[1]\\nwhile True:\\n    z = (x[0]+y[0], x[1]+y[1])\\n    if z[0] > target[0] or z[1] > target[1]:\\n        print(\\\"Impossible\\\")\\n        return\\n    if z==target:\\n        print(ans)\\n        return\\n    if less(z, target): # z replaces y\\n        low = 1\\n        high = int(1e18)\\n        while (high > low):\\n            guess = (low+high+1)//2\\n            if less((x[0]*guess+y[0], x[1]*guess+y[1]), target):\\n                low = guess\\n            else:\\n                high = guess - 1\\n        ans += str(low)\\n        ans += \\\"A\\\"\\n        y = (y[0] + low * x[0], y[1] + low * x[1])\\n    elif less(target, z):\\n        low = 1\\n        high = int(1e18)\\n        while (high > low):\\n            guess = (low+high+1)//2\\n            if less(target,(x[0]+guess*y[0], x[1]+guess*y[1])):\\n                low = guess\\n            else:\\n                high = guess - 1\\n        ans += str(low)\\n        ans += \\\"B\\\"\\n        x = (x[0] + low * y[0], x[1] + low * y[1])\\n    else:\\n        print(\\\"Impossible\\\")\\n        return\\n\", \"def gcd(x , y):\\n    if(x > y):x , y = y , x\\n    if(x == 0):return y\\n    return gcd(y % x , x)\\nA , B = map(int , input().split())\\ndef solve(X , Y):\\n    if(X > Y):\\n        if(Y == 1):\\n            print(str(X - 1) + \\\"A\\\" , end = \\\"\\\")\\n            return;\\n        else:\\n            print(str(X // Y) + \\\"A\\\" , end = \\\"\\\")\\n            solve(X % Y , Y)\\n    else:\\n        if(X == 1):\\n            print(str(Y - 1) + \\\"B\\\" , end = \\\"\\\")\\n            return;\\n        else:\\n            print(str(Y // X) + \\\"B\\\" , end = \\\"\\\")\\n            solve(X ,  Y % X)\\nif(gcd(A , B) == 1):\\n    solve(A , B)\\nelse:\\n    print(\\\"Impossible\\\")\\n\", \"def gcd(a,b):\\n\\n    if b==0:\\n\\n        return a\\n\\n    else:\\n\\n        return gcd(b, a%b)\\n\\n    \\n\\ndef solve(x, y, a, b):\\n\\n    ans=\\\"\\\"\\n\\n    while not x==1 or not y==1:\\n\\n        if x < y:\\n\\n            x,y,a,b=y,x,b,a\\n\\n        ans+=str((x-1)//y)+a\\n\\n        x = x - (x-1)//y * y\\n\\n    print (ans)\\n\\n    \\n\\nx,y=list(map(int, input().split()))\\n\\nif gcd(x,y)>1:\\n\\n    print (\\\"Impossible\\\")\\n\\nelse:\\n\\n    solve(x,y, \\\"A\\\", \\\"B\\\")\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"def gcd(a,b):\\n\\tif b==0:\\n\\t\\treturn a\\n\\tif a//b!=0:\\n\\t\\tl.append(a//b)\\n\\treturn gcd(b,a%b)\\n\\nl=[]\\nt=[\\\"A\\\",\\\"B\\\"]\\nx,y=list(map(int,input().split()))\\ng=gcd(x,y)\\n\\nl[-1]-=1\\nif g==1:\\n\\tif x>y:\\n\\t\\tstart=0\\n\\telse:\\n\\t\\tstart=1\\n\\ts=''\\n\\tfor v in range(len(l)):\\n\\t\\ts+=str(l[v])+t[(start+v)%2]\\n\\tprint(s)\\n\\n\\nelse:\\n\\tprint('Impossible')\\n\", \"def gcd(x, y):\\n\\tif y == 0:\\n\\t\\treturn x\\n\\treturn gcd(y, x % y)\\nx, y = map(int, input().split())\\nif gcd(x, y) != 1:\\n\\tprint('Impossible')\\n\\treturn\\na = []\\nwhile y != 1:\\n\\ta += [x // y]\\n\\tx %= y\\n\\tx, y = y, x\\na += [x-1]\\ns = 'A'\\nfor x in a:\\n\\tif x > 0:\\n\\t\\tprint(x, end=s)\\n\\ts = 'AB'.replace(s, '') \\n\", \"from math import gcd\\ndef help():\\n\\tans = []\\n\\ta,b = map(int,input().split(\\\" \\\"))\\n\\tif(gcd(a,b)>1):\\n\\t\\tprint(\\\"Impossible\\\")\\n\\t\\treturn\\n\\twhile a!=1 or b!=1:\\n\\t\\tif(a==1):\\n\\t\\t\\tans.append(str(b-1)+\\\"B\\\")\\n\\t\\t\\tbreak\\n\\t\\telif(b==1):\\n\\t\\t\\tans.append(str(a-1)+\\\"A\\\")\\n\\t\\t\\tbreak\\n\\t\\telif(a>b):\\n\\t\\t\\tans.append(str(a//b)+\\\"A\\\")\\n\\t\\t\\ta = a%b\\n\\t\\telif(b>a):\\n\\t\\t\\tans.append(str(b//a)+\\\"B\\\")\\n\\t\\t\\tb = b%a\\n\\tprint(*ans[::],sep=\\\"\\\")\\nhelp()\"]",
    "test": "{\n  \"inputs\": [\n    \"1 4\\n\",\n    \"2 2\\n\",\n    \"3 2\\n\",\n    \"2 1\\n\",\n    \"5 3\\n\",\n    \"5 2\\n\",\n    \"8 5\\n\",\n    \"97 101\\n\",\n    \"1 3\\n\",\n    \"1000000000000000000 999999999999999999\\n\",\n    \"55 89\\n\",\n    \"610 987\\n\",\n    \"4181 6765\\n\",\n    \"46368 75025\\n\",\n    \"832040 514229\\n\",\n    \"5702887 9227465\\n\",\n    \"701408733 433494437\\n\",\n    \"956722026041 591286729879\\n\",\n    \"498454011879264 806515533049393\\n\",\n    \"420196140727489673 679891637638612258\\n\",\n    \"1000000000000000000 1000000000000000000\\n\",\n    \"1000000000000000000 1\\n\",\n    \"2 1000000000000000000\\n\",\n    \"999999999999999999 999999999999999998\\n\",\n    \"616274828435574301 10268395600356301\\n\",\n    \"10808314049304201 270039182096201\\n\",\n    \"1000100020001 100010001\\n\",\n    \"152139002499 367296043199\\n\",\n    \"25220791 839761\\n\",\n    \"27961 931\\n\",\n    \"127601 6382601\\n\",\n    \"1 1000000000000000000\\n\",\n    \"242 100\\n\",\n    \"507769900974602687 547261784951014891\\n\",\n    \"585026192452577797 570146946822492493\\n\",\n    \"568679881256193737 513570106829158157\\n\",\n    \"567036128564717939 510505130335113937\\n\",\n    \"519421744863260201 572972909476222789\\n\",\n    \"529495319593227313 631186172547690847\\n\",\n    \"540431588408227541 540431588408227541\\n\",\n    \"410218934960967047 378596216455001869\\n\",\n    \"395130552422107969 382562323268297483\\n\",\n    \"416445288135075809 416445288135075809\\n\",\n    \"402725448165665593 481342602240996343\\n\",\n    \"412177780967225699 432177937877609093\\n\",\n    \"423506197818989927 442863139846534733\\n\",\n    \"453151988636162147 474019690903735841\\n\",\n    \"408962762283480959 444443583457646111\\n\",\n    \"976540997167958951 969335176443917693\\n\",\n    \"957591654759084713 981022104435698593\\n\",\n    \"962890278562476113 969978235623119279\\n\",\n    \"963716517445592213 976351630941239591\\n\",\n    \"964542760623675601 965233603018687501\\n\",\n    \"977367244641009653 977367244641009653\\n\"\n  ],\n  \"outputs\": [\n    \"3B\\n\",\n    \"Impossible\\n\",\n    \"1A1B\\n\",\n    \"1A\\n\",\n    \"1A1B1A\\n\",\n    \"2A1B\\n\",\n    \"1A1B1A1B\\n\",\n    \"1B24A3B\\n\",\n    \"2B\\n\",\n    \"1A999999999999999998B\\n\",\n    \"1B1A1B1A1B1A1B1A1B\\n\",\n    \"1B1A1B1A1B1A1B1A1B1A1B1A1B1A\\n\",\n    \"1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A\\n\",\n    \"1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B\\n\",\n    \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B\\n\",\n    \"1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B\\n\",\n    \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B\\n\",\n    \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A\\n\",\n    \"1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B\\n\",\n    \"1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B\\n\",\n    \"Impossible\\n\",\n    \"999999999999999999A\\n\",\n    \"Impossible\\n\",\n    \"1A999999999999999997B\\n\",\n    \"60A60B60A60B60A60B60A60B60A60B\\n\",\n    \"40A40B40A40B40A40B40A40B40A40B\\n\",\n    \"10000A10000B10000A\\n\",\n    \"2B2A2B2A2B2A2B2A2B2A2B2A2B2A2B2A2B2A2B2A2B2A2B2A2B2A2B2A2B2A\\n\",\n    \"30A30B30A30B30A\\n\",\n    \"30A30B30A\\n\",\n    \"50B50A50B50A\\n\",\n    \"999999999999999999B\\n\",\n    \"Impossible\\n\",\n    \"Impossible\\n\",\n    \"1A38B3A7B23A2B1A1B1A8B2A1B5A117B2A1B1A2B12A3B10A5B3A2B3A11B2A1B7A\\n\",\n    \"1A9B3A7B2A3B1A1B1A2B3A2B1A3B2A82B1A7B2A14B2A1B1A4B5A3B2A1B9A1B2A1B4A1B3A1B3A2B\\n\",\n    \"1A9B32A1B2A1B368A1B1A1B2A4B1A1B23A14B21A5B1A1B2A4B1A1B3A1B1A1B3A1B5A1B1A9B\\n\",\n    \"1B9A1B2A3B21A1B1A21B2A1B2A12B1A4B1A1B5A160B4A1B1A138B1A1B9A4B3A2B6A\\n\",\n    \"1B5A4B1A4B1A76B3A2B11A3B7A5B1A1B2A2B7A2B2A8B5A3B143A1B3A8B1A5B1A\\n\",\n    \"Impossible\\n\",\n    \"Impossible\\n\",\n    \"Impossible\\n\",\n    \"Impossible\\n\",\n    \"1B5A8B6A2B2A1B20A3B9A5B2A1B4A5B2A4B1A268B9A4B1A1B4A3B2A2B1A2B1A1B3A\\n\",\n    \"1B20A1B1A1B1A3B1A58B1A4B1A13B206A2B2A5B5A22B3A45B1A7B5A1B1A6B1A1B\\n\",\n    \"1B21A1B7A4B76A1B3A2B82A1B18A4B1A13B1A3B6A1B1A2B1A22B1A3B2A1B1A2B27A\\n\",\n    \"1B21A1B2A1B1A16B1A1B1A4B300A1B4A1B11A47B1A6B8A1B1A1B1A2B2A5B3A2B1A7B1A5B1A\\n\",\n    \"1B11A1B1A9B253A1B5A22B6A1B11A4B3A2B1A1B4A1B13A2B4A1B50A1B6A1B5A3B\\n\",\n    \"1A134B1A1B11A3B26A2B3A1B1A2B22A1B3A3B1A1B66A63B36A2B1A13B5A3B\\n\",\n    \"1B40A1B6A1B1A1B68A1B18A2B3A1B2A2B2A1B1A4B1A3B2A1B12A3B604A5B1A1B39A1B1A\\n\",\n    \"1B135A1B5A1B1A1B1A2B1A1B3A4B2A1B2A2B1A5B3A1B2A2B2A1B2A1B3A2B67A1B1A6B3A1B14A1B3A19B\\n\",\n    \"1B76A3B1A1B1A52B1A6B2A7B35A1B1A2B17A5B5A4B5A9B3A2B13A1B2A3B1A7B\\n\",\n    \"1B1396A5B2A4B2A2B1A18B4A1B1A1B2A3B3A1B10A2B3A1B3A1B5A1B1A1B2A10B3A9B1A1B3A2B\\n\",\n    \"Impossible\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}