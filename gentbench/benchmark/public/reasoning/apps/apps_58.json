{
    "problem": "You are an expert Python programmer, and here is your task: As usual, Sereja has array a, its elements are integers: a[1], a[2], ..., a[n]. Let's introduce notation:\n\n$f(a, l, r) = \\sum_{i = l}^{r} a [ i ] ; m(a) = \\operatorname{max}_{1 \\leq l \\leq r \\leq n} f(a, l, r)$\n\nA swap operation is the following sequence of actions:\n\n  choose two indexes i, j (i \u2260 j);  perform assignments tmp = a[i], a[i] = a[j], a[j] = tmp. \n\nWhat maximum value of function m(a) can Sereja get if he is allowed to perform at most k swap operations?\n\n\n-----Input-----\n\nThe first line contains two integers n and k (1 \u2264 n \u2264 200;\u00a01 \u2264 k \u2264 10). The next line contains n integers a[1], a[2], ..., a[n] ( - 1000 \u2264 a[i] \u2264 1000).\n\n\n-----Output-----\n\nIn a single line print the maximum value of m(a) that Sereja can get if he is allowed to perform at most k swap operations.\n\n\n-----Examples-----\nInput\n10 2\n10 -1 2 2 2 2 2 2 -1 10\n\nOutput\n32\n\nInput\n5 10\n-1 -1 -1 -1 -1\n\nOutput\n-1",
    "solution": "[\"def solve(a,l,r,k):\\n    out = sorted(a[:l]+a[r:],reverse=True)\\n    inside = sorted(a[l:r])\\n    cur = sum(a[l:r])\\n    for i in range(min(k,len(inside),len(out))):\\n        if out[i] > inside[i]:\\n            cur += out[i]-inside[i]\\n        else:\\n            break\\n    return cur\\n\\nn,k = [int(x) for x in input().split()]\\na = [int(x) for x in input().split()]\\nassert len(a) == n\\n\\nbest = a[0]\\nfor l in range(n):\\n    for r in range(l+1,n+1):\\n        cur = solve(a,l,r,k)\\n        if cur > best:\\n            best = cur\\n\\nprint(best)\\n\", \"read_line = lambda: [int(i) for i in input().split()]\\nn, k = read_line()\\nx = read_line()\\nprint(max(sum(sorted(x[l:r] + sorted(x[:l] + x[r:])[-k:])[l-r:]) for l in range(n) for r in range(l + 1, n + 1)))\\n\", \"def main():\\n\\tn, k = map(int, input().split())\\n\\ta = list(map(int, input().split()))\\n\\n\\ts = a[0]\\n\\tfor l in range(n):\\n\\t\\tfor r in range(l,n):\\n\\t\\t\\tout = sorted(a[:l] + a[r+1:], reverse=True)\\n\\t\\t\\tinside = sorted(a[l:r+1])\\n\\t\\t\\ttemp = sum(a[l:r+1])\\n\\t\\t\\tfor i in range(min(k, len(out), len(inside))):\\n\\t\\t\\t\\tif out[i] > inside[i]:\\n\\t\\t\\t\\t\\ttemp += out[i] - inside[i]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif temp > s:\\n\\t\\t\\t\\ts = temp\\n\\tprint(s)\\n\\nmain()\", \"from bisect import bisect_left, bisect_right\\n\\nn, k = map(int, input().split())\\nt = list(map(int, input().split()))\\np = sorted(t)\\n\\nif p[-1] <= 0:\\n    print(p[-1])\\n    return\\nif p[0] >= 0:\\n    print(sum(p))\\n    return\\ni = max(0, n - k - 1)\\nwhile p[i] < 0: i += 1\\nq = sum(p[i: ])\\nif n < k + 2 or p[n - k - 1] <= 0:\\n    print(q)\\n    return\\n\\nfor l in range(n - k - 2):\\n    r = l + k + 2\\n    u = sorted(t[: l] + t[r: ])\\n    v = sorted(t[l: r])\\n    for i in range(r, n):\\n        q = max(q, sum(sorted(v + u[- min(k, len(u)): ])[- len(v): ]))\\n        u.remove(t[i])\\n        v.insert(bisect_left(v, t[i]), t[i])\\n    q = max(q, sum(sorted(v + u[- min(k, len(u)): ])[- len(v): ]))\\nprint(q)\", \"n,k = map(int, input().split(' '))\\nA = list(map(int, input().split(' ')))\\nbest = max(A)\\nfor left in range(n) :\\n    for right in range(left, n) :\\n        inner = A[left:right+1]\\n        outer = A[:left]+A[right+1:]\\n        inner.sort()\\n        outer.sort(reverse = True)\\n        for i in range(k) :\\n            if i >= len(inner) or i >= len(outer) : break\\n            if inner[i] < outer[i] :\\n                inner[i] = outer[i]\\n            else : break\\n        best = max(best, sum(inner))\\nprint(best)\", \"# coding=utf-8\\nimport sys\\n\\n\\nR = lambda: list(map(int, input().split()))\\n\\n\\ndef f(l, r):\\n    ans = sum(a[l:r + 1])\\n\\n    a1 = sorted(a[l:r + 1])\\n    a2 = sorted(a[:l] + a[r + 1:], reverse=True)\\n\\n\\n    for i in range(min(k, len(a1), len(a2))):\\n        m = min(a1)\\n        if a2[i] > m:\\n            ans += a2[i] - m\\n            a1[a1.index(m)] = a2[i]\\n\\n    return ans\\n\\n\\nn, k = R()\\n\\na = R()\\n\\nprint(max(f(l,r) for l in range(n) for r in range(l,n)))\", \"n, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\n\\ns = a[0]\\nfor l in range(n):\\n\\tfor r in range(l,n):\\n\\t\\tout = sorted(a[:l] + a[r+1:], reverse=True)\\n\\t\\tinside = sorted(a[l:r+1])\\n\\t\\ttemp = sum(a[l:r+1])\\n\\t\\tfor i in range(min(k, len(out), len(inside))):\\n\\t\\t\\tif out[i] > inside[i]:\\n\\t\\t\\t\\ttemp += out[i] - inside[i]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbreak\\n\\t\\tif temp > s:\\n\\t\\t\\ts = temp\\nprint(s)\\n\", \"read_line = lambda: [int(i) for i in input().split()]\\nn, k = read_line()\\nx = read_line()\\nprint(max(sum(sorted(x[l:r] + sorted(x[:l] + x[r:])[-k:])[l-r:]) for l in range(n) for r in range(l + 1, n + 1)))\\n\", \"read_line = lambda: [int(i) for i in input().split()]\\nn, k = read_line()\\nx = read_line()\\nprint(max(sum(sorted(x[l:r] + sorted(x[:l] + x[r:])[-k:])[l-r:]) for l in range(n) for r in range(l + 1, n + 1)))\", \"read_line = lambda: [int(i) for i in input().split()]\\nn, k = read_line()\\nx = read_line()\\nprint(max(sum(sorted(x[l:r] + sorted(x[:l] + x[r:])[-k:])[l-r:]) for l in range(n) for r in range(l + 1, n + 1)))\\n\\n\", \"read_line = lambda: [int(i) for i in input().split()]\\nn, k = read_line()\\nx = read_line()\\nprint(max(sum(sorted(x[l:r] + sorted(x[:l] + x[r:])[-k:])[l-r:]) for l in range(n) for r in range(l + 1, n + 1)))\\n\\n\", \"read_line = lambda: [int(i) for i in input().split()]\\nn, k = read_line()\\nx = read_line()\\nprint(max(sum(sorted(x[l:r] + sorted(x[:l] + x[r:])[-k:])[l-r:]) for l in range(n) for r in range(l + 1, n + 1)))\\n\\n\", \"read_line = lambda: [int(i) for i in input().split()]\\nn, k = read_line()\\nx = read_line()\\nprint(max(sum(sorted(x[l:r] + sorted(x[:l] + x[r:])[-k:])[l-r:]) for l in range(n) for r in range(l + 1, n + 1)))\\n\\n\", \"read_line = lambda: [int(i) for i in input().split()]\\nn, k = read_line()\\nx = read_line()\\nprint(max(sum(sorted(x[l:r] + sorted(x[:l] + x[r:])[-k:])[l-r:]) for l in range(n) for r in range(l + 1, n + 1)))\\n\\n\", \"read_line = lambda: [int(i) for i in input().split()]\\nn, k = read_line()\\nx = read_line()\\nprint(max(sum(sorted(x[l:r] + sorted(x[:l] + x[r:])[-k:])[l-r:]) for l in range(n) for r in range(l + 1, n + 1)))\\n\\n\", \"read_line = lambda: [int(i) for i in input().split()]\\nn, k = read_line()\\nx = read_line()\\nprint(max(sum(sorted(x[l:r] + sorted(x[:l] + x[r:])[-k:])[l-r:]) for l in range(n) for r in range(l + 1, n + 1)))\\n\\n\", \"read_line = lambda: [int(i) for i in input().split()]\\nn, k = read_line()\\nx = read_line()\\nprint(max(sum(sorted(x[l:r] + sorted(x[:l] + x[r:])[-k:])[l-r:]) for l in range(n) for r in range(l + 1, n + 1)))\\n\\n\", \"def solve(curr,other,k):\\n    t=0 \\n    while t<k and t<len(curr) and t<len(other) and other[t]>curr[t]:\\n        t+=1 \\n    return t\\n\\nn,k=map(int,input().split())\\narr=list(map(int,input().split()))\\nmaxx=-10**100\\nfor i in range(n):\\n    curr=[]\\n    other=sorted(arr[:i]+arr[i+1:],reverse=True)\\n    for j in range(i,n):\\n        curr.append(arr[j])\\n        curr.sort()\\n        if j<n-1:\\n            del other[other.index(arr[j+1])]\\n        #print(other)\\n        t=min(len(curr),len(other),k)\\n        t=solve(curr,other,k)\\n        maxx=max(maxx,sum(curr)-sum(curr[:t])+sum(other[:t]))\\n        #print(curr,other,sum(curr)-sum(curr[:t])+sum(other[:t]))\\n    #print(maxx)\\n    #print(curr,other)\\nprint(maxx)\", \"# Made By Mostafa_Khaled \\nbot = True \\nread_line = lambda: [int(i) for i in input().split()]\\nn, k = read_line()\\nx = read_line()\\nprint(max(sum(sorted(x[l:r] + sorted(x[:l] + x[r:])[-k:])[l-r:]) for l in range(n) for r in range(l + 1, n + 1)))\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"n,k=map(int,input().split())\\na=[int(i) for i in input().split()]\\nbest=max(a)\\nfor left in range(n):\\n    for right in range(left,n):\\n        inner=a[left:right+1]\\n        outer=a[0:left]+a[right+1:]\\n        inner.sort()\\n        outer.sort(reverse=True)\\n        for i in range(k):\\n            if i>=len(outer) or i>=len(inner): break \\n            if inner[i]<outer[i]:\\n                inner[i]=outer[i]\\n            else :\\n                break \\n        best=max(best,sum(inner)) \\nprint(best)\", \"import os\\nif not(\\\"BEFUNGEE_HOME\\\" in os.environ.keys()):\\n    f=open(\\\"input.txt\\\",\\\"r\\\")\\n    input=f.readline\\nn,k=list(map(int,input().split()))\\na=list(map(int,input().split()))\\n\\ndef f(l,r):\\n    original_sequence=a[l:r+1]\\n    outside_sequence=a[:l]+a[r+1:]\\n    original_sequence.sort()\\n    outside_sequence.sort(reverse=True)\\n    k_=min(k,len(original_sequence),len(outside_sequence))\\n    original_sequence[:k_]=[max(x,y) for x,y in zip(original_sequence[:k_],outside_sequence[:k_])]\\n    s=sum(original_sequence)\\n    return s\\n\\nresult=-2000000\\nfor l in range(n):\\n    for r in range(l,n):\\n        result=max(f(l,r),result)\\n\\nprint(result)\", \"readline = lambda : [int(x) for x in input().split()]\\nn, k = readline()\\na = readline()\\nbest = max(a)\\nfor left in range(n):\\n    for right in range(left, n):\\n        inner = a[left:right+1]\\n        outer = a[:left]+a[right+1:]\\n        inner.sort()\\n        outer.sort(reverse=True)\\n        \\n        for i in range(k): #check for k number of swaps for this combination\\n            if i>=len(inner) or i>=len(outer): break\\n            if inner[i]<outer[i]:\\n                inner[i]=outer[i] #don't give a swap fuck haha,,, bitch!\\n            else:\\n                break #no more chances\\n        best = max(best, sum(inner)) #results update\\nprint(best)\\n\", \"n, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\n\\ndef solve(i, j):\\n    cur_res = sum(a[i:j+1])\\n    a1 = sorted(a[i:j+1])\\n    a2 = sorted(a[:i] + a[j+1:], reverse=True)\\n    for t in range(min(k, len(a1), len(a2))):\\n        m = min(a1)\\n        if a2[t] > m:\\n            cur_res += a2[t] - m\\n            a1[a1.index(m)] = a2[t]\\n    return cur_res\\n\\nprint(max(solve(i, j) for i in range(n) for j in range(i, n)))\\n\", \"# HEY STALKER\\nn, kr = map(int, input().split())\\nl = list(map(int, input().split()))\\nans = -2e18\\nfor i in range(n):\\n    for j in range(i, n):\\n        k = kr\\n        sub = l[i:j+1]\\n        sub_sum = sum(sub)\\n        sub.sort()\\n        chk = l[0:i] + l[j+1:]\\n        chk.sort()\\n        chk.reverse()\\n        ans = max(ans, sub_sum)\\n        for t in range(len(sub)):\\n            if t < len(chk) and k > 0:\\n                if sub[t] < chk[t]:\\n                    sub_sum -= sub[t]\\n                    sub_sum += chk[t]\\n                    ans = max(ans, sub_sum)\\n                    k -= 1\\n            else:\\n                break\\nprint(ans)\", \"from operator import itemgetter\\nfrom sys import stdin, stdout\\n\\n\\ndef solve(a, k):\\n    aa = list(map(lambda x: [x[1], x[0]], enumerate(a)))\\n    aa.sort(reverse=True, key=itemgetter(0))\\n    if aa[0][0] < 0:\\n        return aa[0][0]\\n\\n    best = -float(\\\"inf\\\")\\n    for i in range(len(a)):\\n        for j in range(1, len(a)+1):\\n            in_range = sorted(a[i:j], reverse=True)\\n            out_of_range = sorted(a[:i] + a[j:])\\n            additional = []\\n            for kk in range(k):\\n                if len(out_of_range) > 0 and len(in_range) > 0 and in_range[-1] < out_of_range[-1]:\\n                    in_range.pop()\\n                    additional.append(out_of_range.pop())\\n            best = max(best, sum(in_range + additional))\\n\\n    return best\\n\\n\\n\\n\\ndef __starting_point():\\n    n, k = map(int, stdin.readline().split())\\n    a = [int(x) for x in stdin.readline().split()]\\n    stdout.write(\\\"{}\\\\n\\\".format(solve(a, k)))\\n__starting_point()\"]",
    "test": "{\n  \"inputs\": [\n    \"10 2\\n10 -1 2 2 2 2 2 2 -1 10\\n\",\n    \"5 10\\n-1 -1 -1 -1 -1\\n\",\n    \"18 1\\n166 788 276 -103 -491 195 -960 389 376 369 630 285 3 575 315 -987 820 466\\n\",\n    \"29 6\\n-21 486 -630 -433 -123 -387 618 110 -203 55 -123 524 -168 662 432 378 -155 -136 -162 811 457 -157 -215 861 -565 -506 557 348 -7\\n\",\n    \"9 9\\n-767 148 -323 -818 41 -228 615 885 -260\\n\",\n    \"35 5\\n151 -160 -292 -31 -131 174 359 42 438 413 164 91 118 393 76 435 371 -76 145 605 292 578 623 405 664 330 455 329 66 168 179 -76 996 163 531\\n\",\n    \"47 10\\n-175 246 -903 681 748 -338 333 0 666 245 370 402 -38 682 144 658 -10 313 295 351 -95 149 111 -210 645 -173 -276 690 593 697 259 698 421 584 -229 445 -215 -203 49 642 386 649 469 4 340 484 279\\n\",\n    \"11 7\\n877 -188 10 -175 217 -254 841 380 552 -607 228\\n\",\n    \"38 1\\n173 587 -788 163 83 -768 461 -527 350 3 -898 634 -217 -528 317 -238 545 93 -964 283 -798 -596 77 222 -370 -209 61 846 -831 -419 -366 -509 -356 -649 916 -391 981 -596\\n\",\n    \"6 9\\n-669 45 -220 544 106 680\\n\",\n    \"32 9\\n-650 -208 506 812 -540 -275 -272 -236 -96 197 425 475 81 570 281 633 449 396 401 -362 -379 667 717 875 658 114 294 100 286 112 -928 -373\\n\",\n    \"36 5\\n-286 762 -5 -230 -483 -140 -143 -82 -127 449 435 85 -262 567 454 -163 942 -679 -609 854 -533 717 -101 92 -767 795 -804 -953 -754 -251 -100 884 809 -358 469 -112\\n\",\n    \"24 5\\n-751 889 721 -900 903 -900 -693 895 828 314 836 -493 549 -74 264 662 229 517 -223 367 141 -99 -390 283\\n\",\n    \"82 8\\n-483 465 435 -789 80 -412 672 512 -755 981 784 -281 -634 -270 806 887 -495 -46 -244 609 42 -821 100 -40 -299 -6 560 941 523 758 -730 -930 91 -138 -299 0 533 -208 -416 869 967 -871 573 165 -279 298 934 -236 70 800 550 433 139 147 139 -212 137 -933 -863 876 -622 193 -121 -944 983 -592 -40 -712 891 985 16 580 -845 -903 -986 952 -95 -613 -2 -45 -86 -206\\n\",\n    \"116 10\\n477 -765 -756 376 -48 -75 768 -658 263 -207 362 -535 96 -960 630 -686 609 -830 889 57 -239 346 -298 -18 -107 853 -607 -443 -517 371 657 105 479 498 -47 432 503 -917 -656 610 -466 216 -747 -587 -163 -174 493 -882 853 -582 -774 -477 -386 610 -58 557 968 196 69 610 -38 366 -79 574 170 317 332 189 158 -194 136 -151 500 309 624 316 543 472 132 -15 -78 166 360 -71 12 247 678 263 573 -198 1 101 155 -65 597 -93 60 3 -496 985 -586 -761 -532 506 578 -13 569 845 -341 870 -900 891 724 408 229 -210\\n\",\n    \"110 4\\n-813 -73 334 667 602 -155 432 -133 689 397 461 499 630 40 69 299 697 449 -130 210 -146 415 292 123 12 -105 444 338 509 497 142 688 603 107 -108 160 211 -215 219 -144 637 -173 615 -210 521 545 377 -6 -187 354 647 309 139 309 155 -242 546 -231 -267 405 411 -271 -149 264 -169 -447 -749 -218 273 -798 -135 839 54 -764 279 -578 -641 -152 -881 241 174 31 525 621 -855 656 482 -197 -402 995 785 338 -733 293 606 294 -645 262 909 325 -246 -952 408 646 2 -567 -484 661 -390 -488\\n\",\n    \"94 2\\n432 255 304 757 -438 52 461 55 837 -564 304 713 -968 -539 -593 835 -824 -532 38 -880 -772 480 -755 -387 -830 286 -38 -202 -273 423 272 471 -224 306 490 532 -210 -245 -20 680 -236 404 -5 -188 387 582 -30 -800 276 -811 240 -4 214 -708 200 -785 -466 61 16 -742 647 -371 -851 -295 -552 480 38 924 403 704 -705 -972 677 569 450 446 816 396 -179 281 -564 -27 -272 -640 809 29 28 -209 -925 997 -268 133 265 161\\n\",\n    \"78 8\\n-230 -757 673 -284 381 -324 -96 975 249 971 -355 186 -526 804 147 -553 655 263 -247 775 108 -246 -107 25 -786 -372 -24 -619 265 -192 269 392 210 449 335 -207 371 562 307 141 668 78 13 251 623 -238 60 543 618 201 73 -35 -663 620 485 444 330 362 -33 484 685 257 542 375 -952 48 -604 -288 -19 -718 -798 946 -533 -666 -686 -278 368 -294\\n\",\n    \"1 10\\n-1\\n\",\n    \"1 1\\n-1\\n\",\n    \"1 1\\n1\\n\",\n    \"1 10\\n1\\n\",\n    \"10 1\\n-1 1 1 1 1 1 1 1 1 1\\n\"\n  ],\n  \"outputs\": [\n    \"32\\n\",\n    \"-1\\n\",\n    \"5016\\n\",\n    \"6299\\n\",\n    \"1689\\n\",\n    \"9754\\n\",\n    \"14728\\n\",\n    \"3105\\n\",\n    \"2743\\n\",\n    \"1375\\n\",\n    \"9049\\n\",\n    \"8222\\n\",\n    \"8398\\n\",\n    \"18704\\n\",\n    \"24624\\n\",\n    \"20286\\n\",\n    \"7839\\n\",\n    \"17941\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"9\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}