{
    "problem": "You are an expert Python programmer, and here is your task: Consider a table G of size n \u00d7 m such that G(i, j) = GCD(i, j) for all 1 \u2264 i \u2264 n, 1 \u2264 j \u2264 m. GCD(a, b) is the greatest common divisor of numbers a and b.\n\nYou have a sequence of positive integer numbers a_1, a_2, ..., a_{k}. We say that this sequence occurs in table G if it coincides with consecutive elements in some row, starting from some position. More formally, such numbers 1 \u2264 i \u2264 n and 1 \u2264 j \u2264 m - k + 1 should exist that G(i, j + l - 1) = a_{l} for all 1 \u2264 l \u2264 k.\n\nDetermine if the sequence a occurs in table G.\n\n\n-----Input-----\n\nThe first line contains three space-separated integers n, m and k (1 \u2264 n, m \u2264 10^12; 1 \u2264 k \u2264 10000). The second line contains k space-separated integers a_1, a_2, ..., a_{k} (1 \u2264 a_{i} \u2264 10^12).\n\n\n-----Output-----\n\nPrint a single word \"YES\", if the given sequence occurs in table G, otherwise print \"NO\".\n\n\n-----Examples-----\nInput\n100 100 5\n5 2 1 2 1\n\nOutput\nYES\n\nInput\n100 8 5\n5 2 1 2 1\n\nOutput\nNO\n\nInput\n100 100 7\n1 2 3 4 5 6 7\n\nOutput\nNO\n\n\n\n-----Note-----\n\nSample 1. The tenth row of table G starts from sequence {1, 2, 1, 2, 5, 2, 1, 2, 1, 10}. As you can see, elements from fifth to ninth coincide with sequence a.\n\nSample 2. This time the width of table G equals 8. Sequence a doesn't occur there.",
    "solution": "[\"'''\\nCreated on Aug 28, 2016\\n\\n@author: Md. Rezwanul Haque\\n'''\\ndef gcd(a,b):\\n    if b == 0:\\n        return a \\n    return gcd(b, a%b) \\ndef extend_euclid(a,b):\\n    if b == 0:\\n        return 1,0 \\n    else:\\n        y,x = extend_euclid(b, a%b)\\n        y = y - (a//b)*x\\n        return x,y \\n\\nn,m,k = map(int,input().split())\\na = list(map(int,input().split()))\\n\\nlcm = 1\\nfor i in a:\\n    lcm = (lcm*i)//gcd(lcm, i)\\n    if lcm>n:\\n        print('NO')\\n        return\\nj = 0\\nm1 = 1\\ns = True\\nfor i in range(k):\\n    x,y = extend_euclid(m1, a[i])\\n    res = m1*x + a[i]*y \\n    if (-i-j)%res != 0:\\n        s = False\\n        break\\n    res = (-i-j)//res \\n    x,y = x*res , y*res \\n    j += m1*x \\n    t = m1*a[i]\\n    if j>t:\\n        j -= (j//t)*t \\n    if j<0:\\n        j += ((-j+t-1)//t)*t \\n    if j == 0:\\n        j = t \\n    m1 = (m1*a[i])//gcd(m1, a[i])\\n    \\nif j+k-1 >m or s == False:\\n    print('NO')\\n    return\\nb = [gcd(lcm, j+i) for i in range(k)]\\nfor i in range(k):\\n    if (a[i] != b[i]):\\n        print('NO')\\n        return\\nprint('YES')\", \"def gcd(a,b):\\n\\tif a<b:\\n\\t\\tc=b\\n\\t\\tb=a\\n\\t\\ta=c\\n\\twhile b!=0:\\n\\t\\tt=b\\n\\t\\tb=a%b \\n\\t\\ta=t\\n\\treturn int(a)\\ndef extendedEuclides(a,b):\\n\\txx=y=0\\n\\tyy=x=1\\n\\twhile b!=0:\\n\\t\\tq=int(a/b)\\n\\t\\tt=b\\n\\t\\tb=a%b\\n\\t\\ta=t\\n\\t\\tt=xx\\n\\t\\txx=x-q*xx\\n\\t\\tx=t\\n\\t\\tt=yy\\n\\t\\tyy=y-q*yy\\n\\t\\ty=t\\n\\treturn [a,x,y]\\ndef chineseRemainder(x,y,a,b):\\n\\t[d,s,t]=extendedEuclides(x,y)\\n\\tif(a%d!=b%d):\\n\\t\\treturn [0,-1]\\n\\treturn [int(((s*b*x+t*a*y)%(x*y))/d),x*y/d]\\n[n,m,k]=input().split(' ')\\nn=eval(n)\\nm=eval(m)\\nk=eval(k)\\narr=list(map(int,input().split(' ')))\\nI=1\\nfor el in arr:\\n\\tI=I*(el/gcd(I,el))\\n\\tif I>n:\\n\\t\\tbreak\\nif I==1:\\n\\tprint(\\\"YES\\\")\\nelif I>n:\\t\\n\\tprint(\\\"NO\\\")\\nelse:\\n\\tcan=1\\n\\tauxI=I\\n\\tfat=[]\\n\\toccur=[]\\n\\tfor i in range(2,1010000):\\n\\t\\tif auxI%i==0:\\n\\t\\t\\tv=1\\n\\t\\t\\twhile auxI%i==0:\\n\\t\\t\\t\\tv=v*i\\n\\t\\t\\t\\tfat.append(v)\\n\\t\\t\\t\\toccur.append(-1)\\n\\t\\t\\t\\tauxI=int(auxI/i)\\n\\tif auxI>1:\\n\\t\\tfat.append(auxI)\\n\\t\\toccur.append(-1)\\n\\tfor i,x in enumerate(fat):\\n\\t\\tfor j in range(0,min(k,x)):\\n\\t\\t\\tif(gcd(arr[j],x)==x):\\n\\t\\t\\t\\toccur[i]=j\\n\\t\\tif occur[i]==-1:\\n\\t\\t\\tcan=0\\n\\tfor i,x in enumerate(fat):\\t\\t\\n\\t\\tfor j in range(0,k):\\n\\t\\t\\tif ((gcd(arr[j],x)!=x and j%x==occur[i])or(gcd(arr[j],x)==x and j%x!=occur[i])):\\n\\t\\t\\t\\tcan=0\\n\\tI=1\\n\\tJ=1\\n\\tlrem=0\\n\\tfor i,x in enumerate(fat):\\n\\t\\trem=(x-occur[i])%x\\n\\t\\tg=gcd(I,x)\\n\\t\\tauxI=I*int(x/g)\\n\\t\\txxx=chineseRemainder(I,x,lrem%I,rem)\\n\\t\\tlrem=xxx[0]\\n\\t\\tI=auxI\\n\\t\\t#print(lrem,rem,x,I)\\n\\tif lrem==0:\\n\\t\\tlrem=I\\n\\tif int(lrem)>m-k+1:\\n\\t\\tcan=0\\n\\tif can==0:\\n\\t\\tprint('NO')\\n\\telse:\\n\\t\\tprint('YES')\\n\\n# 1491583140056\\n\", \"def gcd(a,b):\\n\\tif a<b:\\n\\t\\tc=b\\n\\t\\tb=a\\n\\t\\ta=c\\n\\twhile b!=0:\\n\\t\\tt=b\\n\\t\\tb=a%b \\n\\t\\ta=t\\n\\treturn int(a)\\ndef extendedEuclides(a,b):\\n\\txx=y=0\\n\\tyy=x=1\\n\\twhile b!=0:\\n\\t\\tq=int(a/b)\\n\\t\\tt=b\\n\\t\\tb=a%b\\n\\t\\ta=t\\n\\t\\tt=xx\\n\\t\\txx=x-q*xx\\n\\t\\tx=t\\n\\t\\tt=yy\\n\\t\\tyy=y-q*yy\\n\\t\\ty=t\\n\\treturn [a,x,y]\\ndef chineseRemainder(x,y,a,b):\\n\\t[d,s,t]=extendedEuclides(x,y)\\n\\tif(a%d!=b%d):\\n\\t\\treturn [0,-1]\\n\\treturn [int(((s*b*x+t*a*y)%(x*y))/d),x*y/d]\\n[n,m,k]=input().split(' ')\\nn=eval(n)\\nm=eval(m)\\nk=eval(k)\\narr=list(map(int,input().split(' ')))\\nI=1\\nfor el in arr:\\n\\tI=I*(el/gcd(I,el))\\n\\tif I>n:\\n\\t\\tbreak\\nif I==1:\\n\\tprint(\\\"YES\\\")\\nelif I>n:\\t\\n\\tprint(\\\"NO\\\")\\nelse:\\n\\tcan=1\\n\\tauxI=I\\n\\tfat=[]\\n\\toccur=[]\\n\\tfor i in range(2,1010000):\\n\\t\\tif auxI%i==0:\\n\\t\\t\\tv=1\\n\\t\\t\\twhile auxI%i==0:\\n\\t\\t\\t\\tv=v*i\\n\\t\\t\\t\\tfat.append(v)\\n\\t\\t\\t\\toccur.append(-1)\\n\\t\\t\\t\\tauxI=int(auxI/i)\\n\\tif auxI>1:\\n\\t\\tfat.append(auxI)\\n\\t\\toccur.append(-1)\\n\\tfor i,x in enumerate(fat):\\n\\t\\tfor j in range(0,min(k,x)):\\n\\t\\t\\tif(gcd(arr[j],x)==x):\\n\\t\\t\\t\\toccur[i]=j\\n\\t\\tif occur[i]==-1:\\n\\t\\t\\tcan=0\\n\\tfor i,x in enumerate(fat):\\t\\t\\n\\t\\tfor j in range(0,k):\\n\\t\\t\\tif ((gcd(arr[j],x)!=x and j%x==occur[i])or(gcd(arr[j],x)==x and j%x!=occur[i])):\\n\\t\\t\\t\\tcan=0\\n\\tI=1\\n\\tJ=1\\n\\tlrem=0\\n\\tfor i,x in enumerate(fat):\\n\\t\\trem=(x-occur[i])%x\\n\\t\\tg=gcd(I,x)\\n\\t\\tauxI=I*int(x/g)\\n\\t\\txxx=chineseRemainder(I,x,lrem%I,rem)\\n\\t\\tlrem=xxx[0]\\n\\t\\tI=auxI\\n\\t\\t#print(lrem,rem,x,I)\\n\\tif lrem==0:\\n\\t\\tlrem=I\\n\\tif int(lrem)>m-k+1:\\n\\t\\tcan=0\\n\\tif can==0:\\n\\t\\tprint('NO')\\n\\telse:\\n\\t\\tprint('YES')\\n\\n# 1491583330722\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"100 100 5\\n5 2 1 2 1\\n\",\n    \"100 8 5\\n5 2 1 2 1\\n\",\n    \"100 100 7\\n1 2 3 4 5 6 7\\n\",\n    \"5 5 5\\n1 1 1 1 1\\n\",\n    \"11 10 1\\n11\\n\",\n    \"108 942 35\\n1 1 3 1 1 3 1 1 3 1 1 3 1 1 3 1 1 3 1 1 3 1 1 3 31 1 3 1 1 3 1 1 3 1 1\\n\",\n    \"1000000000000 1000000000000 116\\n1587924000 7 2 3 4 5 6 1 56 9 10 1 12 13 2 105 16 1 18 1 620 3 14 1 24 25 26 27 4 203 30 1 32 3 2 5 252 1 2 39 40 1 6 7 4 45 2 1 48 1 350 93 52 1 54 5 8 21 58 1 60 1 2 9 224 65 6 1 4 3 10 7 72 1 2 75 4 1 546 1 80 81 62 1 12 35 2 87 8 1 90 13 28 3 2 5 96 1 2 63 100 1 6 1 104 15 14 1 108 1 10 3 16 217 6 5\\n\",\n    \"1000000000000 1000000000000 10\\n99991 99992 99993 99994 99995 99996 99997 99998 99999 31000000000\\n\",\n    \"100 100 10\\n3 5 1 1 1 1 1 1 1 9\\n\",\n    \"54275126675 128566125 50\\n1 1 3 1 1 3 7 1 9 1 11 3 13 7 3 1 1 27 1 1 21 11 1 3 1 13 9 7 1 3 1 1 33 1 7 9 37 1 39 1 1 21 1 11 27 1 1 3 7 1\\n\",\n    \"100000 49999 2\\n50000 1\\n\",\n    \"1000000000000 1000000000000 59\\n1 1 3 1 5 3 1 1 3 5 1 3 1 1 15 1 1 3 1 5 3 1 1 3 5 1 3 1 1 15 1 1 3 1 5 3 1 1 3 5 1 3 1 1 15 1 1 3 1 5 3 1 1 3 5 1 3 1 1\\n\",\n    \"1000000000000 1000000000000 6\\n8 21 2 1 12 1\\n\",\n    \"1000000000000 1000000000000 6\\n1 6 5 2 3 2\\n\",\n    \"1000000000000 1000000000000 100\\n2 9 2 1 6 1 2 3 2 1 18 1 2 3 2 1 6 1 2 9 2 1 6 1 2 3 2 1 18 1 74 3 2 1 6 1 2 9 2 1 6 1 2 3 2 1 18 1 2 3 2 1 6 1 2 9 2 1 6 1 2 3 2 1 18 1 2 111 2 1 6 1 2 9 2 1 6 1 2 3 2 1 18 1 2 3 2 1 6 1 2 9 2 1 6 1 2 3 2 1\\n\",\n    \"1000000000000 1000000000000 100\\n2 9 2 1 6 1 2 3 2 1 18 1 2 3 2 1 6 1 2 9 2 1 6 1 2 3 2 1 18 1 74 3 2 1 6 1 2 9 2 1 6 1 2 3 2 1 18 1 2 3 2 1 6 1 2 9 2 1 12 1 2 3 2 1 18 1 2 111 2 1 6 1 2 9 2 1 6 1 2 3 2 1 18 1 2 3 2 1 6 1 2 9 2 1 6 1 2 3 2 1\\n\",\n    \"1000000000000 1000000000000 100\\n2 9 2 1 6 1 2 3 2 1 18 1 2 3 2 1 6 1 2 9 2 1 6 1 2 3 2 1 18 1 74 3 2 1 6 1 2 9 2 1 6 1 2 3 2 1 18 1 2 3 2 1 6 1 2 9 2 1 6 1 2 3 2 1 18 1 2 111 2 1 6 1 2 9 2 1 6 1 2 3 2 1 9 1 2 3 2 1 6 1 2 9 2 1 6 1 2 3 2 1\\n\",\n    \"1000000000000 1000000000000 40\\n2 1 8 1 10 1 4 1 2 25 16 1 2 1 20 1 2 1 8 5 2 1 4 1 10 1 128 1 2 5 4 1 2 1 1000 1 2 1 4 5\\n\",\n    \"1000000000000 1000000000000 40\\n2 1 8 1 10 1 4 1 2 5 16 1 2 1 20 1 2 1 8 5 2 1 4 1 10 1 64 1 2 5 4 1 2 1 500 1 2 1 4 5\\n\",\n    \"1000000000000 1000000000000 2\\n1 1000000000000\\n\",\n    \"1000000000000 1000000000000 4\\n1 2 1 100000000000\\n\",\n    \"991234567890 927215128595 5\\n6 11 8 3 2000000014\\n\",\n    \"991234567890 182000001269 5\\n6 11 8 3 2000000014\\n\",\n    \"999999999999 999999999999 2\\n20145182300 20145182301\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}