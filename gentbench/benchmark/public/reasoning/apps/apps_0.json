{
    "problem": "You are an expert Python programmer, and here is your task: It was recycling day in Kekoland. To celebrate it Adil and Bera went to Central Perk where they can take bottles from the ground and put them into a recycling bin.\n\nWe can think Central Perk as coordinate plane. There are n bottles on the ground, the i-th bottle is located at position (x_{i}, y_{i}). Both Adil and Bera can carry only one bottle at once each. \n\nFor both Adil and Bera the process looks as follows:   Choose to stop or to continue to collect bottles.  If the choice was to continue then choose some bottle and walk towards it.  Pick this bottle and walk to the recycling bin.  Go to step 1. \n\nAdil and Bera may move independently. They are allowed to pick bottles simultaneously, all bottles may be picked by any of the two, it's allowed that one of them stays still while the other one continues to pick bottles.\n\nThey want to organize the process such that the total distance they walk (the sum of distance walked by Adil and distance walked by Bera) is minimum possible. Of course, at the end all bottles should lie in the recycling bin.\n\n\n-----Input-----\n\nFirst line of the input contains six integers a_{x}, a_{y}, b_{x}, b_{y}, t_{x} and t_{y} (0 \u2264 a_{x}, a_{y}, b_{x}, b_{y}, t_{x}, t_{y} \u2264 10^9)\u00a0\u2014 initial positions of Adil, Bera and recycling bin respectively.\n\nThe second line contains a single integer n (1 \u2264 n \u2264 100 000)\u00a0\u2014 the number of bottles on the ground.\n\nThen follow n lines, each of them contains two integers x_{i} and y_{i} (0 \u2264 x_{i}, y_{i} \u2264 10^9)\u00a0\u2014 position of the i-th bottle.\n\nIt's guaranteed that positions of Adil, Bera, recycling bin and all bottles are distinct.\n\n\n-----Output-----\n\nPrint one real number\u00a0\u2014 the minimum possible total distance Adil and Bera need to walk in order to put all bottles into recycling bin. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\nNamely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct if $\\frac{|a - b|}{\\operatorname{max}(1, b)} \\leq 10^{-6}$.\n\n\n-----Examples-----\nInput\n3 1 1 2 0 0\n3\n1 1\n2 1\n2 3\n\nOutput\n11.084259940083\n\nInput\n5 0 4 2 2 0\n5\n5 2\n3 0\n5 5\n3 5\n3 3\n\nOutput\n33.121375178000\n\n\n\n-----Note-----\n\nConsider the first sample.\n\nAdil will use the following path: $(3,1) \\rightarrow(2,1) \\rightarrow(0,0) \\rightarrow(1,1) \\rightarrow(0,0)$.\n\nBera will use the following path: $(1,2) \\rightarrow(2,3) \\rightarrow(0,0)$.\n\nAdil's path will be $1 + \\sqrt{5} + \\sqrt{2} + \\sqrt{2}$ units long, while Bera's path will be $\\sqrt{2} + \\sqrt{13}$ units long.",
    "solution": "[\"from math import *\\n\\nax, ay, bx, by, cx, cy = [int(t) for t in input().split()]\\nn = int(input())\\ndist = 0\\nmaxv = [[-inf, -inf], [-inf, -inf]]\\nindex = [[0,0], [0,0]]\\n\\ndef update(d, idx, p):\\n    nonlocal maxv, index\\n    if d > maxv[p][0]:\\n        maxv[p][1] = maxv[p][0]\\n        index[p][1] = index[p][0]\\n        maxv[p][0] = d\\n        index[p][0] = idx\\n    elif d > maxv[p][1]:\\n        maxv[p][1] = d\\n        index[p][1] = idx\\n\\nfor i in range(n):\\n    x, y = [int(t) for t in input().split()]\\n    bottle_recycle = sqrt((cx - x) ** 2 + (cy - y) ** 2)\\n    dist += bottle_recycle * 2\\n    dista = bottle_recycle - sqrt((ax - x) ** 2 + (ay - y) ** 2)\\n    distb = bottle_recycle - sqrt((bx - x) ** 2 + (by - y) ** 2)\\n    update(dista, i, 0)\\n    update(distb, i, 1)\\n\\nans = dist - maxv[0][0]\\nans = min(ans, dist - maxv[1][0])\\nif(index[0][0] != index[1][0]):\\n    ans = min(ans, dist - maxv[0][0] - maxv[1][0])\\nelif(n > 1):\\n    ans = min(ans, dist - maxv[0][1] - maxv[1][0], dist - maxv[0][0] - maxv[1][1])\\nprint(ans)\", \"from math import *\\n\\nax, ay, bx, by, cx, cy = map(lambda t: int(t), input().split())\\nn = int(input())\\ndist = 0\\nmaxv = [[-inf, -inf], [-inf, -inf]]\\nindex = [[0,0], [0,0]]\\n\\ndef update(d, idx, p):\\n    nonlocal maxv, index\\n    if d > maxv[p][0]:\\n        maxv[p][1] = maxv[p][0]\\n        index[p][1] = index[p][0]\\n        maxv[p][0] = d\\n        index[p][0] = idx\\n    elif d > maxv[p][1]:\\n        maxv[p][1] = d\\n        index[p][1] = idx\\n\\nfor i in range(n):\\n    x, y = map(lambda t: int(t), input().split())\\n    bottle_recycle = sqrt((cx - x) ** 2 + (cy - y) ** 2)\\n    dist += bottle_recycle * 2\\n    dista = bottle_recycle - sqrt((ax - x) ** 2 + (ay - y) ** 2)\\n    distb = bottle_recycle - sqrt((bx - x) ** 2 + (by - y) ** 2)\\n    update(dista, i, 0)\\n    update(distb, i, 1)\\n\\nans = dist - maxv[0][0]\\nans = min(ans, dist - maxv[1][0])\\nif(index[0][0] != index[1][0]):\\n    ans = min(ans, dist - maxv[0][0] - maxv[1][0])\\nelif(n > 1):\\n    ans = min(ans, dist - maxv[0][1] - maxv[1][0], dist - maxv[0][0] - maxv[1][1])\\nprint(ans)\", \"def main():\\n    from math import hypot\\n    from sys import stdin\\n    ax, ay, bx, by, tx, ty = list(map(float, input().split()))\\n    n, tot = int(input()), 0.\\n    m0 = m1 = m2 = m3 = -9e9\\n    j = k = 0\\n    for i, s in enumerate(stdin.read().splitlines()):\\n        x, y = list(map(float, s.split()))\\n        r = hypot(tx - x, ty - y)\\n        tot += r\\n        d = r - hypot(ax - x, ay - y)\\n        if m1 < d:\\n            if m0 < d:\\n                m0, m1, j = d, m0, i\\n            else:\\n                m1 = d\\n        d = r - hypot(bx - x, by - y)\\n        if m3 < d:\\n            if m2 < d:\\n                m2, m3, k = d, m2, i\\n            else:\\n                m3 = d\\n    print(tot * 2. - max((m0, m2) if min(m0, m2) < 0. else((m0 + m2) * (j != k), m0 + m3, m1 + m2, m0, m2)))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"def main():\\n    from math import hypot\\n    from sys import stdin\\n    ax, ay, bx, by, tx, ty = list(map(float, input().split()))\\n    s, tot = input(), 0.\\n    m0 = m1 = m2 = m3 = -9e9\\n    j = k = 0\\n    for i, s in enumerate(stdin.read().splitlines()):\\n        x, y = list(map(float, s.split()))\\n        r = hypot(tx - x, ty - y)\\n        tot += r\\n        d = r - hypot(ax - x, ay - y)\\n        if m1 < d:\\n            if m0 < d:\\n                m0, m1, j = d, m0, i\\n            else:\\n                m1 = d\\n        d = r - hypot(bx - x, by - y)\\n        if m3 < d:\\n            if m2 < d:\\n                m2, m3, k = d, m2, i\\n            else:\\n                m3 = d\\n    print(tot * 2. - max((m0, m2, m0 + m2) if j != k else (m0, m2, m0 + m3, m1 + m2)))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from math import hypot\\n\\nax, ay, bx, by, tx, ty = map(int, input().split())\\n\\nn = int(input())\\n\\nans = 0\\n\\np1, p2, beg, end = [0]*n, [0]*n, [0]*n, [0]*n\\n\\ndef pref(x):\\n    return beg[x] if x >= 0 else 0\\n\\ndef suff(x):\\n    return end[x] if x < n else 0\\n\\ndef ex(x):\\n    return max(pref(x-1), suff(x+1))\\n\\nfor i in range(n):\\n    x, y = map(int, input().split())\\n    d = hypot(x-tx, y-ty)\\n    d1 = hypot(x-ax, y-ay)\\n    d2 = hypot(x-bx, y-by)\\n    ans += d+d\\n    p1[i], p2[i] = d-d1, d-d2\\n\\nbeg[0] = p1[0]\\nfor i in range(1, n):\\n    beg[i] = max(beg[i-1], p1[i])\\n\\nend[n-1] = p1[n-1]\\nfor i in range(n-2, -1, -1):\\n    end[i] = max(end[i+1], p1[i])\\n\\nres = 1e220\\n\\nfor i in range(0, n):\\n    res = min(res, min(ans-p2[i]-ex(i), ans-max(p1[i], p2[i])))\\n\\nprint(res)\", \"from math import hypot\\n\\nax, ay, bx, by, tx, ty = map(int, input().split())\\n\\nn = int(input())\\n\\nans = 0\\n\\np1, p2, beg, end = [0]*n, [0]*n, [0]*n, [0]*n\\n\\ndef pref(x):\\n    return beg[x] if x >= 0 else 0\\n\\ndef suff(x):\\n    return end[x] if x < n else 0\\n\\ndef ex(x):\\n    return max(pref(x-1), suff(x+1))\\n\\nfor i in range(n):\\n    x, y = map(int, input().split())\\n    d = hypot(x-tx, y-ty)\\n    d1 = hypot(x-ax, y-ay)\\n    d2 = hypot(x-bx, y-by)\\n    ans += d+d\\n    p1[i], p2[i] = d-d1, d-d2\\n\\nbeg[0] = p1[0]\\nfor i in range(1, n):\\n    beg[i] = max(beg[i-1], p1[i])\\n\\nend[n-1] = p1[n-1]\\nfor i in range(n-2, -1, -1):\\n    end[i] = max(end[i+1], p1[i])\\n\\nres = 1e220\\n\\nfor i in range(0, n):\\n    res = min(res, min(ans-p2[i]-ex(i), ans-max(p1[i], p2[i])))\\n\\nprint(res)\", \"from math import sqrt\\n\\nax, ay, bx, by, tx, ty = map(int, input().split())\\n\\nn = int(input())\\n\\nans = 0\\n\\np1, p2, beg, end = [0]*n, [0]*n, [0]*n, [0]*n\\n\\ndef sqr(x):\\n    return x*x\\n\\ndef pref(x):\\n    return beg[x] if x >= 0 else 0\\n\\ndef suff(x):\\n    return end[x] if x < n else 0\\n\\ndef ex(x):\\n    return max(pref(x-1), suff(x+1))\\n\\nfor i in range(n):\\n    x, y = map(int, input().split())\\n    d = sqrt(sqr(x-tx) + sqr(y-ty))\\n    d1 = sqrt(sqr(x-ax) + sqr(y-ay))\\n    d2 = sqrt(sqr(x-bx) + sqr(y-by))\\n    ans += d+d\\n    p1[i], p2[i] = d-d1, d-d2\\n\\nbeg[0] = p1[0]\\nfor i in range(1, n):\\n    beg[i] = max(beg[i-1], p1[i])\\n\\nend[n-1] = p1[n-1]\\nfor i in range(n-2, -1, -1):\\n    end[i] = max(end[i+1], p1[i])\\n\\nres = 1e220\\n\\nfor i in range(0, n):\\n    res = min(res, min(ans-p2[i]-ex(i), ans-max(p1[i], p2[i])))\\n\\nprint(res)\", \"from math import sqrt\\n\\nax, ay, bx, by, tx, ty = map(int, input().split())\\n\\nn = int(input())\\n\\nans = 0\\n\\np1, p2, beg, end = [0]*n, [0]*n, [0]*n, [0]*n\\n\\ndef sqr(x):\\n    return x*x\\n\\ndef pref(x):\\n    return beg[x] if x >= 0 else 0\\n\\ndef suff(x):\\n    return end[x] if x < n else 0\\n\\ndef ex(x):\\n    return max(pref(x-1), suff(x+1))\\n\\nfor i in range(n):\\n    x, y = map(int, input().split())\\n    d = sqrt(sqr(x-tx) + sqr(y-ty))\\n    d1 = sqrt(sqr(x-ax) + sqr(y-ay))\\n    d2 = sqrt(sqr(x-bx) + sqr(y-by))\\n    ans += d+d\\n    p1[i], p2[i] = d-d1, d-d2\\n\\nbeg[0] = p1[0]\\nfor i in range(1, n):\\n    beg[i] = max(beg[i-1], p1[i])\\n\\nend[n-1] = p1[n-1]\\nfor i in range(n-2, -1, -1):\\n    end[i] = max(end[i+1], p1[i])\\n\\nres = 1e220\\n\\nfor i in range(0, n):\\n    res = min(res, min(ans-p2[i]-ex(i), ans-max(p1[i], p2[i])))\\n\\nprint(res)\", \"import math, sys\\n\\nax,ay,bx,by,tx,ty = list(map(float, input().split()))\\nn = int(input())\\n\\ndef dist(x1,y1,x2,y2):\\n    return math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))\\n\\ncost = 0\\nbottleCoord = []\\nfor i in range(0,n):\\n    x,y = list(map(float, input().split()))\\n    cost += 2*dist(tx,ty,x,y)\\n    bottleCoord.append((x,y))\\n\\nasCost = [(0,-1)]\\nbsCost = [(0,-1)]\\n\\nfor i in range(0,n):\\n    asCost.append((dist(ax,ay,bottleCoord[i][0],bottleCoord[i][1]) - dist(bottleCoord[i][0],bottleCoord[i][1],tx,ty),i))\\n    bsCost.append((dist(bx,by,bottleCoord[i][0],bottleCoord[i][1]) - dist(bottleCoord[i][0],bottleCoord[i][1],tx,ty),i))\\n\\nasCost.sort()\\nbsCost.sort()\\ncostTmpIndiv = sys.maxsize\\n\\nfor i in range(0,min(len(asCost),5)):\\n    for j in range(0, min(len(bsCost),5)):\\n        if (asCost[i][1] != bsCost[j][1]):\\n            costTmpIndiv = min(costTmpIndiv, asCost[i][0]+bsCost[j][0])\\n\\nprint(cost + costTmpIndiv)\\n\", \"from math import sqrt\\n\\nax, ay, bx, by, tx, ty = list(map(int, input().split()))\\nn = int(input())\\nd = 0\\nmina = (2*10**9,0,0)\\nmina2 = (2*10**9,0,0)\\nminb = (2*10**9,0,0)\\nminb2 = (2*10**9,0,0)\\nfor _ in range(n):\\n  x, y = list(map(int, input().split()))\\n  dt = sqrt((x-tx)**2+(y-ty)**2)\\n  d += 2*dt\\n  da = sqrt((ax-x)**2+(ay-y)**2)\\n  dat = (da-dt,x,y)\\n  if dat[0] < mina[0]:\\n    mina, mina2 = dat, mina\\n  elif dat[0] < mina2[0]:\\n    mina2 = dat\\n  db = sqrt((bx-x)**2+(by-y)**2)\\n  dbt = (db-dt,x,y)\\n  if dbt[0] < minb[0]:\\n    minb, minb2 = dbt, minb\\n  elif dbt[0] < minb2[0]:\\n    minb2 = dbt\\nif n >= 2 and mina[0] < 0 and minb[0] < 0:\\n  if mina[1] != minb[1] or mina[2] != minb[2]:\\n    d += mina[0] + minb[0]\\n  elif mina2[0] < 0 and minb2[0] < 0:\\n    d += min(mina[0]+minb2[0],mina2[0]+minb[0])\\n  elif mina2[0] < 0:\\n    d += min(mina[0],mina2[0]+minb[0])\\n  elif minb2[0] < 0:\\n    d += min(mina[0]+minb2[0],minb[0])\\n  else:\\n    d += min(mina[0],minb[0])\\nelse:\\n  d += min(mina[0],minb[0])\\nprint(d)\\n\", \"read = lambda : map(int, input().split())\\ndef dis(x1, y1, x2, y2):\\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\\n\\nax, ay, bx, by, tx, ty = read()\\nn = int(input())\\na, b = [], []\\nsum = 0\\nfor i in range(n):\\n    x, y = read()\\n    dist = dis(tx, ty, x, y)\\n    a.append((dis(ax, ay, x, y) - dist, i))\\n    b.append((dis(bx, by, x, y) - dist, i))\\n    sum += dist * 2\\na.sort()\\nb.sort()\\nif n > 1 and a[0][1] == b[0][1]:\\n    ans = min(a[0][0], b[0][0], a[0][0] + b[1][0], a[1][0] + b[0][0])\\nelse:\\n    ans = min(a[0][0], b[0][0])\\n    if (n > 1) :\\n        ans = min(a[0][0] + b[0][0], ans)\\nprint(ans + sum)\", \"ax,ay,bx,by,tx,ty=list(map(int,input().split()))  #\\n\\nod=[]  #\\nco=[] #\\nobjects=int(input())#\\nfor i in range(objects):#\\n    x,y=list(map(int,input().split()))#\\n    od.append(((tx-x)**2+(ty-y)**2)**0.5)#\\n    co.append([x,y])#\\n\\n\\nasaved=[0,0]#\\nasaved2=[0,0]#\\nma=-(10**25)\\n\\nfor i in range(objects):\\n    x=co[i][0]\\n    y=co[i][1]\\n    saved=od[i]-((ax-x)**2+(ay-y)**2)**0.5\\n    ma=max(ma,saved)\\n    if saved>asaved[0]:\\n        asaved2[0]=asaved[0]\\n        asaved2[1]=asaved[1]\\n        asaved[0]=saved\\n        asaved[1]=i\\n    elif saved>asaved2[0]:\\n        asaved2[0]=saved\\n        asaved2[1]=i\\n\\n\\nbsaved=[0,0]#\\nbsaved2=[0,0]#\\nmb=-(10**25)\\n\\nfor i in range(objects):\\n    x=co[i][0]\\n    y=co[i][1]\\n    saved=od[i]-((bx-x)**2+(by-y)**2)**0.5\\n    mb=max(mb,saved)\\n    if saved>bsaved[0]:\\n        bsaved2[1]=bsaved[1]\\n        bsaved2[0]=bsaved[0]\\n        bsaved[0]=saved\\n        bsaved[1]=i\\n    elif saved>bsaved2[0]:\\n        bsaved2[0]=saved\\n        bsaved2[1]=i\\n\\n\\ntot=2*sum(od)#\\nif mb<0 and ma<0:\\n    tot-=max(mb,ma)\\nelif bsaved[1]==asaved[1]:\\n    tot-=max(asaved[0]+bsaved2[0],asaved2[0]+bsaved[0])\\nelse:\\n    tot-=asaved[0]+bsaved[0]\\n\\nprint(tot)#\\n\", \"read = lambda : list(map(int, input().split()))\\n\\ndef dis(x1, y1, x2, y2):\\n\\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\\n\\n\\n\\nax, ay, bx, by, tx, ty = read()\\n\\nn = int(input())\\n\\na, b = [], []\\n\\nsum = 0\\n\\nfor i in range(n):\\n\\n    x, y = read()\\n\\n    dist = dis(tx, ty, x, y)\\n\\n    a.append((dis(ax, ay, x, y) - dist, i))\\n\\n    b.append((dis(bx, by, x, y) - dist, i))\\n\\n    sum += dist * 2\\n\\na.sort()\\n\\nb.sort()\\n\\nif n > 1 and a[0][1] == b[0][1]:\\n\\n    ans = min(a[0][0], b[0][0], a[0][0] + b[1][0], a[1][0] + b[0][0])\\n\\nelse:\\n\\n    ans = min(a[0][0], b[0][0])\\n\\n    if (n > 1) :\\n\\n        ans = min(a[0][0] + b[0][0], ans)\\n\\nprint(ans + sum)\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"import math\\n\\nax, ay, bx, by, tx, ty = [int(coord) for coord in input().split()]\\nn = int(input())\\nx ,y = [], []\\n\\nminDis = 0\\ndiff1 = []\\ndiff2 = []\\n\\nfor i in range(n):\\n        xi, yi = [int(coord) for coord in input().split()]\\n        x.append(xi)\\n        y.append(yi)\\n        disBin = math.sqrt((xi-tx)**2 + (yi-ty)**2)\\n        diff1.append(( math.sqrt((ax-xi)**2 + (ay-yi)**2) - disBin, i))\\n        diff2.append(( math.sqrt((bx-xi)**2 + (by-yi)**2) - disBin, i))\\n        minDis += 2 * disBin\\n\\ndiff1.sort()\\ndiff2.sort()\\n\\nans = min(minDis + diff1[0][0], minDis + diff2[0][0])\\n\\nif diff1[0][1] != diff2[0][1]:\\n        ans = min(ans, minDis + diff1[0][0] + diff2[0][0])\\n\\nelif n>1:\\n        ans = min(ans, minDis + diff1[0][0] + diff2[1][0])\\n        ans = min(ans, minDis + diff1[1][0] + diff2[0][0])\\n\\nprint(ans)\", \"import math\\nR = lambda: map(int, input().split())\\nax, ay, bx, by, tx, ty = R()\\nn = int(input())\\ndp = [[0] * (n + 1) for i in range(4)]\\nfor i in range(n):\\n    x, y = R()\\n    da, db, dt = ((x - ax) ** 2 + (y - ay) ** 2) ** 0.5, ((x - bx) ** 2 + (y - by) ** 2) ** 0.5, ((x - tx) ** 2 + (y - ty) ** 2) ** 0.5\\n    dp[0][i] = dp[0][i - 1] + dt * 2\\n    dp[1][i] = min(dp[0][i - 1] + db + dt, dp[1][i - 1] + dt * 2 if i else math.inf)\\n    dp[2][i] = min(dp[0][i - 1] + da + dt, dp[2][i - 1] + dt * 2 if i else math.inf)\\n    dp[3][i] = min(dp[1][i - 1] + da + dt, dp[2][i - 1] + db + dt, dp[3][i - 1] + dt * 2) if i else math.inf\\nprint(min(dp[3][n - 1], dp[2][n - 1], dp[1][n - 1]))\", \"# -*- coding:utf-8 -*-\\n\\n\\\"\\\"\\\"\\n\\ncreated by shuangquan.huang at 1/16/20\\n\\n\\\"\\\"\\\"\\n\\nimport collections\\nimport time\\nimport os\\nimport sys\\nimport bisect\\nimport heapq\\nfrom typing import List\\n\\nimport math\\n\\n\\ndef dist(posa, posb):\\n    return math.sqrt((posa[0] - posb[0]) ** 2 + (posa[1] - posb[1]) ** 2)\\n\\n\\ndef solve(posa, posb, posc, bottles, N):\\n    if N == 1:\\n        print(min(dist(posa, bottles[0]), dist(posb, bottles[0])) + dist(posc, bottles[0]))\\n        return\\n    \\n    bottledist = [dist(posc, b) for b in bottles]\\n    da = [(dist(posa, bottles[i]) - bottledist[i], i) for i in range(N)]\\n    db = [(dist(posb, bottles[i]) - bottledist[i], i) for i in range(N)]\\n    da.sort()\\n    db.sort()\\n    d = 2 * sum(bottledist)\\n    ans = min(d + da[0][0], d + db[0][0])\\n    if da[0][1] != db[0][1]:\\n        ans = min(ans, d + da[0][0] + db[0][0])\\n    else:\\n        e = min(da[0][0] + db[1][0], da[1][0] + db[0][0])\\n        ans = min(ans, d + e)\\n    \\n    print(ans)\\n    \\n    \\nax, ay, bx, by, cx, cy = list(map(int, input().split()))\\nN = int(input())\\nbottles = []\\nfor i in range(N):\\n    x, y = list(map(int, input().split()))\\n    bottles.append((x, y))\\n\\nsolve((ax, ay), (bx, by), (cx, cy), bottles, N)\\n\", \"# -*- coding:utf-8 -*-\\n\\n\\\"\\\"\\\"\\n\\ncreated by shuangquan.huang at 1/16/20\\n\\n\\\"\\\"\\\"\\n\\nimport collections\\nimport time\\nimport os\\nimport sys\\nimport bisect\\nimport heapq\\nfrom typing import List\\n\\nimport math\\n\\n\\ndef dist(posa, posb):\\n    return math.sqrt((posa[0] - posb[0]) ** 2 + (posa[1] - posb[1]) ** 2)\\n\\n\\ndef solve(posa, posb, posc, bottles, N):\\n    if N == 1:\\n        print(min(dist(posa, bottles[0]), dist(posb, bottles[0])) + dist(posc, bottles[0]))\\n        return\\n    \\n    bottledist = [dist(posc, b) for b in bottles]\\n    da = [(dist(posa, bottles[i]) - bottledist[i], i) for i in range(N)]\\n    db = [(dist(posb, bottles[i]) - bottledist[i], i) for i in range(N)]\\n    d = 2 * sum(bottledist)\\n    \\n    heapq.heapify(da)\\n    heapq.heapify(db)\\n    a0 = heapq.heappop(da)\\n    b0 = heapq.heappop(db)\\n    ans = min(d + a0[0], d + b0[0])\\n    if a0[1] != b0[1]:\\n        ans = min(ans, d + a0[0] + b0[0])\\n    else:\\n        a1 = heapq.heappop(da)\\n        b1 = heapq.heappop(db)\\n        e = min(a0[0] + b1[0], a1[0] + b0[0])\\n        ans = min(ans, d + e)\\n    \\n    print(ans)\\n    \\n    \\nax, ay, bx, by, cx, cy = list(map(int, input().split()))\\nN = int(input())\\nbottles = []\\nfor i in range(N):\\n    x, y = list(map(int, input().split()))\\n    bottles.append((x, y))\\n\\nsolve((ax, ay), (bx, by), (cx, cy), bottles, N)\\n\", \"ax,ay,bx,by,tx,ty=list(map(int,input().split()))\\nn=int(input())\\na,b=[],[]\\nres=0\\nfor i in range(n):\\n    x, y=list(map(int, input().split()))\\n    lt=((tx-x)*(tx-x)+(ty-y)*(ty-y))**0.5\\n    la=((ax-x)*(ax-x)+(ay-y)*(ay-y))**0.5\\n    lb=((bx-x)*(bx-x)+(by-y)*(by-y))**0.5\\n    a+=[(la-lt,i)]\\n    b+=[(lb-lt,i)]\\n    res+=lt\\na.sort();b.sort()\\nres*=2\\nif a[0][1]==b[0][1] and n>1:\\n    res+=min(a[0][0],b[0][0],a[0][0]+b[1][0],a[1][0]+b[0][0])\\nelse: \\n    if a[0][1]==b[0][1]:\\n        res+=min(a[0][0],b[0][0])\\n    else:\\n        res+=min(a[0][0],b[0][0],a[0][0]+b[0][0])\\nprint(res)\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"3 1 1 2 0 0\\n3\\n1 1\\n2 1\\n2 3\\n\",\n    \"5 0 4 2 2 0\\n5\\n5 2\\n3 0\\n5 5\\n3 5\\n3 3\\n\",\n    \"107 50 116 37 104 118\\n12\\n16 78\\n95 113\\n112 84\\n5 88\\n54 85\\n112 80\\n19 98\\n25 14\\n48 76\\n95 70\\n77 94\\n38 32\\n\",\n    \"446799 395535 281981 494983 755701 57488\\n20\\n770380 454998\\n147325 211816\\n818964 223521\\n408463 253399\\n49120 253709\\n478114 283776\\n909705 631953\\n303154 889956\\n126532 258846\\n597028 708070\\n147061 192478\\n39515 879057\\n911737 878857\\n26966 701951\\n616099 715301\\n998385 735514\\n277633 346417\\n642301 188888\\n617247 256225\\n668067 352814\\n\",\n    \"0 0 214409724 980408402 975413181 157577991\\n4\\n390610378 473484159\\n920351980 785918656\\n706277914 753279807\\n159291646 213569247\\n\",\n    \"214409724 980408402 0 0 975413181 157577991\\n4\\n390610378 473484159\\n920351980 785918656\\n706277914 753279807\\n159291646 213569247\\n\",\n    \"383677880 965754167 658001115 941943959 0 0\\n10\\n9412 5230\\n4896 7518\\n3635 6202\\n2365 1525\\n241 1398\\n7004 5166\\n1294 9162\\n3898 6706\\n6135 8199\\n4195 4410\\n\",\n    \"825153337 326797826 774256604 103765336 0 0\\n21\\n6537 9734\\n3998 8433\\n560 7638\\n1937 2557\\n3487 244\\n8299 4519\\n73 9952\\n2858 3719\\n9267 5675\\n9584 7636\\n9234 1049\\n7415 6018\\n7653 9345\\n7752 9628\\n7476 8917\\n7207 2352\\n2602 4612\\n1971 3307\\n5530 3694\\n2393 8573\\n7506 9810\\n\",\n    \"214409724 980408402 975413181 157577991 0 0\\n4\\n3721 6099\\n5225 4247\\n940 340\\n8612 7341\\n\",\n    \"235810013 344493922 0 0 975204641 211157253\\n18\\n977686151 621301932\\n408277582 166435161\\n595105725 194278844\\n967498841 705149530\\n551735395 659209387\\n492239556 317614998\\n741520864 843275770\\n585383143 903832112\\n272581169 285871890\\n339100580 134101148\\n920610054 824829107\\n657996186 852771589\\n948065129 573712142\\n615254670 698346010\\n365251531 883011553\\n304877602 625498272\\n418150850 280945187\\n731399551 643859052\\n\",\n    \"0 0 1 1 2 2\\n1\\n1 3\\n\",\n    \"10000 1000 151 121 10 10\\n2\\n1 1\\n2 2\\n\",\n    \"5 5 10 10 15 15\\n2\\n1 1\\n11 11\\n\",\n    \"1000000 1000000 1 1 0 0\\n1\\n2 2\\n\",\n    \"100 0 0 1 0 0\\n2\\n1 1\\n1 2\\n\",\n    \"0 0 1000000000 1000000000 1 1\\n2\\n0 1\\n1 0\\n\",\n    \"1000 1000 0 0 1 1\\n1\\n2 2\\n\",\n    \"1 0 1000000 0 0 0\\n2\\n1 1\\n2 2\\n\",\n    \"3 0 100 100 0 0\\n2\\n1 0\\n2 0\\n\",\n    \"0 100 0 101 0 0\\n1\\n0 99\\n\",\n    \"1000 1000 3 3 0 0\\n2\\n1 0\\n0 1\\n\",\n    \"0 5 0 6 0 7\\n1\\n0 100\\n\",\n    \"1 1 1000000 1000000 0 0\\n2\\n1 2\\n2 1\\n\",\n    \"1 0 10000000 1000000 0 0\\n2\\n1 1\\n2 2\\n\",\n    \"2 2 10 2 6 5\\n2\\n6 2\\n5 5\\n\",\n    \"100000001 100000001 100000000 100000000 1 1\\n1\\n1 0\\n\",\n    \"1000 1000 1001 1001 0 0\\n2\\n1 1\\n2 2\\n\",\n    \"1000000000 1000000000 999999999 999999999 1 1\\n4\\n1 2\\n1 3\\n2 2\\n2 3\\n\",\n    \"0 100 1 1 1 0\\n2\\n2 1\\n0 1\\n\",\n    \"0 100 0 1 0 0\\n5\\n0 2\\n0 3\\n0 4\\n0 5\\n0 6\\n\",\n    \"100 0 0 100 0 0\\n2\\n0 1\\n1 0\\n\",\n    \"0 0 1000000 1000000 0 1\\n2\\n1 1\\n2 2\\n\",\n    \"0 0 1000 1000 1 0\\n2\\n1 1\\n1 2\\n\",\n    \"1 0 100000 100000 0 0\\n1\\n2 0\\n\",\n    \"5 5 5 4 4 5\\n2\\n3 4\\n3 5\\n\",\n    \"10000 10000 9000 9000 0 0\\n3\\n1 1\\n2 2\\n3 3\\n\",\n    \"1 1 1000 1000 0 0\\n3\\n2 2\\n3 3\\n4 4\\n\",\n    \"7 0 8 0 0 0\\n2\\n1 0\\n1 1\\n\",\n    \"1 3 3 3 2 1\\n2\\n2 3\\n3 1\\n\",\n    \"1 2 3 4 5 6\\n1\\n1 1\\n\",\n    \"1000000000 1000000000 0 0 1 1\\n5\\n2 2\\n2 3\\n2 4\\n2 5\\n2 6\\n\",\n    \"2 1 1 2 0 0\\n1\\n1 1\\n\",\n    \"1 0 100000 0 0 0\\n2\\n1 1\\n2 2\\n\",\n    \"0 100 1 100 1 0\\n2\\n2 1\\n0 1\\n\",\n    \"0 0 2 0 1 5\\n2\\n1 0\\n1 20\\n\",\n    \"1000 1000 999 999 0 0\\n2\\n1 0\\n0 1\\n\",\n    \"5 0 1000 1000 2 0\\n2\\n4 0\\n6 7\\n\",\n    \"10000 0 1000000 0 0 0\\n2\\n1 1\\n2 2\\n\",\n    \"0 100 0 101 0 0\\n2\\n0 1\\n0 2\\n\",\n    \"0 0 10000 10000 1 0\\n2\\n2 0\\n3 0\\n\",\n    \"3 1 1 2 0 0\\n1\\n1 1\\n\",\n    \"1000 0 0 1000 0 0\\n2\\n1 0\\n0 1\\n\",\n    \"1 1 1000000 1000000 0 0\\n2\\n2 1\\n1 2\\n\",\n    \"1000 1000 2000 2000 1 1\\n3\\n2 2\\n1 2\\n3 3\\n\",\n    \"0 0 1000000000 1000000000 1 1\\n4\\n2 2\\n3 3\\n4 4\\n5 5\\n\",\n    \"10000000 1 2 1 1 1\\n3\\n1 3\\n1 4\\n1 5\\n\",\n    \"3 7 5 7 4 4\\n2\\n4 6\\n4 0\\n\",\n    \"0 0 3 0 1 5\\n2\\n1 0\\n1 20\\n\",\n    \"0 0 0 1 1000 3\\n2\\n1000 2\\n1000 1\\n\",\n    \"1000000000 0 0 1 0 0\\n2\\n0 2\\n0 3\\n\",\n    \"0 1000000000 1000000000 0 0 0\\n1\\n1 1\\n\",\n    \"1000 1000 1000 1001 0 0\\n2\\n0 1\\n1 1\\n\",\n    \"1002 0 1001 0 0 0\\n1\\n1000 0\\n\",\n    \"1002 0 1001 0 0 0\\n2\\n2 0\\n1 0\\n\",\n    \"3 0 0 100 0 0\\n2\\n1 0\\n2 0\\n\",\n    \"10 10 0 0 0 1\\n2\\n1 0\\n1 1\\n\",\n    \"1000 1000 1001 1001 0 0\\n2\\n0 1\\n1 1\\n\",\n    \"0 100 0 200 0 0\\n2\\n0 1\\n0 2\\n\",\n    \"100 100 0 0 1 1\\n1\\n2 2\\n\",\n    \"123123 154345 123123 123123 2 2\\n3\\n3 3\\n4 4\\n5 5\\n\",\n    \"0 1 0 2 0 0\\n1\\n1 0\\n\",\n    \"1 2 3 4 1000 1000\\n1\\n156 608\\n\",\n    \"0 0 10 0 5 0\\n3\\n4 1\\n5 1\\n6 1\\n\",\n    \"0 0 0 1 1000000000 999999999\\n1\\n1000000000 1000000000\\n\",\n    \"1231231 2342342 123124 123151 12315 12312\\n1\\n354345 234234\\n\",\n    \"0 0 1000000 0 1 1\\n2\\n0 1\\n3 0\\n\",\n    \"1000 1000 2000 2000 1 1\\n1\\n2 2\\n\",\n    \"10 20 10 0 10 10\\n2\\n10 11\\n10 9\\n\",\n    \"1000000000 1 1 1000000000 0 0\\n1\\n2 2\\n\",\n    \"0 0 1000 1000 1 0\\n2\\n2 0\\n3 0\\n\",\n    \"1000 0 100000000 100000000 0 0\\n2\\n999 0\\n1100 0\\n\",\n    \"2 2 1000000000 1000000000 0 0\\n3\\n1 1\\n5 5\\n100 100\\n\",\n    \"2 0 4 0 0 0\\n1\\n3 0\\n\",\n    \"2 2 1000 1000 0 0\\n2\\n1 1\\n1 2\\n\",\n    \"0 0 1000000000 1000000000 0 1\\n3\\n1 0\\n2 0\\n3 0\\n\",\n    \"1 10000 10000 1 0 0\\n2\\n1 100\\n100 1\\n\",\n    \"5 0 6 0 0 0\\n2\\n2 0\\n0 2\\n\",\n    \"2 4 1000000000 1000000000 0 0\\n4\\n2 3\\n2 1\\n3 2\\n1 2\\n\",\n    \"0 100 1 1 0 0\\n2\\n0 1\\n3 1\\n\",\n    \"0 0 10 0 8 2\\n1\\n6 0\\n\",\n    \"0 9 0 8 0 1\\n1\\n0 0\\n\",\n    \"100 0 0 100 0 0\\n2\\n40 0\\n0 40\\n\",\n    \"0 0 0 1 1000 3\\n2\\n1000 1\\n1000 2\\n\",\n    \"1 1 123123 123123 2 2\\n3\\n3 3\\n4 4\\n5 5\\n\",\n    \"999999999 999999999 1000000000 1000000000 1 1\\n1\\n1 0\\n\",\n    \"3 2 1 1 0 0\\n1\\n2 2\\n\",\n    \"0 0 1 1 100 100\\n2\\n101 101\\n102 102\\n\",\n    \"1 15 4 10 1 1\\n2\\n1 10\\n4 5\\n\",\n    \"100 0 0 100 0 0\\n2\\n60 0\\n0 40\\n\",\n    \"0 0 0 1000 1 0\\n4\\n0 1\\n0 2\\n0 3\\n0 4\\n\",\n    \"0 0 100 0 3 0\\n1\\n2 0\\n\",\n    \"0 0 100 0 98 2\\n1\\n98 0\\n\",\n    \"1 1 2 2 3 3\\n1\\n0 0\\n\",\n    \"2 2 1 1 0 0\\n1\\n1 2\\n\",\n    \"10000000 1 2 1 1 1\\n3\\n1 40\\n1 20\\n1 5\\n\",\n    \"1000 1000 1001 1000 0 0\\n3\\n1 1\\n1 2\\n1 3\\n\",\n    \"10000 10000 9999 9999 0 0\\n3\\n0 1\\n0 2\\n0 3\\n\"\n  ],\n  \"outputs\": [\n    \"11.084259940083\\n\",\n    \"33.121375178000\\n\",\n    \"1576.895607473206\\n\",\n    \"22423982.398765542000\\n\",\n    \"4854671149.842136400000\\n\",\n    \"4854671149.842136400000\\n\",\n    \"1039303750.884648200000\\n\",\n    \"781520533.726828810000\\n\",\n    \"988090959.937532070000\\n\",\n    \"20756961047.556908000000\\n\",\n    \"3.414213562373\\n\",\n    \"227.449066182313\\n\",\n    \"32.526911934581\\n\",\n    \"4.242640687119\\n\",\n    \"6.478708664619\\n\",\n    \"4.000000000000\\n\",\n    \"4.242640687119\\n\",\n    \"7.892922226992\\n\",\n    \"5.000000000000\\n\",\n    \"100.000000000000\\n\",\n    \"6.605551275464\\n\",\n    \"187.000000000000\\n\",\n    \"7.708203932499\\n\",\n    \"7.892922226992\\n\",\n    \"9.000000000000\\n\",\n    \"141421356.530202720000\\n\",\n    \"1417.041989497841\\n\",\n    \"1414213568.487842800000\\n\",\n    \"5.242640687119\\n\",\n    \"39.000000000000\\n\",\n    \"102.000000000000\\n\",\n    \"6.886349517373\\n\",\n    \"6.236067977500\\n\",\n    \"3.000000000000\\n\",\n    \"5.414213562373\\n\",\n    \"12736.407342732093\\n\",\n    \"24.041630560343\\n\",\n    \"9.496976092671\\n\",\n    \"5.000000000000\\n\",\n    \"7.403124237433\\n\",\n    \"33.294904485247\\n\",\n    \"2.414213562373\\n\",\n    \"7.892922226992\\n\",\n    \"103.242640687119\\n\",\n    \"36.000000000000\\n\",\n    \"1415.092419071783\\n\",\n    \"19.124515496597\\n\",\n    \"10003.657054289499\\n\",\n    \"102.000000000000\\n\",\n    \"7.000000000000\\n\",\n    \"2.414213562373\\n\",\n    \"1002.000000000000\\n\",\n    \"7.708203932499\\n\",\n    \"1417.627775935468\\n\",\n    \"29.698484809835\\n\",\n    \"18.123105625618\\n\",\n    \"11.414213562373\\n\",\n    \"36.000000000000\\n\",\n    \"1004.000000000000\\n\",\n    \"9.000000000000\\n\",\n    \"1000000000.414213500000\\n\",\n    \"1416.213562373095\\n\",\n    \"1001.000000000000\\n\",\n    \"1003.000000000000\\n\",\n    \"5.000000000000\\n\",\n    \"4.414213562373\\n\",\n    \"1416.213562373095\\n\",\n    \"102.000000000000\\n\",\n    \"4.242640687119\\n\",\n    \"174127.873294312070\\n\",\n    \"2.414213562373\\n\",\n    \"1553.668251715911\\n\",\n    \"10.365746312737\\n\",\n    \"1414213562.665988200000\\n\",\n    \"664238.053973730540\\n\",\n    \"6.472135955000\\n\",\n    \"1412.799348810722\\n\",\n    \"12.000000000000\\n\",\n    \"1000000000.828427200000\\n\",\n    \"7.000000000000\\n\",\n    \"3198.000000000000\\n\",\n    \"296.984848098350\\n\",\n    \"4.000000000000\\n\",\n    \"6.064495102246\\n\",\n    \"13.210904837709\\n\",\n    \"10200.014999625020\\n\",\n    \"9.000000000000\\n\",\n    \"20.760925736391\\n\",\n    \"7.162277660168\\n\",\n    \"6.828427124746\\n\",\n    \"9.000000000000\\n\",\n    \"180.000000000000\\n\",\n    \"1004.000000000000\\n\",\n    \"18.384776310850\\n\",\n    \"1414213561.251774800000\\n\",\n    \"3.828427124746\\n\",\n    \"148.492424049175\\n\",\n    \"22.000000000000\\n\",\n    \"180.000000000000\\n\",\n    \"21.457116088945\\n\",\n    \"3.000000000000\\n\",\n    \"4.000000000000\\n\",\n    \"5.656854249492\\n\",\n    \"3.236067977500\\n\",\n    \"124.012818406262\\n\",\n    \"1421.848684511914\\n\",\n    \"14147.600248963827\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}