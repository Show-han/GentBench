{
    "problem": "You are an expert Python programmer, and here is your task: SIHanatsuka - EMber SIHanatsuka - ATONEMENT\n\nBack in time, the seven-year-old Nora used to play lots of games with her creation ROBO_Head-02, both to have fun and enhance his abilities.\n\nOne day, Nora's adoptive father, Phoenix Wyle, brought Nora $n$ boxes of toys. Before unpacking, Nora decided to make a fun game for ROBO.\n\nShe labelled all $n$ boxes with $n$ distinct integers $a_1, a_2, \\ldots, a_n$ and asked ROBO to do the following action several (possibly zero) times:\n\n  Pick three distinct indices $i$, $j$ and $k$, such that $a_i \\mid a_j$ and $a_i \\mid a_k$. In other words, $a_i$ divides both $a_j$ and $a_k$, that is $a_j \\bmod a_i = 0$, $a_k \\bmod a_i = 0$.  After choosing, Nora will give the $k$-th box to ROBO, and he will place it on top of the box pile at his side. Initially, the pile is empty.  After doing so, the box $k$ becomes unavailable for any further actions. \n\nBeing amused after nine different tries of the game, Nora asked ROBO to calculate the number of possible different piles having the largest amount of boxes in them. Two piles are considered different if there exists a position where those two piles have different boxes.\n\nSince ROBO was still in his infant stages, and Nora was still too young to concentrate for a long time, both fell asleep before finding the final answer. Can you help them?\n\nAs the number of such piles can be very large, you should print the answer modulo $10^9 + 7$.\n\n\n-----Input-----\n\nThe first line contains an integer $n$ ($3 \\le n \\le 60$), denoting the number of boxes.\n\nThe second line contains $n$ distinct integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 60$), where $a_i$ is the label of the $i$-th box.\n\n\n-----Output-----\n\nPrint the number of distinct piles having the maximum number of boxes that ROBO_Head can have, modulo $10^9 + 7$.\n\n\n-----Examples-----\nInput\n3\n2 6 8\n\nOutput\n2\n\nInput\n5\n2 3 4 9 12\n\nOutput\n4\n\nInput\n4\n5 7 2 9\n\nOutput\n1\n\n\n\n-----Note-----\n\nLet's illustrate the box pile as a sequence $b$, with the pile's bottommost box being at the leftmost position.\n\nIn the first example, there are $2$ distinct piles possible:   $b = [6]$ ($[2, \\mathbf{6}, 8] \\xrightarrow{(1, 3, 2)} [2, 8]$)  $b = [8]$ ($[2, 6, \\mathbf{8}] \\xrightarrow{(1, 2, 3)} [2, 6]$) \n\nIn the second example, there are $4$ distinct piles possible:   $b = [9, 12]$ ($[2, 3, 4, \\mathbf{9}, 12] \\xrightarrow{(2, 5, 4)} [2, 3, 4, \\mathbf{12}] \\xrightarrow{(1, 3, 4)} [2, 3, 4]$)  $b = [4, 12]$ ($[2, 3, \\mathbf{4}, 9, 12] \\xrightarrow{(1, 5, 3)} [2, 3, 9, \\mathbf{12}] \\xrightarrow{(2, 3, 4)} [2, 3, 9]$)  $b = [4, 9]$ ($[2, 3, \\mathbf{4}, 9, 12] \\xrightarrow{(1, 5, 3)} [2, 3, \\mathbf{9}, 12] \\xrightarrow{(2, 4, 3)} [2, 3, 12]$)  $b = [9, 4]$ ($[2, 3, 4, \\mathbf{9}, 12] \\xrightarrow{(2, 5, 4)} [2, 3, \\mathbf{4}, 12] \\xrightarrow{(1, 4, 3)} [2, 3, 12]$) \n\nIn the third sequence, ROBO can do nothing at all. Therefore, there is only $1$ valid pile, and that pile is empty.",
    "solution": "[\"MOD = 1000000007\\n\\n\\ndef isSubset(a, b):\\n\\treturn (a & b) == a\\n\\n\\ndef isIntersect(a, b):\\n\\treturn (a & b) != 0\\n\\n\\n# Solve for each weakly connected component (WCC)\\ndef cntOrder(s, t):\\n\\tp = len(s)\\n\\tm = len(t)\\n\\n\\tinMask = [0 for i in range(m)]\\n\\n\\tfor x in range(p):\\n\\t\\tfor i in range(m):\\n\\t\\t\\tif t[i] % s[x] == 0:\\n\\t\\t\\t\\tinMask[i] |= 1 << x\\n\\n\\tcnt = [0 for mask in range(1<<p)]\\n\\tfor mask in range(1<<p):\\n\\t\\tfor i in range(m):\\n\\t\\t\\tif isSubset(inMask[i], mask):\\n\\t\\t\\t\\tcnt[mask] += 1\\n\\n\\tdp = [[0 for mask in range(1<<p)] for k in range(m+1)]\\n\\tfor i in range(m):\\n\\t\\tdp[1][inMask[i]] += 1\\n\\tfor k in range(m):\\n\\t\\tfor mask in range(1<<p):\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tif not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):\\n\\t\\t\\t\\t\\tdp[k+1][mask | inMask[i]] = (dp[k+1][mask | inMask[i]] + dp[k][mask]) % MOD\\n\\t\\t\\tdp[k+1][mask] = (dp[k+1][mask] + dp[k][mask] * (cnt[mask] - k)) % MOD\\n\\n\\treturn dp[m][(1<<p)-1]\\n\\n\\ndef dfs(u):\\n\\tnonlocal a, graph, degIn, visited, s, t\\n\\n\\tvisited[u] = True\\n\\tif degIn[u] == 0:\\n\\t\\ts.append(a[u])\\n\\telse:\\n\\t\\tt.append(a[u])\\n\\n\\tfor v in graph[u]:\\n\\t\\tif not visited[v]:\\n\\t\\t\\tdfs(v)\\n\\n\\ndef main():\\n\\tnonlocal a, graph, degIn, visited, s, t\\n\\n\\t# Reading input\\n\\tn = int(input())\\n\\ta = list(map(int, input().split()))\\n\\n\\t# Pre-calculate C(n, k)\\n\\tc = [[0 for j in range(n)] for i in range(n)]\\n\\tfor i in range(n):\\n\\t\\tc[i][0] = 1\\n\\t\\tfor j in range(1, i+1):\\n\\t\\t\\tc[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD\\t\\n\\n\\t# Building divisibility graph\\n\\tdegIn = [0 for u in range(n)]\\n\\tgraph = [[] for u in range(n)]\\n\\tfor u in range(n):\\n\\t\\tfor v in range(n):\\n\\t\\t\\tif u != v and a[v] % a[u] == 0:\\n\\t\\t\\t\\tgraph[u].append(v)\\n\\t\\t\\t\\tgraph[v].append(u)\\n\\t\\t\\t\\tdegIn[v] += 1\\n\\n\\t# Solve for each WCC of divisibility graph and combine result\\n\\tans = 1\\n\\tcurLen = 0\\n\\tvisited = [False for u in range(n)]\\n\\tfor u in range(n):\\n\\t\\tif not visited[u]:\\n\\t\\t\\ts = []\\n\\t\\t\\tt = []\\n\\t\\t\\tdfs(u)\\n\\n\\t\\t\\tif len(t) > 0:\\n\\t\\t\\t\\tsz = len(t) - 1\\n\\t\\t\\t\\tcnt = cntOrder(s, t)\\n\\n\\t\\t\\t\\t# Number of orders for current WCC\\n\\t\\t\\t\\tans = (ans * cnt) % MOD\\n\\t\\t\\t\\t# Number of ways to insert <sz> number to array of <curLen> elements\\n\\t\\t\\t\\tans = (ans * c[curLen + sz][sz]) % MOD\\n\\t\\t\\t\\tcurLen += sz\\t\\t\\n\\n\\tprint(ans)\\n\\ndef __starting_point():\\n\\tmain()\\n__starting_point()\", \"MOD = 1000000007\\ndef isSubset(a, b):\\n    return (a & b) == a\\ndef isIntersect(a, b):\\n    return (a & b) != 0\\ndef cntOrder(s, t):\\n    p = len(s)\\n    m = len(t)\\n    inMask = [0 for i in range(m)]\\n    for x in range(p):\\n        for i in range(m):\\n            if t[i] % s[x] == 0:\\n                inMask[i] |= 1 << x\\n    cnt = [0 for mask in range(1 << p)]\\n    for mask in range(1 << p):\\n        for i in range(m):\\n            if isSubset(inMask[i], mask):\\n                cnt[mask] += 1\\n    dp = [[0 for mask in range(1 << p)] for k in range(m + 1)]\\n    for i in range(m):\\n        dp[1][inMask[i]] += 1\\n    for k in range(m):\\n        for mask in range(1 << p):\\n            for i in range(m):\\n                if not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):\\n                    dp[k + 1][mask | inMask[i]] = (dp[k + 1][mask | inMask[i]] + dp[k][mask]) % MOD\\n            dp[k + 1][mask] = (dp[k + 1][mask] + dp[k][mask] * (cnt[mask] - k)) % MOD\\n    return dp[m][(1 << p) - 1]\\ndef dfs(u):\\n    nonlocal a, graph, degIn, visited, s, t\\n\\n    visited[u] = True\\n    if degIn[u] == 0:\\n        s.append(a[u])\\n    else:\\n        t.append(a[u])\\n\\n    for v in graph[u]:\\n        if not visited[v]:\\n            dfs(v)\\ndef main():\\n    nonlocal a, graph, degIn, visited, s, t\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    c = [[0 for j in range(n)] for i in range(n)]\\n    for i in range(n):\\n        c[i][0] = 1\\n        for j in range(1, i + 1):\\n            c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD\\n    degIn = [0 for u in range(n)]\\n    graph = [[] for u in range(n)]\\n    for u in range(n):\\n        for v in range(n):\\n            if u != v and a[v] % a[u] == 0:\\n                graph[u].append(v)\\n                graph[v].append(u)\\n                degIn[v] += 1\\n    ans = 1\\n    curLen = 0\\n    visited = [False for u in range(n)]\\n    for u in range(n):\\n        if not visited[u]:\\n            s = []\\n            t = []\\n            dfs(u)\\n            if len(t) > 0:\\n                sz = len(t) - 1\\n                cnt = cntOrder(s, t)\\n                ans = (ans * cnt) % MOD\\n                ans = (ans * c[curLen + sz][sz]) % MOD\\n                curLen += sz\\n    print(ans)\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\"]",
    "test": "{\n  \"inputs\": [\n    \"3\\n2 6 8\\n\",\n    \"5\\n2 3 4 9 12\\n\",\n    \"4\\n5 7 2 9\\n\",\n    \"7\\n7 10 9 4 8 5 6\\n\",\n    \"10\\n3 17 8 5 7 9 2 11 13 12\\n\",\n    \"20\\n13 7 23 19 2 28 5 29 20 6 9 8 30 26 24 21 25 15 27 17\\n\",\n    \"20\\n19 13 7 22 21 31 26 28 20 4 11 10 9 39 25 3 16 27 33 29\\n\",\n    \"20\\n10 50 39 6 47 35 37 26 12 15 11 9 46 45 7 16 21 31 18 23\\n\",\n    \"20\\n23 33 52 48 40 30 47 55 49 53 2 10 14 9 18 11 32 59 60 44\\n\",\n    \"30\\n29 26 15 14 9 16 28 7 39 8 30 17 6 22 27 35 32 11 2 34 38 13 33 36 40 12 20 25 21 31\\n\",\n    \"30\\n20 30 11 12 14 17 3 22 45 24 2 26 9 48 49 29 44 39 8 42 4 50 6 13 27 23 15 10 40 31\\n\",\n    \"30\\n17 53 19 25 13 37 3 18 23 10 46 4 59 57 56 35 21 30 49 51 9 12 26 29 5 7 11 20 36 15\\n\",\n    \"40\\n28 29 12 25 14 44 6 17 37 33 10 45 23 27 18 39 38 43 22 16 20 40 32 13 30 5 8 35 19 7 42 9 41 15 36 24 11 4 34 3\\n\",\n    \"40\\n51 19 2 24 8 14 53 49 43 36 26 20 52 10 29 41 37 46 50 57 33 55 59 25 44 27 34 32 3 45 28 39 7 58 35 12 4 42 9 11\\n\",\n    \"50\\n59 34 3 31 55 41 39 58 49 26 35 22 46 10 60 17 14 44 27 48 20 16 13 6 23 24 11 52 54 57 56 38 42 25 19 15 4 18 2 29 53 47 5 40 30 21 12 32 7 8\\n\",\n    \"59\\n43 38 39 8 13 54 3 51 28 11 46 41 14 20 36 19 32 15 34 55 47 24 45 40 17 29 6 57 59 52 21 4 49 30 33 53 58 10 48 35 7 60 27 26 23 42 18 12 25 31 44 5 16 50 22 9 56 2 37\\n\",\n    \"60\\n51 18 41 48 9 10 7 2 34 23 31 55 28 29 47 42 14 30 60 43 16 21 1 33 6 36 58 35 50 19 40 27 26 25 20 38 8 53 22 13 45 4 24 49 56 39 15 3 57 17 59 11 52 5 44 54 37 46 32 12\\n\",\n    \"42\\n2 29 27 25 23 21 19 17 15 13 11 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60\\n\",\n    \"10\\n14 5 13 7 11 10 8 3 6 2\\n\",\n    \"15\\n9 3 11 16 5 10 12 8 7 13 4 20 17 2 14\\n\",\n    \"15\\n9 12 10 8 17 3 18 5 22 15 19 21 14 25 23\\n\",\n    \"15\\n14 9 3 30 13 26 18 28 4 19 15 8 10 6 5\\n\",\n    \"20\\n18 13 19 4 5 7 9 2 14 11 21 15 16 10 8 3 12 6 20 17\\n\",\n    \"20\\n4 7 14 16 12 18 3 25 23 8 20 24 21 6 19 9 10 2 22 17\\n\",\n    \"20\\n24 32 15 17 3 22 6 2 16 34 12 8 18 11 29 20 21 26 33 14\\n\",\n    \"20\\n20 7 26 4 2 16 40 28 23 41 13 44 6 39 8 31 18 24 36 21\\n\",\n    \"20\\n20 52 2 43 44 14 30 45 21 35 33 15 4 32 12 42 25 54 41 9\\n\",\n    \"25\\n6 17 9 20 28 10 13 11 29 15 22 16 2 7 8 27 5 14 3 18 26 23 21 4 19\\n\",\n    \"25\\n33 7 9 2 13 32 15 3 31 16 26 17 28 34 21 19 24 12 29 30 14 6 8 22 20\\n\",\n    \"25\\n14 29 20 35 26 28 15 39 2 24 38 18 30 12 4 7 9 21 17 11 22 13 27 36 34\\n\",\n    \"25\\n8 23 17 24 34 43 2 20 3 33 18 29 38 28 41 22 39 40 26 32 31 45 9 11 4\\n\",\n    \"25\\n20 32 11 44 48 42 46 21 40 30 2 18 39 43 12 45 9 50 3 35 28 31 5 34 10\\n\",\n    \"25\\n27 41 24 32 37 6 53 30 23 51 19 2 49 43 18 42 20 13 45 33 34 26 52 3 14\\n\",\n    \"25\\n27 50 38 6 29 33 18 26 34 60 37 39 11 47 4 31 40 5 25 43 17 9 45 7 14\\n\",\n    \"30\\n15 32 22 11 34 2 6 8 18 24 30 21 20 35 28 19 16 17 27 25 12 26 14 7 3 33 29 23 13 4\\n\",\n    \"30\\n20 26 16 44 37 21 45 4 23 38 28 17 9 22 15 40 2 10 29 39 3 24 41 30 43 12 42 14 31 34\\n\",\n    \"30\\n49 45 5 37 4 21 32 9 54 41 43 11 46 15 51 42 19 23 30 52 55 38 7 24 10 20 22 35 26 48\\n\",\n    \"35\\n32 19 39 35 16 37 8 33 13 12 29 20 21 7 22 34 9 4 25 31 5 15 14 11 18 10 40 2 6 38 24 23 17 26 28\\n\",\n    \"35\\n38 35 3 23 11 9 27 42 4 16 43 44 19 37 29 17 45 7 33 28 39 15 14 34 10 18 41 22 40 2 36 20 25 30 12\\n\",\n    \"35\\n50 18 10 14 43 24 16 19 36 42 45 11 15 44 29 41 35 21 13 22 47 4 20 26 48 8 3 25 39 6 17 33 12 32 34\\n\",\n    \"35\\n27 10 46 29 40 19 54 47 18 23 43 7 5 25 15 41 11 14 22 52 2 33 30 48 51 37 39 31 32 3 38 35 55 4 26\\n\",\n    \"35\\n18 38 59 58 49 28 5 54 22 3 20 24 57 41 53 26 36 46 33 25 48 31 13 10 35 11 34 43 56 60 2 39 42 50 32\\n\",\n    \"40\\n22 18 45 10 14 23 9 46 21 20 17 47 5 2 34 3 32 37 35 16 4 29 30 42 36 27 33 12 11 8 44 6 31 48 26 13 28 25 40 7\\n\",\n    \"40\\n3 30 22 42 33 21 50 12 41 13 15 7 46 34 9 27 52 54 47 6 55 17 4 2 53 20 28 44 16 48 31 26 49 51 14 23 43 40 19 5\\n\",\n    \"45\\n41 50 11 34 39 40 9 22 48 6 31 16 13 8 20 42 27 45 15 43 32 38 28 10 46 17 21 33 4 18 35 14 37 23 29 2 49 19 12 44 36 24 30 26 3\\n\",\n    \"45\\n23 9 14 10 20 36 46 24 19 39 8 18 49 26 32 38 47 48 13 28 51 12 21 55 5 50 4 41 3 40 7 2 27 44 16 25 37 22 6 45 34 43 11 17 29\\n\",\n    \"45\\n9 50 26 14 31 3 37 27 58 28 57 20 23 60 6 13 22 19 48 21 54 56 30 34 16 53 44 24 43 46 45 32 59 5 33 41 11 42 8 12 25 29 47 49 35\\n\",\n    \"50\\n30 4 54 10 32 18 49 2 36 3 25 29 51 43 7 33 50 44 20 8 53 17 35 48 15 27 42 22 37 11 39 6 31 52 14 5 12 9 13 21 23 26 28 16 19 47 34 45 41 40\\n\",\n    \"55\\n58 31 18 12 17 2 19 54 44 7 21 5 49 11 9 15 43 6 28 53 34 48 23 25 33 41 59 32 38 8 46 20 52 3 22 55 10 29 36 16 40 50 56 35 4 57 30 47 42 51 24 60 39 26 14\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n\",\n    \"4\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"4\\n\",\n    \"1018080\\n\",\n    \"95160\\n\",\n    \"24\\n\",\n    \"167650560\\n\",\n    \"112745935\\n\",\n    \"844327723\\n\",\n    \"543177853\\n\",\n    \"871928441\\n\",\n    \"653596620\\n\",\n    \"780006450\\n\",\n    \"137822246\\n\",\n    \"133605669\\n\",\n    \"948373045\\n\",\n    \"24\\n\",\n    \"20880\\n\",\n    \"1968\\n\",\n    \"6336\\n\",\n    \"326747520\\n\",\n    \"695148772\\n\",\n    \"154637138\\n\",\n    \"273574246\\n\",\n    \"27336960\\n\",\n    \"893205071\\n\",\n    \"677307635\\n\",\n    \"769765990\\n\",\n    \"328260654\\n\",\n    \"914197149\\n\",\n    \"991737812\\n\",\n    \"2556\\n\",\n    \"399378036\\n\",\n    \"631950827\\n\",\n    \"225552404\\n\",\n    \"684687247\\n\",\n    \"978954869\\n\",\n    \"525144617\\n\",\n    \"660048379\\n\",\n    \"641829204\\n\",\n    \"628716855\\n\",\n    \"114991468\\n\",\n    \"461982591\\n\",\n    \"221629876\\n\",\n    \"979906107\\n\",\n    \"601846828\\n\",\n    \"122974992\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}