{
    "problem": "You are an expert Python programmer, and here is your task: Sereja has two sequences a and b and number p. Sequence a consists of n integers a_1, a_2, ..., a_{n}. Similarly, sequence b consists of m integers b_1, b_2, ..., b_{m}. As usual, Sereja studies the sequences he has. Today he wants to find the number of positions q (q + (m - 1)\u00b7p \u2264 n;\u00a0q \u2265 1), such that sequence b can be obtained from sequence a_{q}, a_{q} + p, a_{q} + 2p, ..., a_{q} + (m - 1)p by rearranging elements.\n\nSereja needs to rush to the gym, so he asked to find all the described positions of q.\n\n\n-----Input-----\n\nThe first line contains three integers n, m and p (1 \u2264 n, m \u2264 2\u00b710^5, 1 \u2264 p \u2264 2\u00b710^5). The next line contains n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9). The next line contains m integers b_1, b_2, ..., b_{m} (1 \u2264 b_{i} \u2264 10^9).\n\n\n-----Output-----\n\nIn the first line print the number of valid qs. In the second line, print the valid values in the increasing order.\n\n\n-----Examples-----\nInput\n5 3 1\n1 2 3 2 1\n1 2 3\n\nOutput\n2\n1 3\n\nInput\n6 3 2\n1 3 2 2 3 1\n1 2 3\n\nOutput\n2\n1 2",
    "solution": "[\"from collections import defaultdict\\n\\nn, m, p = map(int, input().split())\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\n\\nu = defaultdict(int)\\nfor i in b: u[i] += 1\\n\\nans = []\\nfor q in range(p):\\n    c = a[q: n: p]\\n    if len(c) < m: break\\n\\n    v = defaultdict(int)\\n    for i in c[: m]: v[i] += 1\\n\\n    d = q + 1\\n    if u == v: ans.append(d)\\n\\n    for j, k in zip(c[: len(c) - m], c[m: ]):\\n        v[j] -= 1\\n        if v[j] == 0: v.pop(j)\\n        v[k] += 1\\n\\n        d += p\\n        if u == v: ans.append(d)\\n\\nans.sort()\\nprint(len(ans))\\nprint(' '.join(map(str, ans)))\", \"from collections import Counter\\n\\nn, m, p = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\n\\n\\ndef try_from(start, a, b):\\n    result = []\\n    seq = a[start::p]\\n    i = 0\\n    if len(seq) < len(b):\\n        return []\\n\\n    counts_a = Counter(seq[:len(b)])\\n    counts_b = Counter(b)\\n    if counts_a == counts_b:\\n        result.append(start)\\n\\n    for i in range(1, len(seq) - len(b) + 1):\\n        counts_a[seq[i-1]] -= 1\\n        counts_a[seq[i+len(b) - 1]] += 1\\n        if not counts_a[seq[i-1]]:\\n            del counts_a[seq[i-1]]\\n\\n        ok = counts_a == counts_b\\n        #ok = sorted(seq[i:i+len(b)]) == sorted(b)\\n\\n        if ok:\\n            result.append(start + p * i)\\n\\n    return [x + 1 for x in result]\\n\\n\\nresult = []\\nfor start in range(p):\\n    result += try_from(start, a, b)\\n\\nprint(len(result))\\nprint(' '.join(map(str, sorted(result))))\\n\\n\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"5 3 1\\n1 2 3 2 1\\n1 2 3\\n\",\n    \"6 3 2\\n1 3 2 2 3 1\\n1 2 3\\n\",\n    \"68 16 3\\n5 3 4 3 3 3 2 2 2 3 2 4 2 2 2 2 4 3 5 1 1 2 2 2 3 1 5 1 2 2 1 5 1 5 3 2 3 5 2 1 1 4 2 3 4 3 4 3 3 1 3 4 1 5 2 5 3 4 4 1 4 5 5 1 1 2 2 2\\n5 4 4 3 5 1 1 2 3 2 2 1 3 3 2 2\\n\",\n    \"44 11 4\\n4 3 3 3 4 3 4 5 1 3 4 2 4 4 2 2 1 5 3 1 5 2 3 2 4 4 5 3 2 2 2 4 2 2 2 5 4 2 3 5 4 3 1 1\\n4 4 1 4 4 1 2 4 2 5 4\\n\",\n    \"54 6 4\\n5 4 1 2 2 2 1 3 3 1 5 5 2 2 2 5 4 4 1 3 4 3 4 2 1 4 2 2 4 3 3 2 5 5 3 5 2 2 1 4 2 3 5 3 5 5 5 5 1 2 5 2 4 5\\n2 3 5 5 3 2\\n\",\n    \"75 54 1\\n1 1 1 5 5 4 2 1 1 1 5 1 5 1 2 1 5 3 1 2 1 3 2 3 4 1 3 5 1 1 3 5 4 1 3 4 3 3 1 2 3 3 1 4 1 4 1 4 3 2 4 3 3 1 2 4 4 4 1 3 4 1 3 1 5 4 4 1 2 3 5 1 4 4 4\\n1 3 3 4 3 4 1 4 4 3 1 3 1 4 3 3 5 3 1 4 5 4 3 2 2 4 3 1 4 1 2 3 3 3 2 5 1 3 1 4 5 1 1 1 4 2 1 2 3 1 1 1 5 1\\n\",\n    \"31 28 1\\n1 4 1 2 5 1 1 4 2 2 5 2 4 5 5 2 4 1 5 3 5 4 1 2 4 3 1 2 5 2 1\\n2 4 1 2 1 4 4 5 5 4 4 5 3 2 5 1 4 2 2 1 1 2 5 2 5 1 5 3\\n\",\n    \"59 2 3\\n2 4 5 3 2 4 4 5 5 5 4 3 4 2 5 4 5 4 5 2 4 1 2 5 3 1 4 4 5 3 4 3 1 2 5 4 2 5 4 1 5 3 4 4 1 5 5 3 1 1 1 1 5 3 4 3 5 1 1\\n5 4\\n\",\n    \"74 33 1\\n4 5 5 2 1 2 2 2 2 2 3 2 3 4 2 2 1 4 4 4 5 4 1 2 4 5 4 2 4 2 5 1 2 1 5 3 5 4 1 4 1 1 2 4 4 5 1 4 2 4 2 3 3 2 5 5 4 3 5 1 3 5 5 4 4 4 2 5 4 2 2 3 4 4\\n2 5 4 4 2 1 4 4 4 5 4 1 2 1 5 2 4 3 4 1 4 1 2 5 1 4 5 4 2 1 2 5 3\\n\",\n    \"70 7 3\\n4 2 5 5 2 3 1 1 2 5 3 1 5 1 1 4 2 4 3 4 4 5 2 3 2 3 5 3 5 5 1 2 2 4 5 1 3 1 2 2 1 5 4 2 4 1 5 1 1 4 5 2 3 4 4 2 4 2 1 3 5 5 1 3 3 2 1 5 5 5\\n4 1 1 3 2 3 4\\n\",\n    \"82 50 1\\n4 2 2 4 4 3 2 2 3 3 4 3 4 1 4 1 4 3 5 3 4 2 4 4 5 2 5 4 2 4 2 5 3 2 3 4 2 5 4 3 3 4 3 4 1 1 5 2 4 1 3 3 2 4 1 2 2 5 4 4 5 3 3 1 2 3 4 5 3 1 2 3 3 5 5 2 4 1 4 2 3 1\\n4 3 3 3 4 1 4 4 5 5 5 2 5 4 1 2 2 1 3 3 3 3 2 5 3 2 4 3 2 2 4 4 4 3 4 2 1 2 3 2 1 1 5 2 3 5 4 5 3 4\\n\",\n    \"41 6 1\\n1 3 1 1 3 4 2 3 1 5 2 3 5 2 3 1 4 4 3 4 2 5 1 3 3 4 2 3 1 3 4 3 1 5 2 3 4 2 1 5 3\\n3 2 3 1 4 5\\n\",\n    \"3 5 1\\n1 1 1\\n1 1 1 1 1\\n\",\n    \"3 5 1\\n1 1 1\\n1 2 3 4 5\\n\",\n    \"1 1 1\\n1\\n1\\n\",\n    \"1 1 2\\n1\\n2\\n\",\n    \"2 2 1\\n1 2\\n2 1\\n\",\n    \"2 2 1\\n1 2\\n1 2\\n\",\n    \"5 10 1\\n1 1 1 1 1\\n1 1 1 1 1 1 1 1 1 1\\n\",\n    \"5 10 1\\n1 1 1 1 2\\n1 1 1 1 1 1 1 1 1 2\\n\",\n    \"10 3 3\\n999999991 999999991 999999991 999999992 999999992 999999993 999999993 999999993 999999993 999999991\\n999999991 999999992 999999993\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n1 3\\n\",\n    \"2\\n1 2\\n\",\n    \"3\\n2 13 15\\n\",\n    \"1\\n1\\n\",\n    \"3\\n4 8 30\\n\",\n    \"3\\n10 11 12\\n\",\n    \"1\\n2\\n\",\n    \"12\\n3 6 7 8 10 15 16 21 24 41 43 44\\n\",\n    \"1\\n20\\n\",\n    \"2\\n6 28\\n\",\n    \"2\\n24 28\\n\",\n    \"10\\n5 12 19 20 21 22 30 31 32 36\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"1\\n1\\n\",\n    \"0\\n\",\n    \"1\\n1\\n\",\n    \"1\\n1\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"3\\n1 2 4\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}