{
    "problem": "You are an expert Python programmer, and here is your task: There is a square grid of size $n \\times n$. Some cells are colored in black, all others are colored in white. In one operation you can select some rectangle and color all its cells in white. It costs $\\min(h, w)$ to color a rectangle of size $h \\times w$. You are to make all cells white for minimum total cost.\n\nThe square is large, so we give it to you in a compressed way. The set of black cells is the union of $m$ rectangles.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 10^{9}$, $0 \\le m \\le 50$)\u00a0\u2014 the size of the square grid and the number of black rectangles.\n\nEach of the next $m$ lines contains 4 integers $x_{i1}$ $y_{i1}$ $x_{i2}$ $y_{i2}$ ($1 \\le x_{i1} \\le x_{i2} \\le n$, $1 \\le y_{i1} \\le y_{i2} \\le n$)\u00a0\u2014 the coordinates of the bottom-left and the top-right corner cells of the $i$-th black rectangle.\n\nThe rectangles may intersect.\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the minimum total cost of painting the whole square in white.\n\n\n-----Examples-----\nInput\n10 2\n4 1 5 10\n1 4 10 5\n\nOutput\n4\n\nInput\n7 6\n2 1 2 1\n4 2 4 3\n2 5 2 5\n2 3 5 3\n1 2 1 2\n3 2 5 3\n\nOutput\n3\n\n\n\n-----Note-----\n\nThe examples and some of optimal solutions are shown on the pictures below.\n\n [Image]",
    "solution": "[\"import sys\\nfrom collections import defaultdict\\n\\nclass MaxFlow(object):\\n    def __init__(self):\\n        self.edges = defaultdict(lambda: defaultdict(lambda: 0))\\n\\n    def add_edge(self, u, v, capacity=float('inf')):\\n        self.edges[u][v] = capacity\\n\\n    def bfs(self, s, t):\\n        open_q = [s]\\n\\n        visited = set()\\n        parent = dict()\\n        while open_q:\\n            close_q = []\\n            for node in open_q:\\n                for v, capacity in list(self.edges[node].items()):\\n                    if v not in visited and capacity > 0:\\n                        close_q.append(v)\\n                        parent[v] = node\\n                        visited.add(v)\\n                        if v == t:\\n                            result = []\\n                            n2 = v\\n                            n1 = node\\n                            while n1 != s:\\n                                result.append((n1, n2))\\n                                n2 = n1\\n                                n1 = parent[n1]\\n                            result.append((n1, n2))\\n                            return result\\n\\n            open_q = close_q\\n\\n        return None\\n\\n    def solve(self, s, t):\\n        flow = 0\\n        route = self.bfs(s, t)\\n        while route is not None:\\n            new_flow = float('inf')\\n            for _, (n1, n2) in enumerate(route):\\n                new_flow = min(new_flow, self.edges[n1][n2])\\n            for _, (n1, n2) in enumerate(route):\\n                self.edges[n1][n2] -= new_flow\\n                self.edges[n2][n1] += new_flow\\n            flow += new_flow\\n\\n            route = self.bfs(s, t)\\n\\n        return flow\\n\\n    def __str__(self):\\n        result = \\\"{ \\\"\\n        for k, v in list(self.edges.items()):\\n            result += str(k) + \\\":\\\" + str(dict(v)) + \\\", \\\"\\n        result += \\\"}\\\"\\n        return result\\n\\n\\ndef main():\\n    (n, m) = tuple([int(x) for x in input().split()])\\n    r = []\\n    xs = set()\\n    ys = set()\\n    for i in range(m):\\n        (x1, y1, x2, y2) = tuple(int(x) for x in input().split())\\n        r.append((x1, y1, x2, y2))\\n        xs.add(x1)\\n        xs.add(x2 + 1)\\n        ys.add(y1)\\n        ys.add(y2 + 1)\\n\\n    xx = sorted(xs)\\n    yy = sorted(ys)\\n    xsize = len(xs)\\n    ysize = len(ys)\\n    grid = []\\n    for i in range(ysize):\\n        grid.append([False] * xsize)\\n\\n    for rect in r:\\n        x1 = rect[0]\\n        y1 = rect[1]\\n        x2 = rect[2]\\n        y2 = rect[3]\\n        for i, y in enumerate(yy):\\n            for j, x in enumerate(xx):\\n                if x1 <= x and y1 <= y and x2 >= x and y2 >= y:\\n                    grid[i][j] = True\\n\\n    f = MaxFlow()\\n    for i in range(len(yy)):\\n        for j in range(len(xx)):\\n            if grid[i][j]:\\n                f.add_edge(1 + i, len(yy) + 1 + j, float('inf'))\\n    for i in range(len(yy) - 1):\\n        f.add_edge(0, i + 1, yy[i + 1] - yy[i])\\n    for i in range(len(xx) - 1):\\n        f.add_edge(len(yy) + 1 + i, len(xx) + len(yy) + 1, xx[i + 1] - xx[i])\\n\\n    # print(xx)\\n    # print(yy)\\n    # print(f)\\n    print(f.solve(0, len(xx) + len(yy) + 1))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\"]",
    "test": "{\n  \"inputs\": [\n    \"10 2\\n4 1 5 10\\n1 4 10 5\\n\",\n    \"7 6\\n2 1 2 1\\n4 2 4 3\\n2 5 2 5\\n2 3 5 3\\n1 2 1 2\\n3 2 5 3\\n\",\n    \"1 0\\n\",\n    \"200 13\\n84 113 191 187\\n52 68 74 83\\n63 46 158 68\\n38 15 170 81\\n38 81 164 183\\n109 52 141 156\\n117 151 126 155\\n21 25 128 197\\n111 30 163 59\\n138 62 154 73\\n83 161 143 189\\n26 56 77 196\\n19 56 66 150\\n\",\n    \"10 3\\n4 8 6 9\\n2 3 4 4\\n6 5 6 6\\n\",\n    \"10 5\\n3 2 10 5\\n8 2 10 2\\n5 4 5 6\\n5 1 8 7\\n10 4 10 10\\n\",\n    \"10 9\\n6 1 9 9\\n5 1 8 8\\n4 7 6 8\\n3 9 10 9\\n1 2 3 4\\n8 6 9 7\\n5 1 5 8\\n3 7 3 10\\n2 6 4 9\\n\",\n    \"50 3\\n17 33 19 45\\n1 13 47 50\\n2 38 31 49\\n\",\n    \"50 5\\n2 16 39 20\\n32 29 36 42\\n14 4 23 9\\n17 16 28 45\\n1 33 46 39\\n\",\n    \"50 9\\n15 28 32 38\\n7 34 45 49\\n14 7 25 49\\n22 4 28 48\\n1 34 41 36\\n27 12 29 36\\n4 6 30 18\\n1 40 40 41\\n9 22 45 32\\n\",\n    \"200 3\\n171 77 191 120\\n1 177 46 182\\n42 15 162 50\\n\",\n    \"200 5\\n9 10 59 49\\n32 6 83 156\\n78 133 125 170\\n28 92 177 175\\n37 23 168 25\\n\",\n    \"200 9\\n98 2 172 82\\n46 122 98 161\\n31 28 98 65\\n40 109 189 195\\n27 20 73 73\\n183 46 198 77\\n42 29 103 132\\n115 34 160 68\\n50 20 93 182\\n\",\n    \"200 18\\n16 4 162 109\\n7 98 30 184\\n30 85 61 186\\n48 160 177 178\\n25 27 76 185\\n39 2 119 119\\n50 126 151 127\\n49 21 165 49\\n67 9 190 105\\n2 10 112 86\\n9 39 158 158\\n89 105 125 137\\n153 67 196 157\\n104 97 130 163\\n2 109 75 194\\n43 97 96 97\\n1 98 168 168\\n111 30 129 73\\n\",\n    \"200 24\\n26 9 43 17\\n20 27 44 190\\n78 27 117 96\\n6 43 55 192\\n8 120 166 133\\n91 44 114 47\\n52 185 149 185\\n145 42 169 161\\n2 132 93 136\\n11 127 156 133\\n72 143 161 148\\n9 31 52 50\\n73 20 79 184\\n132 3 161 73\\n129 11 192 44\\n85 188 150 195\\n158 159 174 176\\n81 60 192 167\\n51 47 119 54\\n18 165 37 197\\n13 27 169 34\\n28 120 45 176\\n10 79 178 112\\n122 22 173 150\\n\",\n    \"1000 3\\n296 494 507 910\\n101 154 570 609\\n48 579 101 812\\n\",\n    \"1000 5\\n334 123 582 438\\n183 433 852 934\\n435 626 529 996\\n143 78 824 386\\n21 363 955 978\\n\",\n    \"1000 9\\n221 596 897 600\\n346 990 822 993\\n697 63 874 749\\n533 77 955 224\\n12 263 860 834\\n184 70 395 175\\n290 481 363 942\\n130 135 364 276\\n24 81 783 437\\n\",\n    \"1000 13\\n127 536 917 639\\n595 533 881 744\\n695 484 985 618\\n717 308 888 531\\n389 430 908 589\\n50 140 388 210\\n130 92 254 933\\n730 319 936 859\\n455 184 890 754\\n371 254 609 479\\n92 9 311 534\\n110 444 942 951\\n633 148 807 799\\n\",\n    \"1000 18\\n741 34 804 58\\n629 658 751 844\\n502 335 936 923\\n105 35 332 652\\n362 176 827 591\\n627 573 814 986\\n851 608 980 867\\n58 406 376 603\\n282 28 541 534\\n235 19 271 371\\n166 495 377 886\\n309 152 861 240\\n507 265 990 701\\n216 27 454 934\\n169 208 789 536\\n324 92 642 840\\n189 341 805 359\\n695 765 790 901\\n\",\n    \"1000 24\\n190 39 552 958\\n539 146 763 587\\n31 526 423 673\\n208 432 953 442\\n263 69 719 635\\n162 428 623 797\\n49 126 94 963\\n749 623 979 919\\n190 461 367 855\\n211 240 939 914\\n169 80 336 203\\n684 546 829 582\\n80 218 324 327\\n560 452 656 637\\n316 534 982 642\\n521 634 758 686\\n514 324 753 437\\n342 395 384 995\\n479 246 723 400\\n217 344 886 381\\n52 50 686 432\\n636 245 699 643\\n205 9 278 62\\n446 460 479 660\\n\",\n    \"1000000000 3\\n759015278 311645863 977199104 413261371\\n17450998 375349221 428269906 902340672\\n310207450 432866707 841374960 756699437\\n\",\n    \"1000000000 5\\n175991137 463805003 423173142 846453004\\n316647784 561571055 533177891 759404250\\n367497836 223465366 484781581 257304521\\n854838912 188836931 920765503 912199365\\n129732287 492353023 208065087 527794268\\n\",\n    \"1000000000 9\\n755312705 208314772 979816776 413350061\\n504975947 580545612 742993862 822481605\\n71081030 302221415 777045906 760955957\\n59005620 71441769 579437611 173761068\\n108290992 135681316 130173981 423327924\\n730854196 342245706 987367869 746156573\\n549592180 299075961 851728078 759898613\\n767765094 416880160 988884730 602444576\\n132601847 887575854 837539482 977191979\\n\"\n  ],\n  \"outputs\": [\n    \"4\\n\",\n    \"3\\n\",\n    \"0\\n\",\n    \"173\\n\",\n    \"5\\n\",\n    \"8\\n\",\n    \"10\\n\",\n    \"38\\n\",\n    \"32\\n\",\n    \"45\\n\",\n    \"63\\n\",\n    \"162\\n\",\n    \"172\\n\",\n    \"193\\n\",\n    \"191\\n\",\n    \"523\\n\",\n    \"919\\n\",\n    \"850\\n\",\n    \"936\\n\",\n    \"933\\n\",\n    \"952\\n\",\n    \"590694810\\n\",\n    \"458554593\\n\",\n    \"827985250\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}