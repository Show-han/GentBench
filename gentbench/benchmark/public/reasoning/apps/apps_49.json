{
    "problem": "You are an expert Python programmer, and here is your task: Mike has a frog and a flower. His frog is named Xaniar and his flower is named Abol. Initially(at time 0), height of Xaniar is h_1 and height of Abol is h_2. Each second, Mike waters Abol and Xaniar.\n\n [Image] \n\nSo, if height of Xaniar is h_1 and height of Abol is h_2, after one second height of Xaniar will become $(x_{1} h_{1} + y_{1}) \\operatorname{mod} m$ and height of Abol will become $(x_{2} h_{2} + y_{2}) \\operatorname{mod} m$ where x_1, y_1, x_2 and y_2 are some integer numbers and $a \\operatorname{mod} b$ denotes the remainder of a modulo b.\n\nMike is a competitive programmer fan. He wants to know the minimum time it takes until height of Xania is a_1 and height of Abol is a_2.\n\nMike has asked you for your help. Calculate the minimum time or say it will never happen.\n\n\n-----Input-----\n\nThe first line of input contains integer m (2 \u2264 m \u2264 10^6).\n\nThe second line of input contains integers h_1 and a_1 (0 \u2264 h_1, a_1 < m).\n\nThe third line of input contains integers x_1 and y_1 (0 \u2264 x_1, y_1 < m).\n\nThe fourth line of input contains integers h_2 and a_2 (0 \u2264 h_2, a_2 < m).\n\nThe fifth line of input contains integers x_2 and y_2 (0 \u2264 x_2, y_2 < m).\n\nIt is guaranteed that h_1 \u2260 a_1 and h_2 \u2260 a_2.\n\n\n-----Output-----\n\nPrint the minimum number of seconds until Xaniar reaches height a_1 and Abol reaches height a_2 or print -1 otherwise.\n\n\n-----Examples-----\nInput\n5\n4 2\n1 1\n0 1\n2 3\n\nOutput\n3\n\nInput\n1023\n1 2\n1 0\n1 2\n1 1\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first sample, heights sequences are following:\n\nXaniar: $4 \\rightarrow 0 \\rightarrow 1 \\rightarrow 2$\n\nAbol: $0 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1$",
    "solution": "[\"import fractions\\n\\ndef read_data():\\n    m = int(input())\\n    h1, a1 = map(int, input().split())\\n    x1, y1 = map(int, input().split())\\n    h2, a2 = map(int, input().split())\\n    x2, y2 = map(int, input().split())\\n    return m, h1, a1, x1, y1, h2, a2, x2, y2\\n\\ndef solve(m, h1, a1, x1, y1, h2, a2, x2, y2):\\n    t = 0\\n    h1s = [-1] * m\\n    h2s = [-1] * m\\n    h1s[h1] = 0\\n    h2s[h2] = 0\\n    t1 = -1\\n    t2 = -1\\n    while h1 != a1 or h2 != a2:\\n        t += 1\\n        h1 = (x1 * h1 + y1) % m\\n        h2 = (x2 * h2 + y2) % m\\n        if h1s[h1] >= 0 and t1 == -1:\\n            t1 = h1s[h1]\\n            s1 = t - t1\\n            if t2 >= 0:\\n                break\\n        else:\\n            h1s[h1] = t\\n        if h2s[h2] >= 0 and t2 == -1:\\n            t2 = h2s[h2]\\n            s2 = t - t2\\n            if t1 >= 0:\\n                break\\n        else:\\n            h2s[h2] = t\\n    if h1 == a1 and h2 == a2:\\n        return t\\n    return retrieve(a1, a2, t1, s1, t2, s2, h1s, h2s)\\n\\ndef retrieve(a1, a2, t1, s1, t2, s2, h1s, h2s):\\n    u1 = h1s[a1]\\n    u2 = h2s[a2]\\n    if u1 == -1 or u2 == -1:\\n        return -1\\n    if u1 < t1:\\n        if guess(h2s, u1, t2, s2, a2):\\n            return u1\\n        else:\\n            return -1\\n    if u2 < t2:\\n        if guess(h1s, u2, t1, s1, a1):\\n            return u2\\n        else:\\n            return -1\\n    return find_time(u1, s1, u2, s2)\\n\\ndef guess(hs, u, t, s, a):\\n    if u <= t:\\n        return hs[a] == u\\n    tt = t + (u - t) % s\\n    return hs[a] == tt\\n\\ndef find_time(u1, s1, u2, s2):\\n    g = fractions.gcd(s1, s2)\\n    if abs(u1 - u2) % g:\\n        return -1\\n    k1, k2 = extended_euclid(s1, s2, u2-u1, g)\\n    b = s2 // g\\n    return (k1 % b) * s1 + u1\\n\\ndef egcd(a, b):\\n    x, lastx = 0, 1\\n    y, lasty = 1, 0\\n    while b:\\n        q = a // b\\n        a, b = b, a % b\\n        x, lastx = lastx - q * x, x\\n        y, lasty = lasty - q * y, y\\n    return lastx, lasty\\n\\ndef extended_euclid(a, b, c, g):\\n    x, y = egcd(a, b)\\n    return (c // g) * x, (x // g) * y\\n\\n\\nparam = read_data()\\nprint(solve(*param))\", \"mod = int(input())\\nh1, a1 = map(int, input().split())\\nx1, y1 = map(int, input().split())\\nh2, a2 = map(int, input().split())\\nx2, y2 = map(int, input().split())\\n\\nq1 = 0\\nwhile h1 != a1:\\n    h1 = (h1 * x1 + y1) % mod\\n    q1 += 1\\n    if q1 > 2 * mod:\\n        print(-1)\\n        return\\n\\nq2 = 0\\nt2 = h2\\nwhile t2 != a2:\\n    t2 = (t2 * x2 + y2) % mod\\n    q2 += 1\\n    if q2 > 2 * mod:\\n        print(-1)\\n        return\\n\\nif q1 == q2:\\n    print(q1)\\n    return\\n\\n\\nc1 = 1\\nh1 = (a1 * x1 + y1) % mod\\nwhile h1 != a1:\\n    h1 = (h1 * x1 + y1) % mod\\n    c1 += 1\\n    if c1 > 2 * mod:\\n        print(-1)\\n        return\\n\\nc2 = 0\\nnx2 = 1\\nny2 = 0\\n\\nfor i in range(c1):\\n    nx2 = (nx2 * x2) % mod\\n    ny2 = (ny2 * x2 + y2) % mod\\n\\nfor i in range(q1):\\n    h2 = (h2 * x2 + y2) % mod\\n\\nwhile h2 != a2:\\n    h2 = (h2 * nx2 + ny2) % mod\\n    c2 += 1\\n    if c2 > 2 * mod:\\n        print(-1)\\n        return\\n\\nprint(q1 + c1 * c2)\", \"__author__ = 'kitkat'\\nimport sys\\n\\n\\n\\ndef GetNext(h, x, y):\\n    nonlocal m\\n    return (x * h + y) % m\\ntry:\\n    while True:\\n        m = int(input())\\n        h1, a1 = list(map(int, input().split(\\\" \\\")))\\n        x1, y1 = list(map(int, input().split(\\\" \\\")))\\n        h2, a2 = list(map(int, input().split(\\\" \\\")))\\n        x2, y2 = list(map(int, input().split(\\\" \\\")))\\n        t1 = []\\n        t2 = []\\n        T = 0\\n        for i in range (2 * m + 1):\\n            if h1 == a1:\\n                t1.append(T)\\n            if h2 == a2:\\n                t2.append(T)\\n            T += 1\\n            h1 = GetNext(h1, x1, y1)\\n            h2 = GetNext(h2, x2, y2)\\n\\n        if len(t1) == 0 or len(t2) == 0:\\n            print(\\\"-1\\\")\\n            continue\\n        if t1[0] == t2[0]:\\n            print(t1[0])\\n            continue\\n        elif len(t1) < 2 or len(t2) < 2:\\n            if len(t1) == 1 and len(t2) == 1:\\n                print(t1[0] if t1[0] == t2[0] else \\\"-1\\\")\\n            elif len(t1) == 1:\\n                if t1[0] in t2:\\n                    print(t1[0])\\n                else:\\n                    print(\\\"-1\\\")\\n            elif len(t2) == 1:\\n                if t2[0] in t1:\\n                    print(t2[0])\\n                else:\\n                    print(\\\"-1\\\")\\n            continue\\n        res1 = t1[0]\\n        res2 = t2[0]\\n        flag = False\\n        for i in range (5000000):\\n            if res1 == res2:\\n                flag = True\\n                print(res1)\\n                break\\n            elif res1 <= res2:\\n                res1 += t1[1] - t1[0]\\n            else:\\n                res2 += t2[1] - t2[0]\\n        if not flag:\\n            print(\\\"-1\\\")\\nexcept EOFError:\\n    pass\\n\", \"def main():\\n    m, tt = int(input()), [0] * 4\\n    for i in 0, 2:\\n        h, a = list(map(int, input().split()))\\n        x, y = list(map(int, input().split()))\\n        ha = (h, a)\\n        for t in range(1, m * 2):\\n            h = (h * x + y) % m\\n            if h in ha:\\n                if h == ha[0]:\\n                    if tt[i]:\\n                        tt[i] = t - tt[i]\\n                        break\\n                    else:\\n                        tt[i] = t\\n                else:\\n                    if tt[i + 1]:\\n                        tt[i] = t - tt[i + 1]\\n                        break\\n                    else:\\n                        tt[i + 1] = t\\n    step1, shift1, step2, shift2 = tt if tt[0] > tt[2] else tt[2:] + tt[:2]\\n    if shift1 == shift2 != 0:\\n        print(shift1)\\n        return\\n    if step1 and not step2 and shift1 and shift1 <= shift2 and not (shift2 - shift1) % step1:\\n        print(shift2)\\n        return\\n    if all(tt):\\n        if step2 == 1:\\n            print(shift1 if shift1 >= shift2 else shift2 + (shift2 - shift1) % step1)\\n            return\\n        for t in range(shift1 - shift2, shift1 - shift2 + step1 * step2, step1):\\n            if not t % step2:\\n                print(t + shift2)\\n                return\\n    print(-1)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"mod = int(input())\\nh1, a1 = map(int, input().split())\\nx1, y1 = map(int, input().split())\\nh2, a2 = map(int, input().split())\\nx2, y2 = map(int, input().split())\\n\\nq1 = 0\\nwhile h1 != a1:\\n    h1 = (h1 * x1 + y1) % mod\\n    q1 += 1\\n    if q1 > 2 * mod:\\n        print(-1)\\n        return\\n\\nq2 = 0\\nt2 = h2\\nwhile t2 != a2:\\n    t2 = (t2 * x2 + y2) % mod\\n    q2 += 1\\n    if q2 > 2 * mod:\\n        print(-1)\\n        return\\n\\nif q1 == q2:\\n    print(q1)\\n    return\\n\\n\\nc1 = 1\\nh1 = (a1 * x1 + y1) % mod\\nwhile h1 != a1:\\n    h1 = (h1 * x1 + y1) % mod\\n    c1 += 1\\n    if c1 > 2 * mod:\\n        print(-1)\\n        return\\n\\nc2 = 0\\nnx2 = 1\\nny2 = 0\\n\\nfor i in range(c1):\\n    nx2 = (nx2 * x2) % mod\\n    ny2 = (ny2 * x2 + y2) % mod\\n\\nfor i in range(q1):\\n    h2 = (h2 * x2 + y2) % mod\\n\\nwhile h2 != a2:\\n    h2 = (h2 * nx2 + ny2) % mod\\n    c2 += 1\\n    if c2 > 2 * mod:\\n        print(-1)\\n        return\\n\\nprint(q1 + c1 * c2)\", \"from fractions import *\\nf = lambda: map(int, input().split())\\nm = int(input())\\n\\ndef g(u, v):\\n    h, a = u\\n    x, y = v\\n\\n    s = 0\\n    while h != a:\\n        h = (h * x + y) % m\\n        s += 1\\n        if s > m: break\\n\\n    h = (a * x + y) % m\\n    d = 1\\n    while h != a:\\n        h = (h * x + y) % m\\n        d += 1\\n        if d > m: break\\n\\n    return s, d\\n\\n(u, x), (v, y) = g(f(), f()), g(f(), f())\\n\\nif u > m or v > m: q = -1\\nelif u == v: q = u\\nelif x > m: q = -1 if u < v or (v - u) % y else u\\nelif y > m: q = -1 if v < u or (v - u) % x else v\\nelif (v - u) % gcd(x, y): q = -1\\nelse:\\n    while u != v:\\n        if u < v: u += x\\n        else: v += y\\n    q = u\\n\\nprint(q)\"]",
    "test": "{\n  \"inputs\": [\n    \"5\\n4 2\\n1 1\\n0 1\\n2 3\\n\",\n    \"1023\\n1 2\\n1 0\\n1 2\\n1 1\\n\",\n    \"1023\\n1 2\\n1 2\\n1 2\\n1 2\\n\",\n    \"2\\n0 1\\n1 0\\n1 0\\n0 1\\n\",\n    \"17\\n15 12\\n15 12\\n12 14\\n1 11\\n\",\n    \"29\\n4 0\\n1 1\\n25 20\\n16 0\\n\",\n    \"91\\n9 64\\n75 32\\n60 81\\n35 46\\n\",\n    \"91\\n38 74\\n66 10\\n40 76\\n17 13\\n\",\n    \"100\\n11 20\\n99 31\\n60 44\\n45 64\\n\",\n    \"9999\\n4879 6224\\n63 7313\\n4279 6583\\n438 1627\\n\",\n    \"10000\\n8681 4319\\n9740 5980\\n24 137\\n462 7971\\n\",\n    \"100000\\n76036 94415\\n34870 43365\\n56647 26095\\n88580 30995\\n\",\n    \"100000\\n90861 77058\\n96282 30306\\n45940 25601\\n17117 48287\\n\",\n    \"1000000\\n220036 846131\\n698020 485511\\n656298 242999\\n766802 905433\\n\",\n    \"1000000\\n536586 435396\\n748740 34356\\n135075 790803\\n547356 534911\\n\",\n    \"1000000\\n661647 690400\\n864868 326304\\n581148 452012\\n327910 197092\\n\",\n    \"1000000\\n233404 949288\\n893747 751429\\n692094 57207\\n674400 583468\\n\",\n    \"1000000\\n358465 242431\\n977171 267570\\n170871 616951\\n711850 180241\\n\",\n    \"1000000\\n707719 502871\\n60595 816414\\n649648 143990\\n525107 66615\\n\",\n    \"999983\\n192005 690428\\n971158 641039\\n974183 1882\\n127579 312317\\n\",\n    \"999983\\n420528 808305\\n387096 497121\\n596163 353326\\n47177 758204\\n\",\n    \"999983\\n651224 992349\\n803017 393514\\n258455 402487\\n888310 244420\\n\",\n    \"999983\\n151890 906425\\n851007 9094\\n696594 968184\\n867017 157783\\n\",\n    \"999983\\n380412 325756\\n266945 907644\\n318575 83081\\n786616 603671\\n\",\n    \"999983\\n570797 704759\\n723177 763726\\n978676 238272\\n708387 89886\\n\",\n    \"999983\\n408725 408721\\n1 1\\n378562 294895\\n984270 0\\n\",\n    \"999983\\n639420 639416\\n1 1\\n507684 954997\\n466316 0\\n\",\n    \"999983\\n867942 867939\\n1 1\\n963840 536667\\n899441 0\\n\",\n    \"999961\\n664221 931770\\n530542 936292\\n885122 515424\\n868560 472225\\n\",\n    \"999961\\n744938 661980\\n845908 76370\\n237399 381935\\n418010 938769\\n\",\n    \"999961\\n89288 89284\\n1 1\\n764559 727291\\n999322 0\\n\",\n    \"1000000\\n661703 661699\\n1 1\\n425192 823944\\n854093 0\\n\",\n    \"100019\\n98811 98807\\n1 1\\n91322 14787\\n72253 0\\n\",\n    \"524288\\n199980 199978\\n1 1\\n236260 325076\\n81773 0\\n\",\n    \"524288\\n47283 489031\\n305624 183135\\n141146 335913\\n519614 150715\\n\",\n    \"524288\\n83398 33987\\n158854 211502\\n36433 18758\\n218812 517001\\n\",\n    \"912488\\n681639 518634\\n168348 212018\\n255428 4970\\n31726 664998\\n\",\n    \"129081\\n128454 36771\\n116353 2940\\n95311 22200\\n579 118683\\n\",\n    \"129081\\n45717 106320\\n121816 69841\\n5161 4872\\n102076 100020\\n\",\n    \"4\\n1 2\\n1 1\\n0 1\\n2 0\\n\",\n    \"3\\n1 0\\n1 1\\n1 2\\n2 0\\n\",\n    \"3\\n0 2\\n1 0\\n2 0\\n2 1\\n\",\n    \"2\\n0 1\\n0 1\\n0 1\\n0 1\\n\",\n    \"2\\n0 1\\n1 0\\n0 1\\n1 0\\n\",\n    \"2\\n0 1\\n1 1\\n0 1\\n1 1\\n\",\n    \"2\\n0 1\\n1 1\\n0 1\\n1 0\\n\",\n    \"2\\n0 1\\n1 0\\n0 1\\n1 1\\n\",\n    \"1000000\\n1 0\\n1 1\\n1 0\\n1 1\\n\",\n    \"1000000\\n2 1\\n1 1\\n2 0\\n1 2\\n\",\n    \"6\\n1 2\\n3 5\\n0 2\\n4 2\\n\",\n    \"545\\n26 40\\n477 97\\n454 394\\n15 264\\n\",\n    \"3\\n1 0\\n0 1\\n0 2\\n1 0\\n\",\n    \"1376\\n1227 1349\\n313 193\\n1113 361\\n1314 23\\n\",\n    \"1376\\n1322 1320\\n1 1\\n776 495\\n38 0\\n\",\n    \"1376\\n152 405\\n1083 1328\\n76 856\\n49 629\\n\",\n    \"1392\\n1060 796\\n512 242\\n1386 1346\\n1310 1199\\n\",\n    \"100000\\n5827 41281\\n41285 70821\\n99199 42807\\n65667 94952\\n\",\n    \"100000\\n51157 27741\\n40564 90740\\n45270 52367\\n31585 92150\\n\",\n    \"100000\\n70525 70522\\n1 1\\n89465 30265\\n33279 0\\n\",\n    \"10\\n1 6\\n7 9\\n1 4\\n4 0\\n\",\n    \"10\\n9 6\\n0 8\\n3 0\\n2 7\\n\",\n    \"10\\n4 2\\n1 1\\n7 3\\n9 0\\n\",\n    \"6\\n5 1\\n1 1\\n3 1\\n3 0\\n\",\n    \"999983\\n3 1\\n1 1\\n8 1\\n2 0\\n\",\n    \"18\\n3 9\\n3 0\\n1 3\\n3 0\\n\",\n    \"18\\n1 3\\n3 0\\n3 9\\n3 0\\n\",\n    \"16\\n1 0\\n2 0\\n1 2\\n2 0\\n\",\n    \"16\\n8 0\\n2 0\\n1 4\\n2 0\\n\",\n    \"999983\\n2 1\\n2 0\\n1 0\\n1 1\\n\",\n    \"324\\n2 54\\n3 0\\n27 108\\n2 0\\n\",\n    \"999993\\n499997 1\\n2 3\\n1 4\\n1 1\\n\",\n    \"999983\\n1 37827\\n1 1\\n2 192083\\n3 0\\n\",\n    \"41222\\n30759 26408\\n31332 39118\\n5026 25812\\n1 9030\\n\",\n    \"100007\\n2 1\\n2 0\\n3 1\\n1 1\\n\",\n    \"8\\n0 4\\n4 4\\n1 4\\n2 0\\n\"\n  ],\n  \"outputs\": [\n    \"3\\n\",\n    \"-1\\n\",\n    \"512\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"170\\n\",\n    \"5\\n\",\n    \"-1\\n\",\n    \"3\\n\",\n    \"4\\n\",\n    \"-1\\n\",\n    \"5\\n\",\n    \"-1\\n\",\n    \"5297\\n\",\n    \"9958\\n\",\n    \"1021\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"470479\\n\",\n    \"548500\\n\",\n    \"126531\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"499981500166\\n\",\n    \"499981500166\\n\",\n    \"999964000320\\n\",\n    \"-1\\n\",\n    \"203332\\n\",\n    \"999920001595\\n\",\n    \"-1\\n\",\n    \"10003600319\\n\",\n    \"-1\\n\",\n    \"19\\n\",\n    \"-1\\n\",\n    \"34838\\n\",\n    \"68409\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"5\\n\",\n    \"-1\\n\",\n    \"1\\n\",\n    \"-1\\n\",\n    \"1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"999999\\n\",\n    \"999999\\n\",\n    \"1\\n\",\n    \"90\\n\",\n    \"-1\\n\",\n    \"338\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"13770\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"499981500168\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"-1\\n\",\n    \"2\\n\",\n    \"499982500152\\n\",\n    \"-1\\n\",\n    \"39325724721\\n\",\n    \"404303164556\\n\",\n    \"58900566\\n\",\n    \"434330399\\n\",\n    \"2\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}