{
    "problem": "You are an expert Python programmer, and here is your task: Ujan has been lazy lately, but now has decided to bring his yard to good shape. First, he decided to paint the path from his house to the gate.\n\nThe path consists of $n$ consecutive tiles, numbered from $1$ to $n$. Ujan will paint each tile in some color. He will consider the path aesthetic if for any two different tiles with numbers $i$ and $j$, such that $|j - i|$ is a divisor of $n$ greater than $1$, they have the same color. Formally, the colors of two tiles with numbers $i$ and $j$ should be the same if $|i-j| > 1$ and $n \\bmod |i-j| = 0$ (where $x \\bmod y$ is the remainder when dividing $x$ by $y$).\n\nUjan wants to brighten up space. What is the maximum number of different colors that Ujan can use, so that the path is aesthetic?\n\n\n-----Input-----\n\nThe first line of input contains a single integer $n$ ($1 \\leq n \\leq 10^{12}$), the length of the path.\n\n\n-----Output-----\n\nOutput a single integer, the maximum possible number of colors that the path can be painted in.\n\n\n-----Examples-----\nInput\n4\n\nOutput\n2\n\nInput\n5\n\nOutput\n5\n\n\n\n-----Note-----\n\nIn the first sample, two colors is the maximum number. Tiles $1$ and $3$ should have the same color since $4 \\bmod |3-1| = 0$. Also, tiles $2$ and $4$ should have the same color since $4 \\bmod |4-2| = 0$.\n\nIn the second sample, all five colors can be used. [Image]",
    "solution": "[\"n = int(input())\\np = 2\\nwhile n % p and p ** 2 <= n:\\n    p += 1\\nif p ** 2 > n:\\n    p = n\\npw = n.bit_length() // p.bit_length()\\nwhile pow(p, pw) < n:\\n    pw += 1\\nwhile pow(p, pw) > n:\\n    pw -= 1\\nif pow(p, pw) == n:\\n    print(p)\\nelse:\\n    print(1)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nx=int(input())\\n\\nif x==1:\\n    print(1)\\n    return\\n\\nimport math \\nL=int(math.sqrt(x))\\n\\nFACT=dict()\\n\\nfor i in range(2,L+2):\\n    while x%i==0:\\n        FACT[i]=FACT.get(i,0)+1\\n        x=x//i\\n\\nif x!=1:\\n    FACT[x]=FACT.get(x,0)+1\\n\\nif len(FACT)>1:\\n    print(1)\\nelse:\\n    print(list(FACT.keys())[0])\\n\", \"n = int(input())\\n\\ntest = 2\\nout = 1\\nwhile test * test <= n:\\n    p = 0\\n    while n % test == 0:\\n        n //= test\\n        p += 1\\n\\n    if p >= 1:\\n        out = test\\n        break\\n\\n    test += 1\\n\\nif out == 1 and n > 1:\\n    print(n)\\nelif out > 1 and n == 1:\\n    print(out)\\nelse:\\n    print(1)\\n\", \"from functools import reduce\\ndef primeFactor(N):\\n    i, n, ret, d, sq = 2, N, {}, 2, 99\\n    while i <= sq:\\n        k = 0\\n        while n % i == 0: n, k, ret[i] = n//i, k+1, k+1\\n        if k > 0 or i == 97: sq = int(n**(1/2)+0.5)\\n        if i < 4: i = i * 2 - 1\\n        else: i, d = i+d, d^6\\n    if n > 1: ret[n] = 1\\n    return ret\\n\\ndef divisors(N):\\n    pf = primeFactor(N)\\n    ret = [1]\\n    for p in pf:\\n        ret_prev = ret\\n        ret = []\\n        for i in range(pf[p]+1):\\n            for r in ret_prev:\\n                ret.append(r * (p ** i))\\n    return sorted(ret)\\n\\n\\ndef gcd(a, b):\\n    while b: a, b = b, a % b\\n    return abs(a)\\ndef gcd_mult(numbers):\\n    return reduce(gcd, numbers)\\n\\n\\nN = int(input())\\ndv = divisors(N)[1:-1]\\nif len(dv) == 0:\\n    print(N)\\nelse:\\n    print(gcd_mult(dv))\\n\", \"3\\n\\nimport array\\nimport bisect\\nimport collections\\nfrom fractions import Fraction\\nimport functools\\nimport itertools\\nimport math\\nimport os\\nimport sys\\n\\n\\ndef main():\\n    N = read_int()\\n    print(solve(N))\\n\\n\\ndef solve(N):\\n    d = []\\n    x = 2\\n    while x * x <= N:\\n        if N % x == 0:\\n            d.append(x)\\n            if x * x < N:\\n                d.append(N // x)\\n        x += 1\\n\\n    d.sort()\\n    if not d:\\n        return N\\n    g = d[0]\\n    for x in d[1:]:\\n        g = math.gcd(g, x)\\n    return g\\n\\n\\n###############################################################################\\n# AUXILIARY FUNCTIONS\\n\\nDEBUG = 'DEBUG' in os.environ\\n\\n\\ndef inp():\\n    return sys.stdin.readline().rstrip()\\n\\n\\ndef read_int():\\n    return int(inp())\\n\\n\\ndef read_ints():\\n    return [int(e) for e in inp().split()]\\n\\n\\ndef dprint(*value, sep=' ', end='\\\\n'):\\n    if DEBUG:\\n        print(*value, sep=sep, end=end)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import sys\\nreadline = sys.stdin.readline\\ndef prf(m):\\n    pf = {}\\n    for i in range(2, int(m**0.5)+1):\\n        while m % i == 0:\\n            pf[i] = pf.get(i, 0)+1\\n            m //= i\\n    if m > 1:\\n        pf[m] = 1\\n    return pf\\n\\nN = int(readline())\\n\\nPf = prf(N)\\n\\nans = 1\\nif len(Pf) == 1:\\n    ans = list(Pf.keys())[0]\\n\\nprint(ans)              \\n\", \"n = int(input())\\nsome_pow = False\\nprime = True\\nd = 2\\nwhile d * d <= n:\\n    if n % d == 0:\\n        tst = n\\n        while tst % d == 0 and tst > 1:\\n            tst //= d\\n        if tst == 1:\\n            some_pow = True\\n        prime = False\\n        break\\n    d += 1\\nif prime:\\n    print(n)\\nelif some_pow:\\n    print(d)\\nelse:\\n    print(1)\\n\", \"from math import sqrt, floor\\n\\ndef sieve(n):\\n\\tprimes = [True] * (n + 1)\\n\\tprimes[0] = False\\n\\tprimes[1] = False\\n\\tfor i in range(2, n + 1):\\n\\t\\tif i*i > n:\\n\\t\\t\\tbreak\\n\\n\\t\\t# if primes[i] == True:\\n\\t\\tif primes[i] == False:\\n\\t\\t\\tcontinue\\n\\n\\t\\t# for j in range(2*i, n + 1):\\n\\t\\tfor j in range(2*i, n + 1, i):\\n\\t\\t\\t# if j == 5:\\n\\t\\t\\t# \\tprint('i: ', i)\\n\\t\\t\\tprimes[j] = False\\n\\n\\treturn primes\\n\\n\\ndef run_testcase():\\n\\tnumber = int(input())\\n\\n\\t# print(sieve(number))\\n\\t# print(zip(range(number), sieve(number)))\\n\\t# print(list(zip(range(number), sieve(number))))\\n\\t# print(list(zip(range(number + 1), sieve(number))))\\n\\n\\t# prime_divisors_count = 0\\n\\n\\t# # while number % 2 == 0:\\n\\t# # \\tprime_divisors_count += 1\\n\\n\\t# last_prime_divisor = 2\\n\\n\\n\\t# # def sieve():\\n\\n\\n\\t# if number % last_prime_divisor == 0:\\n\\t# \\tprime_divisors_count += 1\\n\\t# \\twhile number % last_prime_divisor == 0:\\n\\t# \\t\\t# number /= last_prime_divisor\\n\\t# \\t\\tnumber = number // last_prime_divisor\\n\\n\\t# num_sqrt = sqrt(number)\\n\\n\\t# # primes = [True] * (int(sqrt) + 1)\\n\\t# # primes = [True] * int(sqrt)\\n\\t# # primes = [True] * (int(sqrt) + 1)\\n\\t# # primes = [True] * (floor(num_sqrt) + 1)\\n\\t# primes = [True] * (floor(num_sqrt) + 2)\\n\\t# primes[0] = False\\n\\t# primes[1] = False\\n\\n\\t# # print(len(primes))\\n\\n\\t# # for i in range(len(primes)):\\n\\t# # for i in range(len(2, primes)):\\n\\t# for i in range(2, len(primes)):\\n\\t# \\t# for j in range(i)\\n\\t# \\tif i*i >= num_sqrt:\\n\\t# \\t\\tbreak\\n\\n\\t# \\t# if prime[i] == True:\\n\\t# \\tif primes[i] == True:\\n\\t# \\t\\tcontinue\\n\\n\\t# \\t# j = 0\\n\\t# \\tj = 2 * i\\n\\t# \\twhile j < len(primes):\\n\\t# \\t\\t# print(j)\\n\\t# \\t\\tprimes[j] = False\\n\\t# \\t\\tj += i\\n\\n\\t\\t# print('test')\\n\\n\\tnum_sqrt = sqrt(number)\\n\\n\\t# primes = sieve(num_sqrt)\\n\\tprimes = sieve(floor(num_sqrt))\\n\\n\\tprime_divisors_count = 0\\n\\tlast_prime_divisor = 0\\n\\n\\tfor value, prime in enumerate(primes):\\n\\t\\tif prime:\\n\\t\\t\\tif number % value == 0:\\n\\t\\t\\t\\tlast_prime_divisor = value\\n\\t\\t\\t\\tprime_divisors_count += 1\\n\\t\\t\\t\\tif prime_divisors_count >= 2:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\twhile number % value == 0:\\n\\t\\t\\t\\t\\tnumber = number // value\\n\\t\\t\\t\\tif number == 1:\\n\\t\\t\\t\\t\\treturn value\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn 1\\n\\n\\n\\n\\t# for value, prime in primes:\\n\\tfor value, prime in enumerate(primes):\\n\\t\\tif prime:\\n\\t\\t\\t# print(value)\\n\\t\\t\\tif number % value == 0:\\n\\t\\t\\t\\tlast_prime_divisor = value\\n\\t\\t\\t\\tprime_divisors_count += 1\\n\\t\\t\\t\\tif prime_divisors_count >= 2:\\n\\t\\t\\t\\t\\treturn 1\\n\\n\\n\\t# return last_prime_divisor\\n\\t# return last_prime_divisor if last_prime_divisor != 0 else number\\n\\n\\t# print(last_prime_divisor)\\n\\n\\t# if number == 2:\\n\\t# \\treturn 2\\n\\n\\t# if last_prime_divisor ** 2 == number:\\n\\t\\t# return last_prime_divisor\\n\\tif last_prime_divisor == 0:\\n\\t\\treturn number\\n\\telif last_prime_divisor ** 2 == number:\\n\\t\\treturn last_prime_divisor\\n\\telse:\\n\\t\\treturn 1\\n\\n\\treturn last_prime_divisor if last_prime_divisor != 0 else number\\n\\n# testcase_count = int(input())\\n\\n# for i in range(testcase_count):\\n# \\tprint(str(run_testcase()))\\n\\t# run_testcase()\\n# run_testcase()\\nprint(str(run_testcase()))\\n\", \"\\\"\\\"\\\"  if need to find numbers 1...n such that n% (|i-j|>1)>0, can solv as p^k, p is prim num & answr or belw process\\\"\\\"\\\"\\n\\nwhile True:\\n    try:\\n        n = int(input())\\n        num, i = [], 2\\n        if n== 1:\\n            print(\\\"1\\\")\\n            continue\\n        while i*i <= n:\\n            if n%i == 0:\\n                num.append(i)\\n                while n%i == 0:n/=i\\n            i+=1\\n        if n>1:num.append(n)\\n        if len(num)>1:print(1)\\n        else:print(num[0])\\n            \\n    except EOFError:\\n        break\", \"from math import gcd\\nn = int(input())\\nif n == 1:\\n    print(1)\\n    return\\nelif n == 2:\\n    print(2)\\n    return\\nd = 0\\nfor i in range(2, n):\\n    if i * i > n:\\n        break\\n    if n % i:\\n        continue\\n    d = gcd(d, i)\\n    d = gcd(d, n // i)\\nif d:\\n    print(d)\\nelse:\\n    print(n)\\n\", \"from math import ceil\\ndef find_divisor(n):\\n    if n == 2:\\n        return []\\n    root = ceil(n ** 0.5)\\n    ans = []\\n    for i in range(2, root + 1):\\n        if n % i == 0:\\n            ans.extend([i, n / i])\\n\\n    return list(set(ans))\\n\\ndef fans(n):\\n    div = find_divisor(n)\\n    if len(div) == 0:\\n        return n\\n    else:\\n        m = min(div)\\n        divs = True\\n        for x in div:\\n            divs = divs and (x % m == 0)\\n            if divs == False:\\n                break\\n        \\n        if divs: \\n            return min(div)\\n        else:\\n            return 1\\n\\ndef __starting_point():\\n    n = int(input())\\n    print(fans(n))\\n\\n\\n\\n__starting_point()\", \"from math import gcd\\nn = int(input())\\nif n == 1:\\n    print(1)\\n    return\\nelif n == 2:\\n    print(2)\\n    return\\nelse:\\n    d = 0\\n    for i in range(2, n):\\n        if i * i > n:\\n            break\\n        if (n % i)==0:\\n        \\n           d = gcd(d, i)\\n           d = gcd(d, n // i)\\nif d:\\n    print(d)\\nelse:\\n    print(n)\\n\", \"import math\\n\\ndef IsPrime(x):\\n    if x<=2: return x==2\\n    top = int(math.sqrt(x))+1\\n    for i in range(2,top):\\n        if x%i==0:\\n            return False\\n    return True\\n\\nval = int(input())\\nif val==1: print('1')\\nelif IsPrime(val): print(val)\\nelse:\\n    cnt = 0\\n    top = int(math.sqrt(val))+1\\n    for i in range(2,top):\\n        if val%i==0:\\n            cnt += 1\\n            while val%i==0:\\n                val /= i\\n            if val==1:\\n                print(i)\\n            else: print('1')\\n            return\\n\", \"from math import sqrt, ceil\\n\\ndef mindiv(n):\\n    if n==1: return 1\\n    if n%2==0: return 2\\n    if n%3==0: return 3\\n    div,inc=5,2\\n    while div<ceil(sqrt(n))+1:\\n        if n%div == 0: return div\\n        div+=inc\\n        inc=6-inc\\n    return n\\nn=int(input())\\nm=mindiv(n)\\nwhile n%m==0 and n>m: n=n/m\\nprint(1 if n>m else m)\\n\", \"# #n14 = 951069502319\\n# n = int(input())\\n\\n# def isprime(n):\\n#     for i in range(2,int(n**0.5)+1):\\n#         if n%i==0:\\n#             return False\\n#     return True\\n# FOUND = -1\\n\\n# x = int(n**0.5)\\n# if x*x == n:\\n#     n = x\\n\\n# if not isprime(n):\\n#     for i in range(2, int(n**0.5)+1):\\n#         if isprime(i) and n%i==0:    \\n#             FOUND = i\\n#             break\\n#     # print (FOUND)\\n#     if FOUND != -1:\\n#         while(n % FOUND == 0):\\n#             n /= FOUND\\n#         if n == 1:\\n#             print (FOUND)\\n#         else:\\n#             print (1)\\n# else:\\n#     print (n)\\n\\nn = int(input())\\n\\ncheck = 0\\n\\nfor i in range(2,int(n**0.5)+1):\\n    if n%i==0:\\n        #khong phai snt\\n        check = 1\\n        while n%i==0:\\n            n /= i\\n        if n == 1:\\n            print (i)\\n            break\\n        else:\\n            print(1)\\n            break\\n\\nif check == 0:\\n    print (n)\\n\", \"import math\\nfrom sys import stdin\\n\\t\\ndef factorize(x):\\n\\ti = 2\\n\\ty = x\\n\\tprime_factors = []\\n\\twhile i * i <= x:\\n\\t\\tif y % i == 0:\\n\\t\\t\\tprime_factors.append(i)\\n\\t\\t\\twhile y % i == 0:\\n\\t\\t\\t\\ty //= i\\n\\t\\ti += 1\\n\\tif y > 1:\\n\\t\\tprime_factors.append(y)\\n\\treturn prime_factors\\n\\ndef main():\\n\\tn = int(input())\\n\\tprime_factors = factorize(n)\\n\\t\\n\\tif n == 1 or len(prime_factors) > 1:\\n\\t\\tprint(1)\\n\\telif n > prime_factors[0]:\\n\\t\\tprint(prime_factors[0])\\n\\telse:\\n\\t\\tprint(n)\\n\\ndef __starting_point():\\n\\tmain()\\n__starting_point()\", \"n = int(input())\\n\\ndef isPrime(val):\\n    if(val <2):\\n        return 0\\n    n = int(val**0.5)+1\\n    for i in range(2,n):\\n        if (val%i) ==0:\\n            return 0\\n    return val\\n\\ndef titlePaint(n):\\n    if n < 2 or isPrime(n):\\n        print(n)\\n        return 0\\n    n1 = int(n**0.5)*2\\n    prime =[]\\n    dic = dict()\\n    for i in range(2,n1):\\n        while n%i==0:\\n            prime.append(i)\\n            if i not in dic:\\n                dic[i] = 1\\n            else:\\n                dic[i]+=1\\n            n/=i\\n    dic1 = sorted(list(dic.items()), key=lambda x: x[1])\\n    if dic1[0][1] ==1:\\n        print(1)\\n        return 0\\n    if not dic:\\n        print(1)\\n        return 0\\n    if len(dic) ==1:\\n        print(dic1[0][0])\\n        return 0\\n    else:\\n        print(1)\\n        return 0\\ntitlePaint(n)\\n\", \"n = int(input())\\n\\ndef isPrime(val):\\n    if(val <2):\\n        return 0\\n    n = int(val**0.5)+1\\n    for i in range(2,n):\\n        if (val%i) ==0:\\n            return 0\\n    return val\\n\\ndef titlePaint(n):\\n    if n < 2 or isPrime(n):\\n        print(n)\\n        return 0\\n    n1 = int(n**0.5)*2\\n    dic = dict()\\n    for i in range(2,n1):\\n        while n%i==0:\\n            if i not in dic:\\n                dic[i] = 1\\n            else:\\n                dic[i]+=1\\n            n/=i\\n    dic1 = sorted(list(dic.items()), key=lambda x: x[1])\\n    if dic1[0][1] ==1:\\n        print(1)\\n        return 0\\n    if not dic:\\n        print(1)\\n        return 0\\n    if len(dic) ==1:\\n        print(dic1[0][0])\\n        return 0\\n    else:\\n        print(1)\\n        return 0\\ntitlePaint(n)\\n\", \"n = int(input())\\n\\ndef isPrime(val):\\n    if(val <2):\\n        return 0\\n    n = int(val**0.5)+1\\n    for i in range(2,n):\\n        if (val%i) ==0:\\n            return 0\\n    return 1\\n\\ndef titlePaint(n):\\n    if n < 2 or isPrime(n):\\n        print(n)\\n        return 0\\n    n1 = int(n**0.5)*2\\n    dic = dict()\\n    for i in range(2,n1):\\n        while n%i==0:\\n            if i not in dic:\\n                dic[i] = 1\\n            else:\\n                dic[i]+=1\\n            n/=i\\n    dic1 = sorted(list(dic.items()), key=lambda x: x[1])\\n    if dic1[0][1] ==1:\\n        print(1)\\n        return 0\\n    if not dic:\\n        print(1)\\n        return 0\\n    if len(dic) ==1:\\n        print(dic1[0][0])\\n        return 0\\n    else:\\n        print(1)\\n        return 0\\ntitlePaint(n)\\n\", \"from math import sqrt,gcd\\n\\n\\ndef gen_primes():\\n    \\\"\\\"\\\" Generate an infinite sequence of prime numbers.\\n    \\\"\\\"\\\"\\n    #\\n    D = {}\\n\\n    # The running integer that's checked for primeness\\n    q = 2\\n\\n    while True:\\n        if q not in D:\\n            # q is a new prime.\\n            # Yield it and mark its first multiple that isn't\\n            # already marked in previous iterations\\n            #\\n            yield q\\n            D[q * q] = [q]\\n        else:\\n            # q is composite. D[q] is the list of primes that\\n            # divide it. Since we've reached q, we no longer\\n            # need it in the map, but we'll mark the next\\n            # multiples of its witnesses to prepare for larger\\n            # numbers\\n            #\\n            for p in D[q]:\\n                D.setdefault(p + q, []).append(p)\\n            del D[q]\\n\\n        q += 1\\n\\n\\ndef is_prime(n):\\n    if n<=1:\\n        return False\\n    if n == 2:\\n        return True\\n    if n % 2 ==0:\\n        return False\\n    return all(n%i for i in range(3,int(sqrt(n))+1))\\n\\n\\ndef calculate_colors(n):\\n    primes = gen_primes()\\n    sqr_n = int(sqrt(n)) + 1\\n    if n == 1:\\n        return 1\\n    for p in primes:\\n        if n % p == 0:\\n            while n % p == 0:\\n                g= gcd(p,n)\\n                n = int(n//g)\\n            if n > 1:\\n                return 1\\n            else:\\n                return p\\n        if p > sqr_n:\\n            return n\\n\\n\\n\\nn = int(input())\\nprint(calculate_colors(n))\", \"import math\\n\\n\\ndef p(x):\\n    for i in range(2, int(math.sqrt(x)) + 1):\\n        if x % i == 0:\\n            return i\\n    else:\\n        return x\\n\\n\\ndef r(x):\\n    if round(x) - x < 0.5:\\n        return round(x)\\n    else:\\n        return round(x) - 1\\n\\n\\nn = int(input())\\nif n == 1:\\n    print(1)\\nelse:\\n    m = p(n)\\n    d = math.log(n, m)\\n    if m**r(d) == n:\\n        print(m)\\n    else:\\n        print(1)\\n\", \"import os, sys, math\\n\\nn = int(input())\\nsqt = int(math.sqrt(n))\\n\\ndef IsPrime(n):\\n\\tfor i in range(2,sqt+1):\\n\\t\\tif n%i == 0:\\n\\t\\t\\treturn False\\n\\treturn True\\nif IsPrime(n):\\n\\tprint(n)\\n\\treturn\\n\\nfound = 0\\nfor i in range(2,sqt+1):\\n\\tif n%i != 0: continue\\n\\tx = n/i\\n\\twhile x%i == 0:\\n\\t\\tx /= i\\n\\tif x == 1:\\n\\t\\tprint(i)\\n\\t\\treturn\\n\\telse:\\n\\t\\tfound += 1\\n\\t\\tif found == 2:\\n\\t\\t\\tprint(1)\\n\\t\\t\\treturn\\nprint(1)\\n\", \"import math\\ndef smallestDivisor(n):\\n    # if divisible by 2\\n    if (n % 2 == 0):\\n        return 2;\\n\\n        # iterate from 3 to sqrt(n)\\n    i = 3;\\n    while (i * i <= n):\\n        if (n % i == 0):\\n            return i;\\n        i += 2;\\n    return n;\\ndef isPower(div,n):\\n    if n == 1:\\n        return True\\n    ans = int(math.log(n,div))\\n    if pow(div,ans) == n or pow(div,ans+1) == n:\\n        return True\\n    else:\\n        False\\nnum = int(input().strip())\\nsmall = smallestDivisor(num)\\nif isPower(small,num):\\n    print(small)\\nelse:\\n    print(1)\\n\", \"'''input\\n5\\n'''\\nfrom math import gcd\\n\\nN = int(input())\\n\\nats = 0\\n\\ni = 1\\n\\nwhile i*i <= N:\\n\\tif N % i == 0:\\n\\t\\tif i != 1: ats = gcd(ats, i)\\n\\n\\t\\tats = gcd(ats, N // i)\\n\\n\\ti += 1\\n\\n\\nprint(ats)\", \"import math\\n\\nn = int(input())\\n\\nif n == 1:\\n\\tprint(\\\"1\\\")\\nelse:\\n\\tsmallestDivisor = n\\n\\tif n % 2 == 0:\\n\\t\\tsmallestDivisor = 2\\n\\telif n % 3 == 0:\\n\\t\\tsmallestDivisor = 3\\n\\telse:\\n\\t\\tfor i in range(5, int(math.sqrt(n)) + 1, 2):\\n\\t\\t\\tif n % i == 0:\\n\\t\\t\\t\\tsmallestDivisor = i\\n\\t\\t\\t\\tbreak\\n\\n\\twhile n % smallestDivisor == 0:\\n\\t\\tn //= smallestDivisor\\n\\n\\tprint(str(smallestDivisor) if n == 1 else \\\"1\\\")\\n\"]",
    "test": "{\n  \"inputs\": [\n    \"4\\n\",\n    \"5\\n\",\n    \"1\\n\",\n    \"2\\n\",\n    \"3\\n\",\n    \"6\\n\",\n    \"7\\n\",\n    \"8\\n\",\n    \"9\\n\",\n    \"1000000000000\\n\",\n    \"963201794869\\n\",\n    \"902076349729\\n\",\n    \"549755813888\\n\",\n    \"951069502319\\n\",\n    \"442654694329\\n\",\n    \"930881829259\\n\",\n    \"974059904437\\n\",\n    \"912943012301\\n\",\n    \"934464422329\\n\",\n    \"977592945289\\n\",\n    \"916517107801\\n\",\n    \"944364878731\\n\",\n    \"964483090561\\n\",\n    \"812990017201\\n\",\n    \"832972004929\\n\",\n    \"506623120463\\n\",\n    \"852891037441\\n\",\n    \"322687697779\\n\",\n    \"137858491849\\n\",\n    \"30517578125\\n\",\n    \"3486784401\\n\",\n    \"847288609443\\n\",\n    \"1073741824\\n\",\n    \"34359738368\\n\",\n    \"971324893193\\n\",\n    \"918797935650\\n\",\n    \"922350872881\\n\",\n    \"370758709373\\n\",\n    \"954531058771\\n\",\n    \"10460353203\\n\",\n    \"931667836027\\n\",\n    \"19463908527\\n\",\n    \"295697631125\\n\",\n    \"54241012609\\n\",\n    \"6469693230\\n\",\n    \"200560490130\\n\",\n    \"791429910106\\n\",\n    \"463116009722\\n\",\n    \"546739553053\\n\",\n    \"790666780911\\n\",\n    \"2000000014\\n\",\n    \"27\\n\",\n    \"20000038\\n\",\n    \"42\\n\",\n    \"8297518\\n\",\n    \"243\\n\",\n    \"4294967318\\n\",\n    \"2599082\\n\",\n    \"200001286\\n\",\n    \"20000282\\n\",\n    \"81\\n\",\n    \"2000006\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n\",\n    \"5\\n\",\n    \"1\\n\",\n    \"2\\n\",\n    \"3\\n\",\n    \"1\\n\",\n    \"7\\n\",\n    \"2\\n\",\n    \"3\\n\",\n    \"1\\n\",\n    \"963201794869\\n\",\n    \"949777\\n\",\n    \"2\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"930881829259\\n\",\n    \"974059904437\\n\",\n    \"912943012301\\n\",\n    \"966677\\n\",\n    \"988733\\n\",\n    \"957349\\n\",\n    \"9811\\n\",\n    \"991\\n\",\n    \"241\\n\",\n    \"97\\n\",\n    \"47\\n\",\n    \"31\\n\",\n    \"19\\n\",\n    \"13\\n\",\n    \"5\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"3\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"3\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"3\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"3\\n\",\n    \"1\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}