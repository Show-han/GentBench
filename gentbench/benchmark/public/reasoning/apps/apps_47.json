{
    "problem": "You are an expert Python programmer, and here is your task: One common way of digitalizing sound is to record sound intensity at particular time moments. For each time moment intensity is recorded as a non-negative integer. Thus we can represent a sound file as an array of $n$ non-negative integers.\n\nIf there are exactly $K$ distinct values in the array, then we need $k = \\lceil \\log_{2} K \\rceil$ bits to store each value. It then takes $nk$ bits to store the whole file.\n\nTo reduce the memory consumption we need to apply some compression. One common way is to reduce the number of possible intensity values. We choose two integers $l \\le r$, and after that all intensity values are changed in the following way: if the intensity value is within the range $[l;r]$, we don't change it. If it is less than $l$, we change it to $l$; if it is greater than $r$, we change it to $r$. You can see that we lose some low and some high intensities.\n\nYour task is to apply this compression in such a way that the file fits onto a disk of size $I$ bytes, and the number of changed elements in the array is minimal possible.\n\nWe remind you that $1$ byte contains $8$ bits.\n\n$k = \\lceil log_{2} K \\rceil$ is the smallest integer such that $K \\le 2^{k}$. In particular, if $K = 1$, then $k = 0$.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $I$ ($1 \\le n \\le 4 \\cdot 10^{5}$, $1 \\le I \\le 10^{8}$)\u00a0\u2014 the length of the array and the size of the disk in bytes, respectively.\n\nThe next line contains $n$ integers $a_{i}$ ($0 \\le a_{i} \\le 10^{9}$)\u00a0\u2014 the array denoting the sound file.\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the minimal possible number of changed elements.\n\n\n-----Examples-----\nInput\n6 1\n2 1 2 3 4 3\n\nOutput\n2\n\nInput\n6 2\n2 1 2 3 4 3\n\nOutput\n0\n\nInput\n6 1\n1 1 2 2 3 3\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first example we can choose $l=2, r=3$. The array becomes 2 2 2 3 3 3, the number of distinct elements is $K=2$, and the sound file fits onto the disk. Only two values are changed.\n\nIn the second example the disk is larger, so the initial file fits it and no changes are required.\n\nIn the third example we have to change both 1s or both 3s.",
    "solution": "[\"N, I = list(map(int, input().split()))\\nA = sorted([int(a) for a in input().split()])\\nB = []\\nj = 0\\nfor i in range(N):\\n    if i == 0 or A[i] == A[i-1]:\\n        B.append(j)\\n    else:\\n        j += 1\\n        B.append(j)\\n\\ndef calc(k):\\n    K = 1<<k\\n    i = 0\\n    j = 0\\n    ma = 0\\n    while j < N:\\n        if B[j]-B[i] <= K - 1:\\n            ma = max(ma, j-i+1)\\n            j += 1\\n        else:\\n            i += 1\\n    return N-ma\\n\\nans = 10**100\\nfor i in range(31):\\n    if i * N <= 8 * I:\\n        ans = min(ans, calc(i))\\n\\nprint(ans)\\n\\n\\n\", \"from itertools import groupby as gb\\n\\nN, I = map(int,input().split())\\nA = list(map(int,input().split()))\\nA = sorted(A)\\nl = []\\nG = gb(A)\\nfor k, v in G:\\n    l.append(len(list(v)))\\n\\nk = 100\\nwhile True:\\n    if N * k > 8 * I:\\n        k -= 1\\n    else:\\n        break\\nK = 2 ** k\\n\\nNN = len(l)\\nif NN <= K:\\n    print(0)\\n    return\\n\\nsm = sum(l[:K])\\nmx = sm\\n\\nfor i in range(K, NN):\\n    sm += l[i] - l[i - K]\\n    mx = max(mx, sm)\\n\\nprint(sum(l) - mx)\", \"from math import log, floor\\nn,I = list(map(int, input().split()))\\na = [int(s) for s in input().split()]\\nb = []\\na.sort()\\nb.append([-1, 0])\\nfor i in range(0, n):\\n    if a[i] == b[-1][0]:\\n        b[-1][1] += 1\\n    else:\\n        b.append([a[i], b[-1][1]+1])\\nmaxk = I*8//n\\nmaxK = 1<<maxk\\n# print(maxk, maxK)\\nans = n\\n# print(b)\\nif len(b)-1 < maxK:\\n    ans = 0\\nelse:\\n    for i in range(len(b)-maxK):\\n        chg = n-(b[i+maxK][1]-b[i][1])\\n        if chg < ans:\\n            ans = chg\\nprint(ans)\\n\", \"import math\\n\\nimport sys\\ninput = sys.stdin.readline\\n\\nn, I = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\n\\nk = math.floor((I*8)/n)\\nK = 2**min(k, 20)\\n\\n# find distinct\\ns = sorted(set(A))\\ndis = len(s)\\n\\n# count occurence\\ncount = {}\\n\\nfor i in range(n):\\n    if A[i] not in count:\\n        count[A[i]] = 1\\n    else:\\n        count[A[i]] += 1\\n\\n# test eliminating\\ndiff = max(dis - K, 0)\\n\\nct = 0\\nfor i in range(diff):\\n    ct += count[s[i]]\\nans = ct\\n\\nfor i in range(diff-1, -1, -1):\\n    ct -= count[s[i]]\\n    ct += count[s[i+K]]\\n    ans = min(ans, ct)\\n\\nprint(ans)\\n\", \"import sys\\nfrom collections import defaultdict\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n    n, I = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    K = 2**min(20, 8*I//n)\\n\\n    a.sort()\\n    c = []\\n    pos = 0\\n    while pos < n:\\n        r = pos\\n        while r+1 < n and a[pos] == a[r+1]:\\n            r += 1\\n        c.append(r-pos+1)\\n        pos = r + 1\\n\\n    if K > len(c):\\n        print(0)\\n    else:\\n        pref = c.copy()\\n        suff = c.copy()\\n        for i in range(1, len(c)):\\n            pref[i] += pref[i-1]\\n        for i in range(len(c)-2, -1, -1):\\n            suff[i] += suff[i+1]\\n\\n        res = sum(c)\\n        l = 0\\n        r = K-1\\n        while r < len(c):\\n            s1 = 0 if l == 0 else pref[l-1]\\n            s2 = 0 if r == len(c)-1 else suff[r+1]\\n            res = min(res, s1+s2)\\n            l += 1\\n            r += 1\\n\\n        print(res)\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"R=lambda:map(int,input().split())\\nn,I=R()\\na=sorted(R())\\nb=[0]+[i+1for i in range(n-1)if a[i]<a[i+1]]\\nprint(n-max(y-x for x,y in zip(b,b[1<<8*I//n:]+[n])))\", \"R=lambda:map(int,input().split())\\nn,I=R()\\na=-1,*sorted(R())\\nb=[i for i in range(n)if a[i]<a[i+1]]\\nprint(n-max(y-x for x,y in zip(b,b[1<<8*I//n:]+[n])))\", \"R=lambda:map(int,input().split())\\nn,I=R()\\na=[-1]+sorted(R())\\nb=[i for i in range(n)if a[i]<a[i+1]]\\nprint(n-max(y-x for x,y in zip(b,b[1<<8*I//n:]+[n])))\", \"from sys import stdin\\ninput=stdin.readline\\nn,I=map(int,input().split())\\na=sorted(list(map(int,input().split())))\\nkey=[]\\nk=min(I*8//n,20)\\nK=min(2**k,n)\\nlast=-1\\nfor i in range(n):\\n    if a[i]==last:\\n        key[-1]+=1\\n    else:\\n        key.append(1)\\n        last=a[i]\\nnow=0\\nbest=0\\nfor i in range(len(key)):\\n    if i<K:\\n        now+=key[i]\\n    else:\\n        now+=key[i]\\n        now-=key[i-K]\\n    best=max(now,best)\\nprint(n-best)\", \"from sys import stdin\\ninput=stdin.readline\\nn,I=map(int,input().split())\\na=sorted(list(map(int,input().split())))\\nkey=[]\\nk=min(I*8//n,20)\\nK=min(2**k,n)\\nlast=-1\\nfor i in range(n):\\n    if a[i]==last:\\n        key[-1]+=1\\n    else:\\n        key.append(1)\\n        last=a[i]\\nnow=best=0\\nfor i in range(len(key)):\\n    if i<K:\\n        now+=key[i]\\n    else:\\n        now+=key[i]\\n        now-=key[i-K]\\n    best=max(now,best)\\nprint(n-best)\", \"import math\\nn,I=[int(x) for x in input().split()]\\nlis=[int(x) for x in input().split()]\\n\\n\\n\\ndic=dict()\\n\\nfor i in lis:\\n    if i in dic:\\n        dic[i]+=1\\n    else:\\n        dic[i]=1\\n\\n\\ndisLis=sorted(dic)\\nnowK=len(disLis)\\n\\nif math.log2(nowK)>(I*8)//n:\\n\\n    maxK=2**((I*8)//n)\\n    needMin=nowK-maxK\\n    \\n    minChange=0\\n    \\n    for i in range(needMin):\\n        minChange+=dic[disLis[i]]\\n    \\n    befChange=minChange\\n    \\n    for i in range(1,needMin+1):\\n        befChange=befChange-dic[disLis[needMin-i]]+dic[disLis[-i]]\\n        if befChange<minChange:\\n            minChange=befChange\\n\\n    print(minChange)\\nelse:\\n    print(0)\\n\", \"import math\\n\\nn, I = map(int, input().split())\\nif I >= n*round(math.log(n,2)+0.5)/8:\\n    print(0)\\nelse:\\n    a = sorted([x for x in map(int, input().split())])\\n    a=[-1]+a\\n    b=[i for i in range(n) if a[i] < a[i+1]]\\n    ans = set()\\n    for x in zip(b, b[2**(I*8//n):]+[n]):\\n        ans.add(x[1]-x[0])\\n    print(n-max(ans))\", \"n,i=list(map(int,input().split()))\\nk=2**(8*i//n) if 8*i//n < 20 else n\\na=[int(x) for x in input().split()]\\na.sort()\\nfreq = [1]\\nfor i in range(1, len(a)):\\n\\tif a[i-1] == a[i]:\\n\\t\\tfreq[-1] += 1\\n\\telse:\\n\\t\\tfreq.append(1)\\nwindow = sum(freq[:k])\\nans = window\\nfor i in range(k, len(freq)):\\n\\twindow += freq[i]\\n\\twindow -= freq[i-k]\\n\\tans = max(ans, window)\\n\\nprint(n-ans)\\n\", \"n,i=list(map(int,input().split()))\\nk=2**(8*i//n) if 8*i//n < 20 else n\\na=[int(x) for x in input().split()]\\na.sort()\\nfreq = [1]\\nfor i in range(1, len(a)):\\n\\tif a[i-1] == a[i]:\\n\\t\\tfreq[-1] += 1\\n\\telse:\\n\\t\\tfreq.append(1)\\nwindow = sum(freq[:k])\\nans = window\\nfor i in range(k, len(freq)):\\n\\twindow += freq[i]\\n\\twindow -= freq[i-k]\\n\\tans = max(ans, window)\\n\\nprint(n-ans)\\n\", \"import math\\n\\nn, m = list(map(int, input().split()))\\nlst = list(map(int, input().split()))\\n\\nlst.sort()\\nlast_val = -1\\nfreq_list = []\\n\\nfor i in range(n):\\n\\tif lst[i] != last_val:\\n\\t\\tlast_val = lst[i]\\n\\t\\tfreq_list.append(1)\\n\\telse:\\n\\t\\tfreq_list[-1] += 1\\n\\nk = len(freq_list)\\n\\nfor i in range(k, 0, -1):\\n\\tif n * math.ceil(math.log2(i)) <= m * 8:\\n\\t\\tk = i\\n\\t\\tbreak\\n\\nmx = 0\\ntot = sum(freq_list[:k])\\nmx = max(tot, mx)\\nfor i in range(k, len(freq_list)):\\n\\ttot = tot + freq_list[i] - freq_list[i-k]\\n\\tmx = max(mx, tot)\\n\\nprint(n-mx)\\n\\n\\n\", \"R=lambda:map(int,input().split())\\nn,I=R()\\na=-1,*sorted(R())\\nb=[i for i in range(n)if a[i]<a[i+1]]\\nprint(n-max(y-x for x,y in zip(b,b[1<<8*I//n:]+[n])))\", \"from itertools import groupby\\n\\n\\ndef mp3(n, I, a):\\n    k = int((I * 8) / n)\\n    d = 1 << k\\n    c = [len(list(group)) for (key, group) in groupby(sorted(a))]\\n    chgs = sum(c[d:])\\n    ans = chgs\\n    for i in range(0, len(c) - d):\\n        chgs += c[i]\\n        chgs -= c[i + d]\\n        ans = min(ans, chgs)\\n    return ans\\n\\n\\ndef __starting_point():\\n    nn, II = list(map(int, input().split()))\\n    aa = list(map(int, input().split()))\\n    print(mp3(nn, II, aa))\\n__starting_point()\"]",
    "test": "{\n  \"inputs\": [\n    \"6 1\\n2 1 2 3 4 3\\n\",\n    \"6 2\\n2 1 2 3 4 3\\n\",\n    \"6 1\\n1 1 2 2 3 3\\n\",\n    \"10 1\\n589934963 440265648 161048053 196789927 951616256 63404428 660569162 779938975 237139603 31052281\\n\",\n    \"40 1\\n296861916 110348711 213599874 304979682 902720247 958794999 445626005 29685036 968749742 772121742 50110079 72399009 347194050 322418543 594963355 407238845 847251668 210179965 293944170 300817194 842872332 82882809 446438478 304657690 343250734 567326942 47727237 662711343 59995716 812214268 994315801 193163726 656281454 249432773 772706196 977253852 342331261 182317828 550599535 3939813\\n\",\n    \"50 20\\n592183311 362557946 154127088 616872926 395353745 675069471 509655682 79915471 356656666 937992998 304422065 724106263 472338455 792258113 796069631 663370025 201799298 566151622 722278085 508905399 703159587 690854023 925377265 11010958 69791159 990158269 535460930 167415727 999216963 237203826 693974848 530462137 555061429 744123832 887168514 479773974 575345653 282142246 899762676 446274594 338501746 168668673 408947684 226311538 645441958 258972430 216333311 338561078 123733185 539429791\\n\",\n    \"1 1\\n1\\n\",\n    \"2 1\\n1 3\\n\",\n    \"100 1000\\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\\n\",\n    \"81 800\\n2 8 5 1 10 5 9 9 3 5 6 6 2 8 2 2 6 3 8 7 2 5 3 4 3 3 2 7 9 6 8 7 2 9 10 3 8 10 6 5 4 2 3 4 4 5 2 2 4 9 8 5 3 8 8 10 4 2 10 9 7 6 1 3 9 7 1 3 5 9 7 6 1 10 1 1 7 2 4 9 10\\n\",\n    \"8 33\\n1 2 3 4 5 6 7 8\\n\",\n    \"8 64\\n1 2 3 4 5 6 7 8\\n\",\n    \"8 65\\n1 2 3 4 5 6 7 8\\n\",\n    \"8 31\\n2 8 5 1 10 5 9 9\\n\",\n    \"3 11\\n1 2 3\\n\",\n    \"5 100000\\n1 2 3 4 5\\n\",\n    \"2 100000000\\n1 2\\n\",\n    \"5 100000000\\n1 2 3 4 5\\n\",\n    \"100 1000\\n1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10\\n\",\n    \"100 800\\n1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10\\n\",\n    \"8 10000000\\n1 2 3 4 5 6 7 8\\n\",\n    \"1 4\\n1\\n\",\n    \"5 1234567\\n1 2 3 4 5\\n\",\n    \"20 8\\n1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2\\n\",\n    \"9 1\\n1 2 1 2 1 2 1 2 1000000000\\n\",\n    \"1 100000000\\n69\\n\",\n    \"8 63\\n1 2 3 4 5 6 7 8\\n\",\n    \"50 400\\n0 30 60 90 120 150 180 210 240 270 300 330 360 390 420 450 480 510 540 570 600 630 660 690 720 750 780 810 840 870 900 930 960 990 1020 1050 1080 1110 1140 1170 1200 1230 1260 1290 1320 1350 1380 1410 1440 1470\\n\",\n    \"8 30\\n1 2 3 4 5 6 7 8\\n\",\n    \"8 31\\n1 2 3 4 5 6 7 8\\n\",\n    \"1 100000000\\n1\\n\",\n    \"8 32\\n1 2 3 4 5 6 7 8\\n\",\n    \"10 1000000\\n1 2 3 4 5 6 7 8 9 10\\n\",\n    \"2 1000\\n1 2\\n\",\n    \"4 2\\n2 2 2 1\\n\",\n    \"10 100\\n1 2 3 4 5 6 7 8 9 10\\n\",\n    \"64 40\\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\\n\",\n    \"3 100000000\\n1 1 2\\n\",\n    \"8 31\\n1 1 2 2 3 3 4 4\\n\",\n    \"2 10000\\n1 2\\n\",\n    \"2 64\\n1 2\\n\",\n    \"100 1249\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100\\n\",\n    \"2 1000000\\n1 1\\n\",\n    \"2 64\\n2 3\\n\",\n    \"8 64\\n1 1 1 1 1 1 1 1\\n\",\n    \"6 100000\\n2 1 2 3 4 3\\n\",\n    \"5 100000000\\n1 1 2 2 5\\n\",\n    \"2 100000\\n2 3\\n\",\n    \"8 31\\n1 1 1 1 1 1 1 1\\n\",\n    \"2 8\\n1 2\\n\",\n    \"6 100000000\\n2 1 2 3 4 3\\n\",\n    \"2 30000000\\n1 3\\n\",\n    \"10 100\\n1 1 2 2 2 3 3 3 3 4\\n\",\n    \"2 30000000\\n2 5\\n\",\n    \"2 40000000\\n3 9\\n\",\n    \"3 120\\n1 2 3\\n\",\n    \"6 48\\n2 1 2 3 4 3\\n\",\n    \"5 1000000\\n1 2 3 3 4\\n\",\n    \"6 1213\\n1 1 2 2 3 3\\n\",\n    \"5 100\\n1 2 3 4 5\\n\",\n    \"1 10000000\\n1\\n\",\n    \"9 100000000\\n1 2 3 4 5 6 7 8 9\\n\",\n    \"5 100000\\n1 2 2 3 4\\n\",\n    \"3 10000000\\n1 2 3\\n\",\n    \"7 999992\\n1 2 3 4 5 6 7\\n\",\n    \"3 288383\\n2 2 2\\n\",\n    \"5 100000\\n1 2 3 3 4\\n\",\n    \"5 70\\n1 2 3 4 5\\n\",\n    \"10 500\\n1 2 3 4 5 6 7 8 9 10\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n\",\n    \"0\\n\",\n    \"2\\n\",\n    \"9\\n\",\n    \"39\\n\",\n    \"42\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"5\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\"\n  ]\n}",
    "tags": [
        "reasoning/coding"
    ]
}